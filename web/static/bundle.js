/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// -*- coding: utf-8 -*-
	__webpack_require__(1);
	__webpack_require__(1);
	// require('./bower_components/foundation/js/vendor/modernizr.js');
	// require('./bower_components/font-awesome/css/font-awesome.css');
	__webpack_require__(5);
	__webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./foundation.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./foundation.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	exports.push([module.id, "meta.foundation-version {\n  font-family: \"/5.5.2/\"; }\n\nmeta.foundation-mq-small {\n  font-family: \"/only screen/\";\n  width: 0; }\n\nmeta.foundation-mq-small-only {\n  font-family: \"/only screen and (max-width: 40em)/\";\n  width: 0; }\n\nmeta.foundation-mq-medium {\n  font-family: \"/only screen and (min-width:40.0625em)/\";\n  width: 40.0625em; }\n\nmeta.foundation-mq-medium-only {\n  font-family: \"/only screen and (min-width:40.0625em) and (max-width:64em)/\";\n  width: 40.0625em; }\n\nmeta.foundation-mq-large {\n  font-family: \"/only screen and (min-width:64.0625em)/\";\n  width: 64.0625em; }\n\nmeta.foundation-mq-large-only {\n  font-family: \"/only screen and (min-width:64.0625em) and (max-width:90em)/\";\n  width: 64.0625em; }\n\nmeta.foundation-mq-xlarge {\n  font-family: \"/only screen and (min-width:90.0625em)/\";\n  width: 90.0625em; }\n\nmeta.foundation-mq-xlarge-only {\n  font-family: \"/only screen and (min-width:90.0625em) and (max-width:120em)/\";\n  width: 90.0625em; }\n\nmeta.foundation-mq-xxlarge {\n  font-family: \"/only screen and (min-width:120.0625em)/\";\n  width: 120.0625em; }\n\nmeta.foundation-data-attribute-namespace {\n  font-family: false; }\n\nhtml, body {\n  height: 100%; }\n\nhtml {\n  box-sizing: border-box; }\n\n*,\n*:before,\n*:after {\n  -webkit-box-sizing: inherit;\n  -moz-box-sizing: inherit;\n  box-sizing: inherit; }\n\nhtml,\nbody {\n  font-size: 100%; }\n\nbody {\n  background: #fff;\n  color: #222;\n  cursor: auto;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-style: normal;\n  font-weight: normal;\n  line-height: 1.5;\n  margin: 0;\n  padding: 0;\n  position: relative; }\n\na:hover {\n  cursor: pointer; }\n\nimg {\n  max-width: 100%;\n  height: auto; }\n\nimg {\n  -ms-interpolation-mode: bicubic; }\n\n#map_canvas img,\n#map_canvas embed,\n#map_canvas object,\n.map_canvas img,\n.map_canvas embed,\n.map_canvas object,\n.mqa-display img,\n.mqa-display embed,\n.mqa-display object {\n  max-width: none !important; }\n\n.left {\n  float: left !important; }\n\n.right {\n  float: right !important; }\n\n.clearfix:before, .clearfix:after {\n  content: \" \";\n  display: table; }\n.clearfix:after {\n  clear: both; }\n\n.hide {\n  display: none; }\n\n.invisible {\n  visibility: hidden; }\n\n.antialiased {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n\nimg {\n  display: inline-block;\n  vertical-align: middle; }\n\ntextarea {\n  height: auto;\n  min-height: 50px; }\n\nselect {\n  width: 100%; }\n\n.row {\n  margin: 0 auto;\n  max-width: 62.5rem;\n  width: 100%; }\n  .row:before, .row:after {\n    content: \" \";\n    display: table; }\n  .row:after {\n    clear: both; }\n  .row.collapse > .column,\n  .row.collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .row.collapse .row {\n    margin-left: 0;\n    margin-right: 0; }\n  .row .row {\n    margin: 0 -0.9375rem;\n    max-width: none;\n    width: auto; }\n    .row .row:before, .row .row:after {\n      content: \" \";\n      display: table; }\n    .row .row:after {\n      clear: both; }\n    .row .row.collapse {\n      margin: 0;\n      max-width: none;\n      width: auto; }\n      .row .row.collapse:before, .row .row.collapse:after {\n        content: \" \";\n        display: table; }\n      .row .row.collapse:after {\n        clear: both; }\n\n.column,\n.columns {\n  padding-left: 0.9375rem;\n  padding-right: 0.9375rem;\n  width: 100%;\n  float: left; }\n\n.column + .column:last-child,\n.columns + .column:last-child, .column +\n.columns:last-child,\n.columns +\n.columns:last-child {\n  float: right; }\n.column + .column.end,\n.columns + .column.end, .column +\n.columns.end,\n.columns +\n.columns.end {\n  float: left; }\n\n@media only screen {\n  .small-push-0 {\n    position: relative;\n    left: 0;\n    right: auto; }\n\n  .small-pull-0 {\n    position: relative;\n    right: 0;\n    left: auto; }\n\n  .small-push-1 {\n    position: relative;\n    left: 8.33333%;\n    right: auto; }\n\n  .small-pull-1 {\n    position: relative;\n    right: 8.33333%;\n    left: auto; }\n\n  .small-push-2 {\n    position: relative;\n    left: 16.66667%;\n    right: auto; }\n\n  .small-pull-2 {\n    position: relative;\n    right: 16.66667%;\n    left: auto; }\n\n  .small-push-3 {\n    position: relative;\n    left: 25%;\n    right: auto; }\n\n  .small-pull-3 {\n    position: relative;\n    right: 25%;\n    left: auto; }\n\n  .small-push-4 {\n    position: relative;\n    left: 33.33333%;\n    right: auto; }\n\n  .small-pull-4 {\n    position: relative;\n    right: 33.33333%;\n    left: auto; }\n\n  .small-push-5 {\n    position: relative;\n    left: 41.66667%;\n    right: auto; }\n\n  .small-pull-5 {\n    position: relative;\n    right: 41.66667%;\n    left: auto; }\n\n  .small-push-6 {\n    position: relative;\n    left: 50%;\n    right: auto; }\n\n  .small-pull-6 {\n    position: relative;\n    right: 50%;\n    left: auto; }\n\n  .small-push-7 {\n    position: relative;\n    left: 58.33333%;\n    right: auto; }\n\n  .small-pull-7 {\n    position: relative;\n    right: 58.33333%;\n    left: auto; }\n\n  .small-push-8 {\n    position: relative;\n    left: 66.66667%;\n    right: auto; }\n\n  .small-pull-8 {\n    position: relative;\n    right: 66.66667%;\n    left: auto; }\n\n  .small-push-9 {\n    position: relative;\n    left: 75%;\n    right: auto; }\n\n  .small-pull-9 {\n    position: relative;\n    right: 75%;\n    left: auto; }\n\n  .small-push-10 {\n    position: relative;\n    left: 83.33333%;\n    right: auto; }\n\n  .small-pull-10 {\n    position: relative;\n    right: 83.33333%;\n    left: auto; }\n\n  .small-push-11 {\n    position: relative;\n    left: 91.66667%;\n    right: auto; }\n\n  .small-pull-11 {\n    position: relative;\n    right: 91.66667%;\n    left: auto; }\n\n  .column,\n  .columns {\n    position: relative;\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem;\n    float: left; }\n\n  .small-1 {\n    width: 8.33333%; }\n\n  .small-2 {\n    width: 16.66667%; }\n\n  .small-3 {\n    width: 25%; }\n\n  .small-4 {\n    width: 33.33333%; }\n\n  .small-5 {\n    width: 41.66667%; }\n\n  .small-6 {\n    width: 50%; }\n\n  .small-7 {\n    width: 58.33333%; }\n\n  .small-8 {\n    width: 66.66667%; }\n\n  .small-9 {\n    width: 75%; }\n\n  .small-10 {\n    width: 83.33333%; }\n\n  .small-11 {\n    width: 91.66667%; }\n\n  .small-12 {\n    width: 100%; }\n\n  .small-offset-0 {\n    margin-left: 0 !important; }\n\n  .small-offset-1 {\n    margin-left: 8.33333% !important; }\n\n  .small-offset-2 {\n    margin-left: 16.66667% !important; }\n\n  .small-offset-3 {\n    margin-left: 25% !important; }\n\n  .small-offset-4 {\n    margin-left: 33.33333% !important; }\n\n  .small-offset-5 {\n    margin-left: 41.66667% !important; }\n\n  .small-offset-6 {\n    margin-left: 50% !important; }\n\n  .small-offset-7 {\n    margin-left: 58.33333% !important; }\n\n  .small-offset-8 {\n    margin-left: 66.66667% !important; }\n\n  .small-offset-9 {\n    margin-left: 75% !important; }\n\n  .small-offset-10 {\n    margin-left: 83.33333% !important; }\n\n  .small-offset-11 {\n    margin-left: 91.66667% !important; }\n\n  .small-reset-order {\n    float: left;\n    left: auto;\n    margin-left: 0;\n    margin-right: 0;\n    right: auto; }\n\n  .column.small-centered,\n  .columns.small-centered {\n    margin-left: auto;\n    margin-right: auto;\n    float: none; }\n\n  .column.small-uncentered,\n  .columns.small-uncentered {\n    float: left;\n    margin-left: 0;\n    margin-right: 0; }\n\n  .column.small-centered:last-child,\n  .columns.small-centered:last-child {\n    float: none; }\n\n  .column.small-uncentered:last-child,\n  .columns.small-uncentered:last-child {\n    float: left; }\n\n  .column.small-uncentered.opposite,\n  .columns.small-uncentered.opposite {\n    float: right; }\n\n  .row.small-collapse > .column,\n  .row.small-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .row.small-collapse .row {\n    margin-left: 0;\n    margin-right: 0; }\n  .row.small-uncollapse > .column,\n  .row.small-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem;\n    float: left; } }\n@media only screen and (min-width: 40.0625em) {\n  .medium-push-0 {\n    position: relative;\n    left: 0;\n    right: auto; }\n\n  .medium-pull-0 {\n    position: relative;\n    right: 0;\n    left: auto; }\n\n  .medium-push-1 {\n    position: relative;\n    left: 8.33333%;\n    right: auto; }\n\n  .medium-pull-1 {\n    position: relative;\n    right: 8.33333%;\n    left: auto; }\n\n  .medium-push-2 {\n    position: relative;\n    left: 16.66667%;\n    right: auto; }\n\n  .medium-pull-2 {\n    position: relative;\n    right: 16.66667%;\n    left: auto; }\n\n  .medium-push-3 {\n    position: relative;\n    left: 25%;\n    right: auto; }\n\n  .medium-pull-3 {\n    position: relative;\n    right: 25%;\n    left: auto; }\n\n  .medium-push-4 {\n    position: relative;\n    left: 33.33333%;\n    right: auto; }\n\n  .medium-pull-4 {\n    position: relative;\n    right: 33.33333%;\n    left: auto; }\n\n  .medium-push-5 {\n    position: relative;\n    left: 41.66667%;\n    right: auto; }\n\n  .medium-pull-5 {\n    position: relative;\n    right: 41.66667%;\n    left: auto; }\n\n  .medium-push-6 {\n    position: relative;\n    left: 50%;\n    right: auto; }\n\n  .medium-pull-6 {\n    position: relative;\n    right: 50%;\n    left: auto; }\n\n  .medium-push-7 {\n    position: relative;\n    left: 58.33333%;\n    right: auto; }\n\n  .medium-pull-7 {\n    position: relative;\n    right: 58.33333%;\n    left: auto; }\n\n  .medium-push-8 {\n    position: relative;\n    left: 66.66667%;\n    right: auto; }\n\n  .medium-pull-8 {\n    position: relative;\n    right: 66.66667%;\n    left: auto; }\n\n  .medium-push-9 {\n    position: relative;\n    left: 75%;\n    right: auto; }\n\n  .medium-pull-9 {\n    position: relative;\n    right: 75%;\n    left: auto; }\n\n  .medium-push-10 {\n    position: relative;\n    left: 83.33333%;\n    right: auto; }\n\n  .medium-pull-10 {\n    position: relative;\n    right: 83.33333%;\n    left: auto; }\n\n  .medium-push-11 {\n    position: relative;\n    left: 91.66667%;\n    right: auto; }\n\n  .medium-pull-11 {\n    position: relative;\n    right: 91.66667%;\n    left: auto; }\n\n  .column,\n  .columns {\n    position: relative;\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem;\n    float: left; }\n\n  .medium-1 {\n    width: 8.33333%; }\n\n  .medium-2 {\n    width: 16.66667%; }\n\n  .medium-3 {\n    width: 25%; }\n\n  .medium-4 {\n    width: 33.33333%; }\n\n  .medium-5 {\n    width: 41.66667%; }\n\n  .medium-6 {\n    width: 50%; }\n\n  .medium-7 {\n    width: 58.33333%; }\n\n  .medium-8 {\n    width: 66.66667%; }\n\n  .medium-9 {\n    width: 75%; }\n\n  .medium-10 {\n    width: 83.33333%; }\n\n  .medium-11 {\n    width: 91.66667%; }\n\n  .medium-12 {\n    width: 100%; }\n\n  .medium-offset-0 {\n    margin-left: 0 !important; }\n\n  .medium-offset-1 {\n    margin-left: 8.33333% !important; }\n\n  .medium-offset-2 {\n    margin-left: 16.66667% !important; }\n\n  .medium-offset-3 {\n    margin-left: 25% !important; }\n\n  .medium-offset-4 {\n    margin-left: 33.33333% !important; }\n\n  .medium-offset-5 {\n    margin-left: 41.66667% !important; }\n\n  .medium-offset-6 {\n    margin-left: 50% !important; }\n\n  .medium-offset-7 {\n    margin-left: 58.33333% !important; }\n\n  .medium-offset-8 {\n    margin-left: 66.66667% !important; }\n\n  .medium-offset-9 {\n    margin-left: 75% !important; }\n\n  .medium-offset-10 {\n    margin-left: 83.33333% !important; }\n\n  .medium-offset-11 {\n    margin-left: 91.66667% !important; }\n\n  .medium-reset-order {\n    float: left;\n    left: auto;\n    margin-left: 0;\n    margin-right: 0;\n    right: auto; }\n\n  .column.medium-centered,\n  .columns.medium-centered {\n    margin-left: auto;\n    margin-right: auto;\n    float: none; }\n\n  .column.medium-uncentered,\n  .columns.medium-uncentered {\n    float: left;\n    margin-left: 0;\n    margin-right: 0; }\n\n  .column.medium-centered:last-child,\n  .columns.medium-centered:last-child {\n    float: none; }\n\n  .column.medium-uncentered:last-child,\n  .columns.medium-uncentered:last-child {\n    float: left; }\n\n  .column.medium-uncentered.opposite,\n  .columns.medium-uncentered.opposite {\n    float: right; }\n\n  .row.medium-collapse > .column,\n  .row.medium-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .row.medium-collapse .row {\n    margin-left: 0;\n    margin-right: 0; }\n  .row.medium-uncollapse > .column,\n  .row.medium-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem;\n    float: left; }\n\n  .push-0 {\n    position: relative;\n    left: 0;\n    right: auto; }\n\n  .pull-0 {\n    position: relative;\n    right: 0;\n    left: auto; }\n\n  .push-1 {\n    position: relative;\n    left: 8.33333%;\n    right: auto; }\n\n  .pull-1 {\n    position: relative;\n    right: 8.33333%;\n    left: auto; }\n\n  .push-2 {\n    position: relative;\n    left: 16.66667%;\n    right: auto; }\n\n  .pull-2 {\n    position: relative;\n    right: 16.66667%;\n    left: auto; }\n\n  .push-3 {\n    position: relative;\n    left: 25%;\n    right: auto; }\n\n  .pull-3 {\n    position: relative;\n    right: 25%;\n    left: auto; }\n\n  .push-4 {\n    position: relative;\n    left: 33.33333%;\n    right: auto; }\n\n  .pull-4 {\n    position: relative;\n    right: 33.33333%;\n    left: auto; }\n\n  .push-5 {\n    position: relative;\n    left: 41.66667%;\n    right: auto; }\n\n  .pull-5 {\n    position: relative;\n    right: 41.66667%;\n    left: auto; }\n\n  .push-6 {\n    position: relative;\n    left: 50%;\n    right: auto; }\n\n  .pull-6 {\n    position: relative;\n    right: 50%;\n    left: auto; }\n\n  .push-7 {\n    position: relative;\n    left: 58.33333%;\n    right: auto; }\n\n  .pull-7 {\n    position: relative;\n    right: 58.33333%;\n    left: auto; }\n\n  .push-8 {\n    position: relative;\n    left: 66.66667%;\n    right: auto; }\n\n  .pull-8 {\n    position: relative;\n    right: 66.66667%;\n    left: auto; }\n\n  .push-9 {\n    position: relative;\n    left: 75%;\n    right: auto; }\n\n  .pull-9 {\n    position: relative;\n    right: 75%;\n    left: auto; }\n\n  .push-10 {\n    position: relative;\n    left: 83.33333%;\n    right: auto; }\n\n  .pull-10 {\n    position: relative;\n    right: 83.33333%;\n    left: auto; }\n\n  .push-11 {\n    position: relative;\n    left: 91.66667%;\n    right: auto; }\n\n  .pull-11 {\n    position: relative;\n    right: 91.66667%;\n    left: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .large-push-0 {\n    position: relative;\n    left: 0;\n    right: auto; }\n\n  .large-pull-0 {\n    position: relative;\n    right: 0;\n    left: auto; }\n\n  .large-push-1 {\n    position: relative;\n    left: 8.33333%;\n    right: auto; }\n\n  .large-pull-1 {\n    position: relative;\n    right: 8.33333%;\n    left: auto; }\n\n  .large-push-2 {\n    position: relative;\n    left: 16.66667%;\n    right: auto; }\n\n  .large-pull-2 {\n    position: relative;\n    right: 16.66667%;\n    left: auto; }\n\n  .large-push-3 {\n    position: relative;\n    left: 25%;\n    right: auto; }\n\n  .large-pull-3 {\n    position: relative;\n    right: 25%;\n    left: auto; }\n\n  .large-push-4 {\n    position: relative;\n    left: 33.33333%;\n    right: auto; }\n\n  .large-pull-4 {\n    position: relative;\n    right: 33.33333%;\n    left: auto; }\n\n  .large-push-5 {\n    position: relative;\n    left: 41.66667%;\n    right: auto; }\n\n  .large-pull-5 {\n    position: relative;\n    right: 41.66667%;\n    left: auto; }\n\n  .large-push-6 {\n    position: relative;\n    left: 50%;\n    right: auto; }\n\n  .large-pull-6 {\n    position: relative;\n    right: 50%;\n    left: auto; }\n\n  .large-push-7 {\n    position: relative;\n    left: 58.33333%;\n    right: auto; }\n\n  .large-pull-7 {\n    position: relative;\n    right: 58.33333%;\n    left: auto; }\n\n  .large-push-8 {\n    position: relative;\n    left: 66.66667%;\n    right: auto; }\n\n  .large-pull-8 {\n    position: relative;\n    right: 66.66667%;\n    left: auto; }\n\n  .large-push-9 {\n    position: relative;\n    left: 75%;\n    right: auto; }\n\n  .large-pull-9 {\n    position: relative;\n    right: 75%;\n    left: auto; }\n\n  .large-push-10 {\n    position: relative;\n    left: 83.33333%;\n    right: auto; }\n\n  .large-pull-10 {\n    position: relative;\n    right: 83.33333%;\n    left: auto; }\n\n  .large-push-11 {\n    position: relative;\n    left: 91.66667%;\n    right: auto; }\n\n  .large-pull-11 {\n    position: relative;\n    right: 91.66667%;\n    left: auto; }\n\n  .column,\n  .columns {\n    position: relative;\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem;\n    float: left; }\n\n  .large-1 {\n    width: 8.33333%; }\n\n  .large-2 {\n    width: 16.66667%; }\n\n  .large-3 {\n    width: 25%; }\n\n  .large-4 {\n    width: 33.33333%; }\n\n  .large-5 {\n    width: 41.66667%; }\n\n  .large-6 {\n    width: 50%; }\n\n  .large-7 {\n    width: 58.33333%; }\n\n  .large-8 {\n    width: 66.66667%; }\n\n  .large-9 {\n    width: 75%; }\n\n  .large-10 {\n    width: 83.33333%; }\n\n  .large-11 {\n    width: 91.66667%; }\n\n  .large-12 {\n    width: 100%; }\n\n  .large-offset-0 {\n    margin-left: 0 !important; }\n\n  .large-offset-1 {\n    margin-left: 8.33333% !important; }\n\n  .large-offset-2 {\n    margin-left: 16.66667% !important; }\n\n  .large-offset-3 {\n    margin-left: 25% !important; }\n\n  .large-offset-4 {\n    margin-left: 33.33333% !important; }\n\n  .large-offset-5 {\n    margin-left: 41.66667% !important; }\n\n  .large-offset-6 {\n    margin-left: 50% !important; }\n\n  .large-offset-7 {\n    margin-left: 58.33333% !important; }\n\n  .large-offset-8 {\n    margin-left: 66.66667% !important; }\n\n  .large-offset-9 {\n    margin-left: 75% !important; }\n\n  .large-offset-10 {\n    margin-left: 83.33333% !important; }\n\n  .large-offset-11 {\n    margin-left: 91.66667% !important; }\n\n  .large-reset-order {\n    float: left;\n    left: auto;\n    margin-left: 0;\n    margin-right: 0;\n    right: auto; }\n\n  .column.large-centered,\n  .columns.large-centered {\n    margin-left: auto;\n    margin-right: auto;\n    float: none; }\n\n  .column.large-uncentered,\n  .columns.large-uncentered {\n    float: left;\n    margin-left: 0;\n    margin-right: 0; }\n\n  .column.large-centered:last-child,\n  .columns.large-centered:last-child {\n    float: none; }\n\n  .column.large-uncentered:last-child,\n  .columns.large-uncentered:last-child {\n    float: left; }\n\n  .column.large-uncentered.opposite,\n  .columns.large-uncentered.opposite {\n    float: right; }\n\n  .row.large-collapse > .column,\n  .row.large-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .row.large-collapse .row {\n    margin-left: 0;\n    margin-right: 0; }\n  .row.large-uncollapse > .column,\n  .row.large-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem;\n    float: left; }\n\n  .push-0 {\n    position: relative;\n    left: 0;\n    right: auto; }\n\n  .pull-0 {\n    position: relative;\n    right: 0;\n    left: auto; }\n\n  .push-1 {\n    position: relative;\n    left: 8.33333%;\n    right: auto; }\n\n  .pull-1 {\n    position: relative;\n    right: 8.33333%;\n    left: auto; }\n\n  .push-2 {\n    position: relative;\n    left: 16.66667%;\n    right: auto; }\n\n  .pull-2 {\n    position: relative;\n    right: 16.66667%;\n    left: auto; }\n\n  .push-3 {\n    position: relative;\n    left: 25%;\n    right: auto; }\n\n  .pull-3 {\n    position: relative;\n    right: 25%;\n    left: auto; }\n\n  .push-4 {\n    position: relative;\n    left: 33.33333%;\n    right: auto; }\n\n  .pull-4 {\n    position: relative;\n    right: 33.33333%;\n    left: auto; }\n\n  .push-5 {\n    position: relative;\n    left: 41.66667%;\n    right: auto; }\n\n  .pull-5 {\n    position: relative;\n    right: 41.66667%;\n    left: auto; }\n\n  .push-6 {\n    position: relative;\n    left: 50%;\n    right: auto; }\n\n  .pull-6 {\n    position: relative;\n    right: 50%;\n    left: auto; }\n\n  .push-7 {\n    position: relative;\n    left: 58.33333%;\n    right: auto; }\n\n  .pull-7 {\n    position: relative;\n    right: 58.33333%;\n    left: auto; }\n\n  .push-8 {\n    position: relative;\n    left: 66.66667%;\n    right: auto; }\n\n  .pull-8 {\n    position: relative;\n    right: 66.66667%;\n    left: auto; }\n\n  .push-9 {\n    position: relative;\n    left: 75%;\n    right: auto; }\n\n  .pull-9 {\n    position: relative;\n    right: 75%;\n    left: auto; }\n\n  .push-10 {\n    position: relative;\n    left: 83.33333%;\n    right: auto; }\n\n  .pull-10 {\n    position: relative;\n    right: 83.33333%;\n    left: auto; }\n\n  .push-11 {\n    position: relative;\n    left: 91.66667%;\n    right: auto; }\n\n  .pull-11 {\n    position: relative;\n    right: 91.66667%;\n    left: auto; } }\n.accordion {\n  margin-bottom: 0; }\n  .accordion:before, .accordion:after {\n    content: \" \";\n    display: table; }\n  .accordion:after {\n    clear: both; }\n  .accordion .accordion-navigation, .accordion dd {\n    display: block;\n    margin-bottom: 0 !important; }\n    .accordion .accordion-navigation.active > a, .accordion dd.active > a {\n      background: #e8e8e8; }\n    .accordion .accordion-navigation > a, .accordion dd > a {\n      background: #EFEFEF;\n      color: #222222;\n      display: block;\n      font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n      font-size: 1rem;\n      padding: 1rem; }\n      .accordion .accordion-navigation > a:hover, .accordion dd > a:hover {\n        background: #e3e3e3; }\n    .accordion .accordion-navigation > .content, .accordion dd > .content {\n      display: none;\n      padding: 0.9375rem; }\n      .accordion .accordion-navigation > .content.active, .accordion dd > .content.active {\n        background: #FFFFFF;\n        display: block; }\n\n.alert-box {\n  border-style: solid;\n  border-width: 1px;\n  display: block;\n  font-size: 0.8125rem;\n  font-weight: normal;\n  margin-bottom: 1.25rem;\n  padding: 0.875rem 1.5rem 0.875rem 0.875rem;\n  position: relative;\n  transition: opacity 300ms ease-out;\n  background-color: #008CBA;\n  border-color: #0078a0;\n  color: #FFFFFF; }\n  .alert-box .close {\n    right: 0.25rem;\n    background: inherit;\n    color: #333333;\n    font-size: 1.375rem;\n    line-height: .9;\n    margin-top: -0.6875rem;\n    opacity: 0.3;\n    padding: 0 6px 4px;\n    position: absolute;\n    top: 50%; }\n    .alert-box .close:hover, .alert-box .close:focus {\n      opacity: 0.5; }\n  .alert-box.radius {\n    border-radius: 3px; }\n  .alert-box.round {\n    border-radius: 1000px; }\n  .alert-box.success {\n    background-color: #43AC6A;\n    border-color: #3a945b;\n    color: #FFFFFF; }\n  .alert-box.alert {\n    background-color: #f04124;\n    border-color: #de2d0f;\n    color: #FFFFFF; }\n  .alert-box.secondary {\n    background-color: #e7e7e7;\n    border-color: #c7c7c7;\n    color: #4f4f4f; }\n  .alert-box.warning {\n    background-color: #f08a24;\n    border-color: #de770f;\n    color: #FFFFFF; }\n  .alert-box.info {\n    background-color: #a0d3e8;\n    border-color: #74bfdd;\n    color: #4f4f4f; }\n  .alert-box.alert-close {\n    opacity: 0; }\n\n[class*=\"block-grid-\"] {\n  display: block;\n  padding: 0;\n  margin: 0 -0.625rem; }\n  [class*=\"block-grid-\"]:before, [class*=\"block-grid-\"]:after {\n    content: \" \";\n    display: table; }\n  [class*=\"block-grid-\"]:after {\n    clear: both; }\n  [class*=\"block-grid-\"] > li {\n    display: block;\n    float: left;\n    height: auto;\n    padding: 0 0.625rem 1.25rem; }\n\n@media only screen {\n  .small-block-grid-1 > li {\n    list-style: none;\n    width: 100%; }\n    .small-block-grid-1 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-1 > li:nth-of-type(1n+1) {\n      clear: both; }\n\n  .small-block-grid-2 > li {\n    list-style: none;\n    width: 50%; }\n    .small-block-grid-2 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-2 > li:nth-of-type(2n+1) {\n      clear: both; }\n\n  .small-block-grid-3 > li {\n    list-style: none;\n    width: 33.33333%; }\n    .small-block-grid-3 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-3 > li:nth-of-type(3n+1) {\n      clear: both; }\n\n  .small-block-grid-4 > li {\n    list-style: none;\n    width: 25%; }\n    .small-block-grid-4 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-4 > li:nth-of-type(4n+1) {\n      clear: both; }\n\n  .small-block-grid-5 > li {\n    list-style: none;\n    width: 20%; }\n    .small-block-grid-5 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-5 > li:nth-of-type(5n+1) {\n      clear: both; }\n\n  .small-block-grid-6 > li {\n    list-style: none;\n    width: 16.66667%; }\n    .small-block-grid-6 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-6 > li:nth-of-type(6n+1) {\n      clear: both; }\n\n  .small-block-grid-7 > li {\n    list-style: none;\n    width: 14.28571%; }\n    .small-block-grid-7 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-7 > li:nth-of-type(7n+1) {\n      clear: both; }\n\n  .small-block-grid-8 > li {\n    list-style: none;\n    width: 12.5%; }\n    .small-block-grid-8 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-8 > li:nth-of-type(8n+1) {\n      clear: both; }\n\n  .small-block-grid-9 > li {\n    list-style: none;\n    width: 11.11111%; }\n    .small-block-grid-9 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-9 > li:nth-of-type(9n+1) {\n      clear: both; }\n\n  .small-block-grid-10 > li {\n    list-style: none;\n    width: 10%; }\n    .small-block-grid-10 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-10 > li:nth-of-type(10n+1) {\n      clear: both; }\n\n  .small-block-grid-11 > li {\n    list-style: none;\n    width: 9.09091%; }\n    .small-block-grid-11 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-11 > li:nth-of-type(11n+1) {\n      clear: both; }\n\n  .small-block-grid-12 > li {\n    list-style: none;\n    width: 8.33333%; }\n    .small-block-grid-12 > li:nth-of-type(1n) {\n      clear: none; }\n    .small-block-grid-12 > li:nth-of-type(12n+1) {\n      clear: both; } }\n@media only screen and (min-width: 40.0625em) {\n  .medium-block-grid-1 > li {\n    list-style: none;\n    width: 100%; }\n    .medium-block-grid-1 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-1 > li:nth-of-type(1n+1) {\n      clear: both; }\n\n  .medium-block-grid-2 > li {\n    list-style: none;\n    width: 50%; }\n    .medium-block-grid-2 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-2 > li:nth-of-type(2n+1) {\n      clear: both; }\n\n  .medium-block-grid-3 > li {\n    list-style: none;\n    width: 33.33333%; }\n    .medium-block-grid-3 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-3 > li:nth-of-type(3n+1) {\n      clear: both; }\n\n  .medium-block-grid-4 > li {\n    list-style: none;\n    width: 25%; }\n    .medium-block-grid-4 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-4 > li:nth-of-type(4n+1) {\n      clear: both; }\n\n  .medium-block-grid-5 > li {\n    list-style: none;\n    width: 20%; }\n    .medium-block-grid-5 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-5 > li:nth-of-type(5n+1) {\n      clear: both; }\n\n  .medium-block-grid-6 > li {\n    list-style: none;\n    width: 16.66667%; }\n    .medium-block-grid-6 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-6 > li:nth-of-type(6n+1) {\n      clear: both; }\n\n  .medium-block-grid-7 > li {\n    list-style: none;\n    width: 14.28571%; }\n    .medium-block-grid-7 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-7 > li:nth-of-type(7n+1) {\n      clear: both; }\n\n  .medium-block-grid-8 > li {\n    list-style: none;\n    width: 12.5%; }\n    .medium-block-grid-8 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-8 > li:nth-of-type(8n+1) {\n      clear: both; }\n\n  .medium-block-grid-9 > li {\n    list-style: none;\n    width: 11.11111%; }\n    .medium-block-grid-9 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-9 > li:nth-of-type(9n+1) {\n      clear: both; }\n\n  .medium-block-grid-10 > li {\n    list-style: none;\n    width: 10%; }\n    .medium-block-grid-10 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-10 > li:nth-of-type(10n+1) {\n      clear: both; }\n\n  .medium-block-grid-11 > li {\n    list-style: none;\n    width: 9.09091%; }\n    .medium-block-grid-11 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-11 > li:nth-of-type(11n+1) {\n      clear: both; }\n\n  .medium-block-grid-12 > li {\n    list-style: none;\n    width: 8.33333%; }\n    .medium-block-grid-12 > li:nth-of-type(1n) {\n      clear: none; }\n    .medium-block-grid-12 > li:nth-of-type(12n+1) {\n      clear: both; } }\n@media only screen and (min-width: 64.0625em) {\n  .large-block-grid-1 > li {\n    list-style: none;\n    width: 100%; }\n    .large-block-grid-1 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-1 > li:nth-of-type(1n+1) {\n      clear: both; }\n\n  .large-block-grid-2 > li {\n    list-style: none;\n    width: 50%; }\n    .large-block-grid-2 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-2 > li:nth-of-type(2n+1) {\n      clear: both; }\n\n  .large-block-grid-3 > li {\n    list-style: none;\n    width: 33.33333%; }\n    .large-block-grid-3 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-3 > li:nth-of-type(3n+1) {\n      clear: both; }\n\n  .large-block-grid-4 > li {\n    list-style: none;\n    width: 25%; }\n    .large-block-grid-4 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-4 > li:nth-of-type(4n+1) {\n      clear: both; }\n\n  .large-block-grid-5 > li {\n    list-style: none;\n    width: 20%; }\n    .large-block-grid-5 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-5 > li:nth-of-type(5n+1) {\n      clear: both; }\n\n  .large-block-grid-6 > li {\n    list-style: none;\n    width: 16.66667%; }\n    .large-block-grid-6 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-6 > li:nth-of-type(6n+1) {\n      clear: both; }\n\n  .large-block-grid-7 > li {\n    list-style: none;\n    width: 14.28571%; }\n    .large-block-grid-7 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-7 > li:nth-of-type(7n+1) {\n      clear: both; }\n\n  .large-block-grid-8 > li {\n    list-style: none;\n    width: 12.5%; }\n    .large-block-grid-8 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-8 > li:nth-of-type(8n+1) {\n      clear: both; }\n\n  .large-block-grid-9 > li {\n    list-style: none;\n    width: 11.11111%; }\n    .large-block-grid-9 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-9 > li:nth-of-type(9n+1) {\n      clear: both; }\n\n  .large-block-grid-10 > li {\n    list-style: none;\n    width: 10%; }\n    .large-block-grid-10 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-10 > li:nth-of-type(10n+1) {\n      clear: both; }\n\n  .large-block-grid-11 > li {\n    list-style: none;\n    width: 9.09091%; }\n    .large-block-grid-11 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-11 > li:nth-of-type(11n+1) {\n      clear: both; }\n\n  .large-block-grid-12 > li {\n    list-style: none;\n    width: 8.33333%; }\n    .large-block-grid-12 > li:nth-of-type(1n) {\n      clear: none; }\n    .large-block-grid-12 > li:nth-of-type(12n+1) {\n      clear: both; } }\n.breadcrumbs {\n  border-style: solid;\n  border-width: 1px;\n  display: block;\n  list-style: none;\n  margin-left: 0;\n  overflow: hidden;\n  padding: 0.5625rem 0.875rem 0.5625rem;\n  background-color: #f4f4f4;\n  border-color: gainsboro;\n  border-radius: 3px; }\n  .breadcrumbs > * {\n    color: #008CBA;\n    float: left;\n    font-size: 0.6875rem;\n    line-height: 0.6875rem;\n    margin: 0;\n    text-transform: uppercase; }\n    .breadcrumbs > *:hover a, .breadcrumbs > *:focus a {\n      text-decoration: underline; }\n    .breadcrumbs > * a {\n      color: #008CBA; }\n    .breadcrumbs > *.current {\n      color: #333333;\n      cursor: default; }\n      .breadcrumbs > *.current a {\n        color: #333333;\n        cursor: default; }\n      .breadcrumbs > *.current:hover, .breadcrumbs > *.current:hover a, .breadcrumbs > *.current:focus, .breadcrumbs > *.current:focus a {\n        text-decoration: none; }\n    .breadcrumbs > *.unavailable {\n      color: #999999; }\n      .breadcrumbs > *.unavailable a {\n        color: #999999; }\n      .breadcrumbs > *.unavailable:hover, .breadcrumbs > *.unavailable:hover a, .breadcrumbs > *.unavailable:focus,\n      .breadcrumbs > *.unavailable a:focus {\n        color: #999999;\n        cursor: not-allowed;\n        text-decoration: none; }\n    .breadcrumbs > *:before {\n      color: #AAAAAA;\n      content: \"/\";\n      margin: 0 0.75rem;\n      position: relative;\n      top: 1px; }\n    .breadcrumbs > *:first-child:before {\n      content: \" \";\n      margin: 0; }\n\n/* Accessibility - hides the forward slash */\n[aria-label=\"breadcrumbs\"] [aria-hidden=\"true\"]:after {\n  content: \"/\"; }\n\nbutton, .button {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  border-radius: 0;\n  border-style: solid;\n  border-width: 0;\n  cursor: pointer;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-weight: normal;\n  line-height: normal;\n  margin: 0 0 1.25rem;\n  position: relative;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  padding: 1rem 2rem 1.0625rem 2rem;\n  font-size: 1rem;\n  background-color: #008CBA;\n  border-color: #007095;\n  color: #FFFFFF;\n  transition: background-color 300ms ease-out; }\n  button:hover, button:focus, .button:hover, .button:focus {\n    background-color: #007095; }\n  button:hover, button:focus, .button:hover, .button:focus {\n    color: #FFFFFF; }\n  button.secondary, .button.secondary {\n    background-color: #e7e7e7;\n    border-color: #b9b9b9;\n    color: #333333; }\n    button.secondary:hover, button.secondary:focus, .button.secondary:hover, .button.secondary:focus {\n      background-color: #b9b9b9; }\n    button.secondary:hover, button.secondary:focus, .button.secondary:hover, .button.secondary:focus {\n      color: #333333; }\n  button.success, .button.success {\n    background-color: #43AC6A;\n    border-color: #368a55;\n    color: #FFFFFF; }\n    button.success:hover, button.success:focus, .button.success:hover, .button.success:focus {\n      background-color: #368a55; }\n    button.success:hover, button.success:focus, .button.success:hover, .button.success:focus {\n      color: #FFFFFF; }\n  button.alert, .button.alert {\n    background-color: #f04124;\n    border-color: #cf2a0e;\n    color: #FFFFFF; }\n    button.alert:hover, button.alert:focus, .button.alert:hover, .button.alert:focus {\n      background-color: #cf2a0e; }\n    button.alert:hover, button.alert:focus, .button.alert:hover, .button.alert:focus {\n      color: #FFFFFF; }\n  button.warning, .button.warning {\n    background-color: #f08a24;\n    border-color: #cf6e0e;\n    color: #FFFFFF; }\n    button.warning:hover, button.warning:focus, .button.warning:hover, .button.warning:focus {\n      background-color: #cf6e0e; }\n    button.warning:hover, button.warning:focus, .button.warning:hover, .button.warning:focus {\n      color: #FFFFFF; }\n  button.info, .button.info {\n    background-color: #a0d3e8;\n    border-color: #61b6d9;\n    color: #333333; }\n    button.info:hover, button.info:focus, .button.info:hover, .button.info:focus {\n      background-color: #61b6d9; }\n    button.info:hover, button.info:focus, .button.info:hover, .button.info:focus {\n      color: #FFFFFF; }\n  button.large, .button.large {\n    padding: 1.125rem 2.25rem 1.1875rem 2.25rem;\n    font-size: 1.25rem; }\n  button.small, .button.small {\n    padding: 0.875rem 1.75rem 0.9375rem 1.75rem;\n    font-size: 0.8125rem; }\n  button.tiny, .button.tiny {\n    padding: 0.625rem 1.25rem 0.6875rem 1.25rem;\n    font-size: 0.6875rem; }\n  button.expand, .button.expand {\n    padding-left: 0;\n    padding-right: 0;\n    width: 100%; }\n  button.left-align, .button.left-align {\n    text-align: left;\n    text-indent: 0.75rem; }\n  button.right-align, .button.right-align {\n    text-align: right;\n    padding-right: 0.75rem; }\n  button.radius, .button.radius {\n    border-radius: 3px; }\n  button.round, .button.round {\n    border-radius: 1000px; }\n  button.disabled, button[disabled], .button.disabled, .button[disabled] {\n    background-color: #008CBA;\n    border-color: #007095;\n    color: #FFFFFF;\n    box-shadow: none;\n    cursor: default;\n    opacity: 0.7; }\n    button.disabled:hover, button.disabled:focus, button[disabled]:hover, button[disabled]:focus, .button.disabled:hover, .button.disabled:focus, .button[disabled]:hover, .button[disabled]:focus {\n      background-color: #007095; }\n    button.disabled:hover, button.disabled:focus, button[disabled]:hover, button[disabled]:focus, .button.disabled:hover, .button.disabled:focus, .button[disabled]:hover, .button[disabled]:focus {\n      color: #FFFFFF; }\n    button.disabled:hover, button.disabled:focus, button[disabled]:hover, button[disabled]:focus, .button.disabled:hover, .button.disabled:focus, .button[disabled]:hover, .button[disabled]:focus {\n      background-color: #008CBA; }\n    button.disabled.secondary, button[disabled].secondary, .button.disabled.secondary, .button[disabled].secondary {\n      background-color: #e7e7e7;\n      border-color: #b9b9b9;\n      color: #333333;\n      box-shadow: none;\n      cursor: default;\n      opacity: 0.7; }\n      button.disabled.secondary:hover, button.disabled.secondary:focus, button[disabled].secondary:hover, button[disabled].secondary:focus, .button.disabled.secondary:hover, .button.disabled.secondary:focus, .button[disabled].secondary:hover, .button[disabled].secondary:focus {\n        background-color: #b9b9b9; }\n      button.disabled.secondary:hover, button.disabled.secondary:focus, button[disabled].secondary:hover, button[disabled].secondary:focus, .button.disabled.secondary:hover, .button.disabled.secondary:focus, .button[disabled].secondary:hover, .button[disabled].secondary:focus {\n        color: #333333; }\n      button.disabled.secondary:hover, button.disabled.secondary:focus, button[disabled].secondary:hover, button[disabled].secondary:focus, .button.disabled.secondary:hover, .button.disabled.secondary:focus, .button[disabled].secondary:hover, .button[disabled].secondary:focus {\n        background-color: #e7e7e7; }\n    button.disabled.success, button[disabled].success, .button.disabled.success, .button[disabled].success {\n      background-color: #43AC6A;\n      border-color: #368a55;\n      color: #FFFFFF;\n      box-shadow: none;\n      cursor: default;\n      opacity: 0.7; }\n      button.disabled.success:hover, button.disabled.success:focus, button[disabled].success:hover, button[disabled].success:focus, .button.disabled.success:hover, .button.disabled.success:focus, .button[disabled].success:hover, .button[disabled].success:focus {\n        background-color: #368a55; }\n      button.disabled.success:hover, button.disabled.success:focus, button[disabled].success:hover, button[disabled].success:focus, .button.disabled.success:hover, .button.disabled.success:focus, .button[disabled].success:hover, .button[disabled].success:focus {\n        color: #FFFFFF; }\n      button.disabled.success:hover, button.disabled.success:focus, button[disabled].success:hover, button[disabled].success:focus, .button.disabled.success:hover, .button.disabled.success:focus, .button[disabled].success:hover, .button[disabled].success:focus {\n        background-color: #43AC6A; }\n    button.disabled.alert, button[disabled].alert, .button.disabled.alert, .button[disabled].alert {\n      background-color: #f04124;\n      border-color: #cf2a0e;\n      color: #FFFFFF;\n      box-shadow: none;\n      cursor: default;\n      opacity: 0.7; }\n      button.disabled.alert:hover, button.disabled.alert:focus, button[disabled].alert:hover, button[disabled].alert:focus, .button.disabled.alert:hover, .button.disabled.alert:focus, .button[disabled].alert:hover, .button[disabled].alert:focus {\n        background-color: #cf2a0e; }\n      button.disabled.alert:hover, button.disabled.alert:focus, button[disabled].alert:hover, button[disabled].alert:focus, .button.disabled.alert:hover, .button.disabled.alert:focus, .button[disabled].alert:hover, .button[disabled].alert:focus {\n        color: #FFFFFF; }\n      button.disabled.alert:hover, button.disabled.alert:focus, button[disabled].alert:hover, button[disabled].alert:focus, .button.disabled.alert:hover, .button.disabled.alert:focus, .button[disabled].alert:hover, .button[disabled].alert:focus {\n        background-color: #f04124; }\n    button.disabled.warning, button[disabled].warning, .button.disabled.warning, .button[disabled].warning {\n      background-color: #f08a24;\n      border-color: #cf6e0e;\n      color: #FFFFFF;\n      box-shadow: none;\n      cursor: default;\n      opacity: 0.7; }\n      button.disabled.warning:hover, button.disabled.warning:focus, button[disabled].warning:hover, button[disabled].warning:focus, .button.disabled.warning:hover, .button.disabled.warning:focus, .button[disabled].warning:hover, .button[disabled].warning:focus {\n        background-color: #cf6e0e; }\n      button.disabled.warning:hover, button.disabled.warning:focus, button[disabled].warning:hover, button[disabled].warning:focus, .button.disabled.warning:hover, .button.disabled.warning:focus, .button[disabled].warning:hover, .button[disabled].warning:focus {\n        color: #FFFFFF; }\n      button.disabled.warning:hover, button.disabled.warning:focus, button[disabled].warning:hover, button[disabled].warning:focus, .button.disabled.warning:hover, .button.disabled.warning:focus, .button[disabled].warning:hover, .button[disabled].warning:focus {\n        background-color: #f08a24; }\n    button.disabled.info, button[disabled].info, .button.disabled.info, .button[disabled].info {\n      background-color: #a0d3e8;\n      border-color: #61b6d9;\n      color: #333333;\n      box-shadow: none;\n      cursor: default;\n      opacity: 0.7; }\n      button.disabled.info:hover, button.disabled.info:focus, button[disabled].info:hover, button[disabled].info:focus, .button.disabled.info:hover, .button.disabled.info:focus, .button[disabled].info:hover, .button[disabled].info:focus {\n        background-color: #61b6d9; }\n      button.disabled.info:hover, button.disabled.info:focus, button[disabled].info:hover, button[disabled].info:focus, .button.disabled.info:hover, .button.disabled.info:focus, .button[disabled].info:hover, .button[disabled].info:focus {\n        color: #FFFFFF; }\n      button.disabled.info:hover, button.disabled.info:focus, button[disabled].info:hover, button[disabled].info:focus, .button.disabled.info:hover, .button.disabled.info:focus, .button[disabled].info:hover, .button[disabled].info:focus {\n        background-color: #a0d3e8; }\n\nbutton::-moz-focus-inner {\n  border: 0;\n  padding: 0; }\n\n@media only screen and (min-width: 40.0625em) {\n  button, .button {\n    display: inline-block; } }\n.button-group {\n  list-style: none;\n  margin: 0;\n  left: 0; }\n  .button-group:before, .button-group:after {\n    content: \" \";\n    display: table; }\n  .button-group:after {\n    clear: both; }\n  .button-group.even-2 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 50%; }\n    .button-group.even-2 li > button, .button-group.even-2 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-2 li:first-child button, .button-group.even-2 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-2 li button, .button-group.even-2 li .button {\n      width: 100%; }\n  .button-group.even-3 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 33.33333%; }\n    .button-group.even-3 li > button, .button-group.even-3 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-3 li:first-child button, .button-group.even-3 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-3 li button, .button-group.even-3 li .button {\n      width: 100%; }\n  .button-group.even-4 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 25%; }\n    .button-group.even-4 li > button, .button-group.even-4 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-4 li:first-child button, .button-group.even-4 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-4 li button, .button-group.even-4 li .button {\n      width: 100%; }\n  .button-group.even-5 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 20%; }\n    .button-group.even-5 li > button, .button-group.even-5 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-5 li:first-child button, .button-group.even-5 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-5 li button, .button-group.even-5 li .button {\n      width: 100%; }\n  .button-group.even-6 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 16.66667%; }\n    .button-group.even-6 li > button, .button-group.even-6 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-6 li:first-child button, .button-group.even-6 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-6 li button, .button-group.even-6 li .button {\n      width: 100%; }\n  .button-group.even-7 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 14.28571%; }\n    .button-group.even-7 li > button, .button-group.even-7 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-7 li:first-child button, .button-group.even-7 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-7 li button, .button-group.even-7 li .button {\n      width: 100%; }\n  .button-group.even-8 li {\n    display: inline-block;\n    margin: 0 -2px;\n    width: 12.5%; }\n    .button-group.even-8 li > button, .button-group.even-8 li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.even-8 li:first-child button, .button-group.even-8 li:first-child .button {\n      border-left: 0; }\n    .button-group.even-8 li button, .button-group.even-8 li .button {\n      width: 100%; }\n  .button-group > li {\n    display: inline-block;\n    margin: 0 -2px; }\n    .button-group > li > button, .button-group > li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group > li:first-child button, .button-group > li:first-child .button {\n      border-left: 0; }\n  .button-group.stack > li {\n    display: block;\n    margin: 0;\n    float: none; }\n    .button-group.stack > li > button, .button-group.stack > li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.stack > li:first-child button, .button-group.stack > li:first-child .button {\n      border-left: 0; }\n    .button-group.stack > li > button, .button-group.stack > li .button {\n      border-color: rgba(255, 255, 255, 0.5);\n      border-left-width: 0;\n      border-top: 1px solid;\n      display: block;\n      margin: 0; }\n    .button-group.stack > li > button {\n      width: 100%; }\n    .button-group.stack > li:first-child button, .button-group.stack > li:first-child .button {\n      border-top: 0; }\n  .button-group.stack-for-small > li {\n    display: inline-block;\n    margin: 0 -2px; }\n    .button-group.stack-for-small > li > button, .button-group.stack-for-small > li .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.stack-for-small > li:first-child button, .button-group.stack-for-small > li:first-child .button {\n      border-left: 0; }\n    @media only screen and (max-width: 40em) {\n      .button-group.stack-for-small > li {\n        display: block;\n        margin: 0; }\n        .button-group.stack-for-small > li > button, .button-group.stack-for-small > li .button {\n          border-left: 1px solid;\n          border-color: rgba(255, 255, 255, 0.5); }\n        .button-group.stack-for-small > li:first-child button, .button-group.stack-for-small > li:first-child .button {\n          border-left: 0; }\n        .button-group.stack-for-small > li > button, .button-group.stack-for-small > li .button {\n          border-color: rgba(255, 255, 255, 0.5);\n          border-left-width: 0;\n          border-top: 1px solid;\n          display: block;\n          margin: 0; }\n        .button-group.stack-for-small > li > button {\n          width: 100%; }\n        .button-group.stack-for-small > li:first-child button, .button-group.stack-for-small > li:first-child .button {\n          border-top: 0; } }\n  .button-group.radius > * {\n    display: inline-block;\n    margin: 0 -2px; }\n    .button-group.radius > * > button, .button-group.radius > * .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.radius > *:first-child button, .button-group.radius > *:first-child .button {\n      border-left: 0; }\n    .button-group.radius > *,\n    .button-group.radius > * > a,\n    .button-group.radius > * > button,\n    .button-group.radius > * > .button {\n      border-radius: 0; }\n    .button-group.radius > *:first-child, .button-group.radius > *:first-child > a, .button-group.radius > *:first-child > button, .button-group.radius > *:first-child > .button {\n      -webkit-border-bottom-left-radius: 3px;\n      -webkit-border-top-left-radius: 3px;\n      border-bottom-left-radius: 3px;\n      border-top-left-radius: 3px; }\n    .button-group.radius > *:last-child, .button-group.radius > *:last-child > a, .button-group.radius > *:last-child > button, .button-group.radius > *:last-child > .button {\n      -webkit-border-bottom-right-radius: 3px;\n      -webkit-border-top-right-radius: 3px;\n      border-bottom-right-radius: 3px;\n      border-top-right-radius: 3px; }\n  .button-group.radius.stack > * {\n    display: block;\n    margin: 0; }\n    .button-group.radius.stack > * > button, .button-group.radius.stack > * .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.radius.stack > *:first-child button, .button-group.radius.stack > *:first-child .button {\n      border-left: 0; }\n    .button-group.radius.stack > * > button, .button-group.radius.stack > * .button {\n      border-color: rgba(255, 255, 255, 0.5);\n      border-left-width: 0;\n      border-top: 1px solid;\n      display: block;\n      margin: 0; }\n    .button-group.radius.stack > * > button {\n      width: 100%; }\n    .button-group.radius.stack > *:first-child button, .button-group.radius.stack > *:first-child .button {\n      border-top: 0; }\n    .button-group.radius.stack > *,\n    .button-group.radius.stack > * > a,\n    .button-group.radius.stack > * > button,\n    .button-group.radius.stack > * > .button {\n      border-radius: 0; }\n    .button-group.radius.stack > *:first-child, .button-group.radius.stack > *:first-child > a, .button-group.radius.stack > *:first-child > button, .button-group.radius.stack > *:first-child > .button {\n      -webkit-top-left-radius: 3px;\n      -webkit-top-right-radius: 3px;\n      border-top-left-radius: 3px;\n      border-top-right-radius: 3px; }\n    .button-group.radius.stack > *:last-child, .button-group.radius.stack > *:last-child > a, .button-group.radius.stack > *:last-child > button, .button-group.radius.stack > *:last-child > .button {\n      -webkit-bottom-left-radius: 3px;\n      -webkit-bottom-right-radius: 3px;\n      border-bottom-left-radius: 3px;\n      border-bottom-right-radius: 3px; }\n  @media only screen and (min-width: 40.0625em) {\n    .button-group.radius.stack-for-small > * {\n      display: inline-block;\n      margin: 0 -2px; }\n      .button-group.radius.stack-for-small > * > button, .button-group.radius.stack-for-small > * .button {\n        border-left: 1px solid;\n        border-color: rgba(255, 255, 255, 0.5); }\n      .button-group.radius.stack-for-small > *:first-child button, .button-group.radius.stack-for-small > *:first-child .button {\n        border-left: 0; }\n      .button-group.radius.stack-for-small > *,\n      .button-group.radius.stack-for-small > * > a,\n      .button-group.radius.stack-for-small > * > button,\n      .button-group.radius.stack-for-small > * > .button {\n        border-radius: 0; }\n      .button-group.radius.stack-for-small > *:first-child, .button-group.radius.stack-for-small > *:first-child > a, .button-group.radius.stack-for-small > *:first-child > button, .button-group.radius.stack-for-small > *:first-child > .button {\n        -webkit-border-bottom-left-radius: 3px;\n        -webkit-border-top-left-radius: 3px;\n        border-bottom-left-radius: 3px;\n        border-top-left-radius: 3px; }\n      .button-group.radius.stack-for-small > *:last-child, .button-group.radius.stack-for-small > *:last-child > a, .button-group.radius.stack-for-small > *:last-child > button, .button-group.radius.stack-for-small > *:last-child > .button {\n        -webkit-border-bottom-right-radius: 3px;\n        -webkit-border-top-right-radius: 3px;\n        border-bottom-right-radius: 3px;\n        border-top-right-radius: 3px; } }\n  @media only screen and (max-width: 40em) {\n    .button-group.radius.stack-for-small > * {\n      display: block;\n      margin: 0; }\n      .button-group.radius.stack-for-small > * > button, .button-group.radius.stack-for-small > * .button {\n        border-left: 1px solid;\n        border-color: rgba(255, 255, 255, 0.5); }\n      .button-group.radius.stack-for-small > *:first-child button, .button-group.radius.stack-for-small > *:first-child .button {\n        border-left: 0; }\n      .button-group.radius.stack-for-small > * > button, .button-group.radius.stack-for-small > * .button {\n        border-color: rgba(255, 255, 255, 0.5);\n        border-left-width: 0;\n        border-top: 1px solid;\n        display: block;\n        margin: 0; }\n      .button-group.radius.stack-for-small > * > button {\n        width: 100%; }\n      .button-group.radius.stack-for-small > *:first-child button, .button-group.radius.stack-for-small > *:first-child .button {\n        border-top: 0; }\n      .button-group.radius.stack-for-small > *,\n      .button-group.radius.stack-for-small > * > a,\n      .button-group.radius.stack-for-small > * > button,\n      .button-group.radius.stack-for-small > * > .button {\n        border-radius: 0; }\n      .button-group.radius.stack-for-small > *:first-child, .button-group.radius.stack-for-small > *:first-child > a, .button-group.radius.stack-for-small > *:first-child > button, .button-group.radius.stack-for-small > *:first-child > .button {\n        -webkit-top-left-radius: 3px;\n        -webkit-top-right-radius: 3px;\n        border-top-left-radius: 3px;\n        border-top-right-radius: 3px; }\n      .button-group.radius.stack-for-small > *:last-child, .button-group.radius.stack-for-small > *:last-child > a, .button-group.radius.stack-for-small > *:last-child > button, .button-group.radius.stack-for-small > *:last-child > .button {\n        -webkit-bottom-left-radius: 3px;\n        -webkit-bottom-right-radius: 3px;\n        border-bottom-left-radius: 3px;\n        border-bottom-right-radius: 3px; } }\n  .button-group.round > * {\n    display: inline-block;\n    margin: 0 -2px; }\n    .button-group.round > * > button, .button-group.round > * .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.round > *:first-child button, .button-group.round > *:first-child .button {\n      border-left: 0; }\n    .button-group.round > *,\n    .button-group.round > * > a,\n    .button-group.round > * > button,\n    .button-group.round > * > .button {\n      border-radius: 0; }\n    .button-group.round > *:first-child, .button-group.round > *:first-child > a, .button-group.round > *:first-child > button, .button-group.round > *:first-child > .button {\n      -webkit-border-bottom-left-radius: 1000px;\n      -webkit-border-top-left-radius: 1000px;\n      border-bottom-left-radius: 1000px;\n      border-top-left-radius: 1000px; }\n    .button-group.round > *:last-child, .button-group.round > *:last-child > a, .button-group.round > *:last-child > button, .button-group.round > *:last-child > .button {\n      -webkit-border-bottom-right-radius: 1000px;\n      -webkit-border-top-right-radius: 1000px;\n      border-bottom-right-radius: 1000px;\n      border-top-right-radius: 1000px; }\n  .button-group.round.stack > * {\n    display: block;\n    margin: 0; }\n    .button-group.round.stack > * > button, .button-group.round.stack > * .button {\n      border-left: 1px solid;\n      border-color: rgba(255, 255, 255, 0.5); }\n    .button-group.round.stack > *:first-child button, .button-group.round.stack > *:first-child .button {\n      border-left: 0; }\n    .button-group.round.stack > * > button, .button-group.round.stack > * .button {\n      border-color: rgba(255, 255, 255, 0.5);\n      border-left-width: 0;\n      border-top: 1px solid;\n      display: block;\n      margin: 0; }\n    .button-group.round.stack > * > button {\n      width: 100%; }\n    .button-group.round.stack > *:first-child button, .button-group.round.stack > *:first-child .button {\n      border-top: 0; }\n    .button-group.round.stack > *,\n    .button-group.round.stack > * > a,\n    .button-group.round.stack > * > button,\n    .button-group.round.stack > * > .button {\n      border-radius: 0; }\n    .button-group.round.stack > *:first-child, .button-group.round.stack > *:first-child > a, .button-group.round.stack > *:first-child > button, .button-group.round.stack > *:first-child > .button {\n      -webkit-top-left-radius: 1rem;\n      -webkit-top-right-radius: 1rem;\n      border-top-left-radius: 1rem;\n      border-top-right-radius: 1rem; }\n    .button-group.round.stack > *:last-child, .button-group.round.stack > *:last-child > a, .button-group.round.stack > *:last-child > button, .button-group.round.stack > *:last-child > .button {\n      -webkit-bottom-left-radius: 1rem;\n      -webkit-bottom-right-radius: 1rem;\n      border-bottom-left-radius: 1rem;\n      border-bottom-right-radius: 1rem; }\n  @media only screen and (min-width: 40.0625em) {\n    .button-group.round.stack-for-small > * {\n      display: inline-block;\n      margin: 0 -2px; }\n      .button-group.round.stack-for-small > * > button, .button-group.round.stack-for-small > * .button {\n        border-left: 1px solid;\n        border-color: rgba(255, 255, 255, 0.5); }\n      .button-group.round.stack-for-small > *:first-child button, .button-group.round.stack-for-small > *:first-child .button {\n        border-left: 0; }\n      .button-group.round.stack-for-small > *,\n      .button-group.round.stack-for-small > * > a,\n      .button-group.round.stack-for-small > * > button,\n      .button-group.round.stack-for-small > * > .button {\n        border-radius: 0; }\n      .button-group.round.stack-for-small > *:first-child, .button-group.round.stack-for-small > *:first-child > a, .button-group.round.stack-for-small > *:first-child > button, .button-group.round.stack-for-small > *:first-child > .button {\n        -webkit-border-bottom-left-radius: 1000px;\n        -webkit-border-top-left-radius: 1000px;\n        border-bottom-left-radius: 1000px;\n        border-top-left-radius: 1000px; }\n      .button-group.round.stack-for-small > *:last-child, .button-group.round.stack-for-small > *:last-child > a, .button-group.round.stack-for-small > *:last-child > button, .button-group.round.stack-for-small > *:last-child > .button {\n        -webkit-border-bottom-right-radius: 1000px;\n        -webkit-border-top-right-radius: 1000px;\n        border-bottom-right-radius: 1000px;\n        border-top-right-radius: 1000px; } }\n  @media only screen and (max-width: 40em) {\n    .button-group.round.stack-for-small > * {\n      display: block;\n      margin: 0; }\n      .button-group.round.stack-for-small > * > button, .button-group.round.stack-for-small > * .button {\n        border-left: 1px solid;\n        border-color: rgba(255, 255, 255, 0.5); }\n      .button-group.round.stack-for-small > *:first-child button, .button-group.round.stack-for-small > *:first-child .button {\n        border-left: 0; }\n      .button-group.round.stack-for-small > * > button, .button-group.round.stack-for-small > * .button {\n        border-color: rgba(255, 255, 255, 0.5);\n        border-left-width: 0;\n        border-top: 1px solid;\n        display: block;\n        margin: 0; }\n      .button-group.round.stack-for-small > * > button {\n        width: 100%; }\n      .button-group.round.stack-for-small > *:first-child button, .button-group.round.stack-for-small > *:first-child .button {\n        border-top: 0; }\n      .button-group.round.stack-for-small > *,\n      .button-group.round.stack-for-small > * > a,\n      .button-group.round.stack-for-small > * > button,\n      .button-group.round.stack-for-small > * > .button {\n        border-radius: 0; }\n      .button-group.round.stack-for-small > *:first-child, .button-group.round.stack-for-small > *:first-child > a, .button-group.round.stack-for-small > *:first-child > button, .button-group.round.stack-for-small > *:first-child > .button {\n        -webkit-top-left-radius: 1rem;\n        -webkit-top-right-radius: 1rem;\n        border-top-left-radius: 1rem;\n        border-top-right-radius: 1rem; }\n      .button-group.round.stack-for-small > *:last-child, .button-group.round.stack-for-small > *:last-child > a, .button-group.round.stack-for-small > *:last-child > button, .button-group.round.stack-for-small > *:last-child > .button {\n        -webkit-bottom-left-radius: 1rem;\n        -webkit-bottom-right-radius: 1rem;\n        border-bottom-left-radius: 1rem;\n        border-bottom-right-radius: 1rem; } }\n\n.button-bar:before, .button-bar:after {\n  content: \" \";\n  display: table; }\n.button-bar:after {\n  clear: both; }\n.button-bar .button-group {\n  float: left;\n  margin-right: 0.625rem; }\n  .button-bar .button-group div {\n    overflow: hidden; }\n\n/* Clearing Styles */\n.clearing-thumbs, [data-clearing] {\n  list-style: none;\n  margin-left: 0;\n  margin-bottom: 0; }\n  .clearing-thumbs:before, .clearing-thumbs:after, [data-clearing]:before, [data-clearing]:after {\n    content: \" \";\n    display: table; }\n  .clearing-thumbs:after, [data-clearing]:after {\n    clear: both; }\n  .clearing-thumbs li, [data-clearing] li {\n    float: left;\n    margin-right: 10px; }\n  .clearing-thumbs[class*=\"block-grid-\"] li, [data-clearing][class*=\"block-grid-\"] li {\n    margin-right: 0; }\n\n.clearing-blackout {\n  background: #333333;\n  height: 100%;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 998;\n  left: 0; }\n  .clearing-blackout .clearing-close {\n    display: block; }\n\n.clearing-container {\n  height: 100%;\n  margin: 0;\n  overflow: hidden;\n  position: relative;\n  z-index: 998; }\n\n.clearing-touch-label {\n  color: #AAAAAA;\n  font-size: .6em;\n  left: 50%;\n  position: absolute;\n  top: 50%; }\n\n.visible-img {\n  height: 95%;\n  position: relative; }\n  .visible-img img {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    -webkit-transform: translateY(-50%) translateX(-50%);\n    -moz-transform: translateY(-50%) translateX(-50%);\n    -ms-transform: translateY(-50%) translateX(-50%);\n    -o-transform: translateY(-50%) translateX(-50%);\n    transform: translateY(-50%) translateX(-50%);\n    max-height: 100%;\n    max-width: 100%; }\n\n.clearing-caption {\n  background: #333333;\n  bottom: 0;\n  color: #CCCCCC;\n  font-size: 0.875em;\n  line-height: 1.3;\n  margin-bottom: 0;\n  padding: 10px 30px 20px;\n  position: absolute;\n  text-align: center;\n  width: 100%;\n  left: 0; }\n\n.clearing-close {\n  color: #CCCCCC;\n  display: none;\n  font-size: 30px;\n  line-height: 1;\n  padding-left: 20px;\n  padding-top: 10px;\n  z-index: 999; }\n  .clearing-close:hover, .clearing-close:focus {\n    color: #CCCCCC; }\n\n.clearing-assembled .clearing-container {\n  height: 100%; }\n  .clearing-assembled .clearing-container .carousel > ul {\n    display: none; }\n\n.clearing-feature li {\n  display: none; }\n  .clearing-feature li.clearing-featured-img {\n    display: block; }\n\n@media only screen and (min-width: 40.0625em) {\n  .clearing-main-prev,\n  .clearing-main-next {\n    height: 100%;\n    position: absolute;\n    top: 0;\n    width: 40px; }\n    .clearing-main-prev > span,\n    .clearing-main-next > span {\n      border: solid 12px;\n      display: block;\n      height: 0;\n      position: absolute;\n      top: 50%;\n      width: 0; }\n      .clearing-main-prev > span:hover,\n      .clearing-main-next > span:hover {\n        opacity: .8; }\n\n  .clearing-main-prev {\n    left: 0; }\n    .clearing-main-prev > span {\n      left: 5px;\n      border-color: transparent;\n      border-right-color: #CCCCCC; }\n\n  .clearing-main-next {\n    right: 0; }\n    .clearing-main-next > span {\n      border-color: transparent;\n      border-left-color: #CCCCCC; }\n\n  .clearing-main-prev.disabled,\n  .clearing-main-next.disabled {\n    opacity: .3; }\n\n  .clearing-assembled .clearing-container .carousel {\n    background: rgba(51, 51, 51, 0.8);\n    height: 120px;\n    margin-top: 10px;\n    text-align: center; }\n    .clearing-assembled .clearing-container .carousel > ul {\n      display: inline-block;\n      z-index: 999;\n      height: 100%;\n      position: relative;\n      float: none; }\n      .clearing-assembled .clearing-container .carousel > ul li {\n        clear: none;\n        cursor: pointer;\n        display: block;\n        float: left;\n        margin-right: 0;\n        min-height: inherit;\n        opacity: .4;\n        overflow: hidden;\n        padding: 0;\n        position: relative;\n        width: 120px; }\n        .clearing-assembled .clearing-container .carousel > ul li.fix-height img {\n          height: 100%;\n          max-width: none; }\n        .clearing-assembled .clearing-container .carousel > ul li a.th {\n          border: none;\n          box-shadow: none;\n          display: block; }\n        .clearing-assembled .clearing-container .carousel > ul li img {\n          cursor: pointer !important;\n          width: 100% !important; }\n        .clearing-assembled .clearing-container .carousel > ul li.visible {\n          opacity: 1; }\n        .clearing-assembled .clearing-container .carousel > ul li:hover {\n          opacity: .8; }\n  .clearing-assembled .clearing-container .visible-img {\n    background: #333333;\n    height: 85%;\n    overflow: hidden; }\n\n  .clearing-close {\n    padding-left: 0;\n    padding-top: 0;\n    position: absolute;\n    top: 10px;\n    right: 20px; } }\n/* Foundation Dropdowns */\n.f-dropdown {\n  display: none;\n  left: -9999px;\n  list-style: none;\n  margin-left: 0;\n  position: absolute;\n  background: #FFFFFF;\n  border: solid 1px #cccccc;\n  font-size: 0.875rem;\n  height: auto;\n  max-height: none;\n  width: 100%;\n  z-index: 89;\n  margin-top: 2px;\n  max-width: 200px; }\n  .f-dropdown.open {\n    display: block; }\n  .f-dropdown > *:first-child {\n    margin-top: 0; }\n  .f-dropdown > *:last-child {\n    margin-bottom: 0; }\n  .f-dropdown:before {\n    border: inset 6px;\n    content: \"\";\n    display: block;\n    height: 0;\n    width: 0;\n    border-color: transparent transparent #FFFFFF transparent;\n    border-bottom-style: solid;\n    position: absolute;\n    top: -12px;\n    left: 10px;\n    z-index: 89; }\n  .f-dropdown:after {\n    border: inset 7px;\n    content: \"\";\n    display: block;\n    height: 0;\n    width: 0;\n    border-color: transparent transparent #cccccc transparent;\n    border-bottom-style: solid;\n    position: absolute;\n    top: -14px;\n    left: 9px;\n    z-index: 88; }\n  .f-dropdown.right:before {\n    left: auto;\n    right: 10px; }\n  .f-dropdown.right:after {\n    left: auto;\n    right: 9px; }\n  .f-dropdown.drop-right {\n    display: none;\n    left: -9999px;\n    list-style: none;\n    margin-left: 0;\n    position: absolute;\n    background: #FFFFFF;\n    border: solid 1px #cccccc;\n    font-size: 0.875rem;\n    height: auto;\n    max-height: none;\n    width: 100%;\n    z-index: 89;\n    margin-top: 0;\n    margin-left: 2px;\n    max-width: 200px; }\n    .f-dropdown.drop-right.open {\n      display: block; }\n    .f-dropdown.drop-right > *:first-child {\n      margin-top: 0; }\n    .f-dropdown.drop-right > *:last-child {\n      margin-bottom: 0; }\n    .f-dropdown.drop-right:before {\n      border: inset 6px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: transparent #FFFFFF transparent transparent;\n      border-right-style: solid;\n      position: absolute;\n      top: 10px;\n      left: -12px;\n      z-index: 89; }\n    .f-dropdown.drop-right:after {\n      border: inset 7px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: transparent #cccccc transparent transparent;\n      border-right-style: solid;\n      position: absolute;\n      top: 9px;\n      left: -14px;\n      z-index: 88; }\n  .f-dropdown.drop-left {\n    display: none;\n    left: -9999px;\n    list-style: none;\n    margin-left: 0;\n    position: absolute;\n    background: #FFFFFF;\n    border: solid 1px #cccccc;\n    font-size: 0.875rem;\n    height: auto;\n    max-height: none;\n    width: 100%;\n    z-index: 89;\n    margin-top: 0;\n    margin-left: -2px;\n    max-width: 200px; }\n    .f-dropdown.drop-left.open {\n      display: block; }\n    .f-dropdown.drop-left > *:first-child {\n      margin-top: 0; }\n    .f-dropdown.drop-left > *:last-child {\n      margin-bottom: 0; }\n    .f-dropdown.drop-left:before {\n      border: inset 6px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: transparent transparent transparent #FFFFFF;\n      border-left-style: solid;\n      position: absolute;\n      top: 10px;\n      right: -12px;\n      left: auto;\n      z-index: 89; }\n    .f-dropdown.drop-left:after {\n      border: inset 7px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: transparent transparent transparent #cccccc;\n      border-left-style: solid;\n      position: absolute;\n      top: 9px;\n      right: -14px;\n      left: auto;\n      z-index: 88; }\n  .f-dropdown.drop-top {\n    display: none;\n    left: -9999px;\n    list-style: none;\n    margin-left: 0;\n    position: absolute;\n    background: #FFFFFF;\n    border: solid 1px #cccccc;\n    font-size: 0.875rem;\n    height: auto;\n    max-height: none;\n    width: 100%;\n    z-index: 89;\n    margin-left: 0;\n    margin-top: -2px;\n    max-width: 200px; }\n    .f-dropdown.drop-top.open {\n      display: block; }\n    .f-dropdown.drop-top > *:first-child {\n      margin-top: 0; }\n    .f-dropdown.drop-top > *:last-child {\n      margin-bottom: 0; }\n    .f-dropdown.drop-top:before {\n      border: inset 6px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: #FFFFFF transparent transparent transparent;\n      border-top-style: solid;\n      bottom: -12px;\n      position: absolute;\n      top: auto;\n      left: 10px;\n      right: auto;\n      z-index: 89; }\n    .f-dropdown.drop-top:after {\n      border: inset 7px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: #cccccc transparent transparent transparent;\n      border-top-style: solid;\n      bottom: -14px;\n      position: absolute;\n      top: auto;\n      left: 9px;\n      right: auto;\n      z-index: 88; }\n  .f-dropdown li {\n    cursor: pointer;\n    font-size: 0.875rem;\n    line-height: 1.125rem;\n    margin: 0; }\n    .f-dropdown li:hover, .f-dropdown li:focus {\n      background: #EEEEEE; }\n    .f-dropdown li.radius {\n      border-radius: 3px; }\n    .f-dropdown li a {\n      display: block;\n      padding: 0.5rem;\n      color: #555555; }\n  .f-dropdown.content {\n    display: none;\n    left: -9999px;\n    list-style: none;\n    margin-left: 0;\n    position: absolute;\n    background: #FFFFFF;\n    border: solid 1px #cccccc;\n    font-size: 0.875rem;\n    height: auto;\n    max-height: none;\n    padding: 1.25rem;\n    width: 100%;\n    z-index: 89;\n    max-width: 200px; }\n    .f-dropdown.content.open {\n      display: block; }\n    .f-dropdown.content > *:first-child {\n      margin-top: 0; }\n    .f-dropdown.content > *:last-child {\n      margin-bottom: 0; }\n  .f-dropdown.tiny {\n    max-width: 200px; }\n  .f-dropdown.small {\n    max-width: 300px; }\n  .f-dropdown.medium {\n    max-width: 500px; }\n  .f-dropdown.large {\n    max-width: 800px; }\n  .f-dropdown.mega {\n    width: 100% !important;\n    max-width: 100% !important; }\n    .f-dropdown.mega.open {\n      left: 0 !important; }\n\n.dropdown.button, button.dropdown {\n  position: relative;\n  padding-right: 3.5625rem; }\n  .dropdown.button::after, button.dropdown::after {\n    border-color: #FFFFFF transparent transparent transparent;\n    border-style: solid;\n    content: \"\";\n    display: block;\n    height: 0;\n    position: absolute;\n    top: 50%;\n    width: 0; }\n  .dropdown.button::after, button.dropdown::after {\n    border-width: 0.375rem;\n    right: 1.40625rem;\n    margin-top: -0.15625rem; }\n  .dropdown.button::after, button.dropdown::after {\n    border-color: #FFFFFF transparent transparent transparent; }\n  .dropdown.button.tiny, button.dropdown.tiny {\n    padding-right: 2.625rem; }\n    .dropdown.button.tiny:after, button.dropdown.tiny:after {\n      border-width: 0.375rem;\n      right: 1.125rem;\n      margin-top: -0.125rem; }\n    .dropdown.button.tiny::after, button.dropdown.tiny::after {\n      border-color: #FFFFFF transparent transparent transparent; }\n  .dropdown.button.small, button.dropdown.small {\n    padding-right: 3.0625rem; }\n    .dropdown.button.small::after, button.dropdown.small::after {\n      border-width: 0.4375rem;\n      right: 1.3125rem;\n      margin-top: -0.15625rem; }\n    .dropdown.button.small::after, button.dropdown.small::after {\n      border-color: #FFFFFF transparent transparent transparent; }\n  .dropdown.button.large, button.dropdown.large {\n    padding-right: 3.625rem; }\n    .dropdown.button.large::after, button.dropdown.large::after {\n      border-width: 0.3125rem;\n      right: 1.71875rem;\n      margin-top: -0.15625rem; }\n    .dropdown.button.large::after, button.dropdown.large::after {\n      border-color: #FFFFFF transparent transparent transparent; }\n  .dropdown.button.secondary:after, button.dropdown.secondary:after {\n    border-color: #333333 transparent transparent transparent; }\n\n.flex-video {\n  height: 0;\n  margin-bottom: 1rem;\n  overflow: hidden;\n  padding-bottom: 67.5%;\n  padding-top: 1.5625rem;\n  position: relative; }\n  .flex-video.widescreen {\n    padding-bottom: 56.34%; }\n  .flex-video.vimeo {\n    padding-top: 0; }\n  .flex-video iframe,\n  .flex-video object,\n  .flex-video embed,\n  .flex-video video {\n    height: 100%;\n    position: absolute;\n    top: 0;\n    width: 100%;\n    left: 0; }\n\n/* Standard Forms */\nform {\n  margin: 0 0 1rem; }\n\n/* Using forms within rows, we need to set some defaults */\nform .row .row {\n  margin: 0 -0.5rem; }\n  form .row .row .column,\n  form .row .row .columns {\n    padding: 0 0.5rem; }\n  form .row .row.collapse {\n    margin: 0; }\n    form .row .row.collapse .column,\n    form .row .row.collapse .columns {\n      padding: 0; }\n    form .row .row.collapse input {\n      -webkit-border-bottom-right-radius: 0;\n      -webkit-border-top-right-radius: 0;\n      border-bottom-right-radius: 0;\n      border-top-right-radius: 0; }\nform .row input.column,\nform .row input.columns,\nform .row textarea.column,\nform .row textarea.columns {\n  padding-left: 0.5rem; }\n\n/* Label Styles */\nlabel {\n  color: #4d4d4d;\n  cursor: pointer;\n  display: block;\n  font-size: 0.875rem;\n  font-weight: normal;\n  line-height: 1.5;\n  margin-bottom: 0;\n  /* Styles for required inputs */ }\n  label.right {\n    float: none !important;\n    text-align: right; }\n  label.inline {\n    margin: 0 0 1rem 0;\n    padding: 0.5625rem 0; }\n  label small {\n    text-transform: capitalize;\n    color: #676767; }\n\n/* Attach elements to the beginning or end of an input */\n.prefix,\n.postfix {\n  border-style: solid;\n  border-width: 1px;\n  display: block;\n  font-size: 0.875rem;\n  height: 2.3125rem;\n  line-height: 2.3125rem;\n  overflow: visible;\n  padding-bottom: 0;\n  padding-top: 0;\n  position: relative;\n  text-align: center;\n  width: 100%;\n  z-index: 2; }\n\n/* Adjust padding, alignment and radius if pre/post element is a button */\n.postfix.button {\n  border-color: true; }\n\n.prefix.button {\n  border: none;\n  padding-left: 0;\n  padding-right: 0;\n  padding-bottom: 0;\n  padding-top: 0;\n  text-align: center; }\n\n.prefix.button.radius {\n  border-radius: 0;\n  -webkit-border-bottom-left-radius: 3px;\n  -webkit-border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px;\n  border-top-left-radius: 3px; }\n\n.postfix.button.radius {\n  border-radius: 0;\n  -webkit-border-bottom-right-radius: 3px;\n  -webkit-border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n  border-top-right-radius: 3px; }\n\n.prefix.button.round {\n  border-radius: 0;\n  -webkit-border-bottom-left-radius: 1000px;\n  -webkit-border-top-left-radius: 1000px;\n  border-bottom-left-radius: 1000px;\n  border-top-left-radius: 1000px; }\n\n.postfix.button.round {\n  border-radius: 0;\n  -webkit-border-bottom-right-radius: 1000px;\n  -webkit-border-top-right-radius: 1000px;\n  border-bottom-right-radius: 1000px;\n  border-top-right-radius: 1000px; }\n\n/* Separate prefix and postfix styles when on span or label so buttons keep their own */\nspan.prefix, label.prefix {\n  background: #f2f2f2;\n  border-right: none;\n  color: #333333;\n  border-color: #cccccc; }\n\nspan.postfix, label.postfix {\n  background: #f2f2f2;\n  color: #333333;\n  border-color: #cccccc; }\n\n/* We use this to get basic styling on all basic form elements */\ninput[type=\"text\"], input[type=\"password\"], input[type=\"date\"], input[type=\"datetime\"], input[type=\"datetime-local\"], input[type=\"month\"], input[type=\"week\"], input[type=\"email\"], input[type=\"number\"], input[type=\"search\"], input[type=\"tel\"], input[type=\"time\"], input[type=\"url\"], input[type=\"color\"], textarea {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  border-radius: 0;\n  background-color: #FFFFFF;\n  border-style: solid;\n  border-width: 1px;\n  border-color: #cccccc;\n  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);\n  color: rgba(0, 0, 0, 0.75);\n  display: block;\n  font-family: inherit;\n  font-size: 0.875rem;\n  height: 2.3125rem;\n  margin: 0 0 1rem 0;\n  padding: 0.5rem;\n  width: 100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  -webkit-transition: border-color 0.15s linear, background 0.15s linear;\n  -moz-transition: border-color 0.15s linear, background 0.15s linear;\n  -ms-transition: border-color 0.15s linear, background 0.15s linear;\n  -o-transition: border-color 0.15s linear, background 0.15s linear;\n  transition: border-color 0.15s linear, background 0.15s linear; }\n  input[type=\"text\"]:focus, input[type=\"password\"]:focus, input[type=\"date\"]:focus, input[type=\"datetime\"]:focus, input[type=\"datetime-local\"]:focus, input[type=\"month\"]:focus, input[type=\"week\"]:focus, input[type=\"email\"]:focus, input[type=\"number\"]:focus, input[type=\"search\"]:focus, input[type=\"tel\"]:focus, input[type=\"time\"]:focus, input[type=\"url\"]:focus, input[type=\"color\"]:focus, textarea:focus {\n    background: #fafafa;\n    border-color: #999999;\n    outline: none; }\n  input[type=\"text\"]:disabled, input[type=\"password\"]:disabled, input[type=\"date\"]:disabled, input[type=\"datetime\"]:disabled, input[type=\"datetime-local\"]:disabled, input[type=\"month\"]:disabled, input[type=\"week\"]:disabled, input[type=\"email\"]:disabled, input[type=\"number\"]:disabled, input[type=\"search\"]:disabled, input[type=\"tel\"]:disabled, input[type=\"time\"]:disabled, input[type=\"url\"]:disabled, input[type=\"color\"]:disabled, textarea:disabled {\n    background-color: #DDDDDD;\n    cursor: default; }\n  input[type=\"text\"][disabled], input[type=\"text\"][readonly], fieldset[disabled] input[type=\"text\"], input[type=\"password\"][disabled], input[type=\"password\"][readonly], fieldset[disabled] input[type=\"password\"], input[type=\"date\"][disabled], input[type=\"date\"][readonly], fieldset[disabled] input[type=\"date\"], input[type=\"datetime\"][disabled], input[type=\"datetime\"][readonly], fieldset[disabled] input[type=\"datetime\"], input[type=\"datetime-local\"][disabled], input[type=\"datetime-local\"][readonly], fieldset[disabled] input[type=\"datetime-local\"], input[type=\"month\"][disabled], input[type=\"month\"][readonly], fieldset[disabled] input[type=\"month\"], input[type=\"week\"][disabled], input[type=\"week\"][readonly], fieldset[disabled] input[type=\"week\"], input[type=\"email\"][disabled], input[type=\"email\"][readonly], fieldset[disabled] input[type=\"email\"], input[type=\"number\"][disabled], input[type=\"number\"][readonly], fieldset[disabled] input[type=\"number\"], input[type=\"search\"][disabled], input[type=\"search\"][readonly], fieldset[disabled] input[type=\"search\"], input[type=\"tel\"][disabled], input[type=\"tel\"][readonly], fieldset[disabled] input[type=\"tel\"], input[type=\"time\"][disabled], input[type=\"time\"][readonly], fieldset[disabled] input[type=\"time\"], input[type=\"url\"][disabled], input[type=\"url\"][readonly], fieldset[disabled] input[type=\"url\"], input[type=\"color\"][disabled], input[type=\"color\"][readonly], fieldset[disabled] input[type=\"color\"], textarea[disabled], textarea[readonly], fieldset[disabled] textarea {\n    background-color: #DDDDDD;\n    cursor: default; }\n  input[type=\"text\"].radius, input[type=\"password\"].radius, input[type=\"date\"].radius, input[type=\"datetime\"].radius, input[type=\"datetime-local\"].radius, input[type=\"month\"].radius, input[type=\"week\"].radius, input[type=\"email\"].radius, input[type=\"number\"].radius, input[type=\"search\"].radius, input[type=\"tel\"].radius, input[type=\"time\"].radius, input[type=\"url\"].radius, input[type=\"color\"].radius, textarea.radius {\n    border-radius: 3px; }\n\nform .row .prefix-radius.row.collapse input,\nform .row .prefix-radius.row.collapse textarea,\nform .row .prefix-radius.row.collapse select,\nform .row .prefix-radius.row.collapse button {\n  border-radius: 0;\n  -webkit-border-bottom-right-radius: 3px;\n  -webkit-border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n  border-top-right-radius: 3px; }\nform .row .prefix-radius.row.collapse .prefix {\n  border-radius: 0;\n  -webkit-border-bottom-left-radius: 3px;\n  -webkit-border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px;\n  border-top-left-radius: 3px; }\nform .row .postfix-radius.row.collapse input,\nform .row .postfix-radius.row.collapse textarea,\nform .row .postfix-radius.row.collapse select,\nform .row .postfix-radius.row.collapse button {\n  border-radius: 0;\n  -webkit-border-bottom-left-radius: 3px;\n  -webkit-border-top-left-radius: 3px;\n  border-bottom-left-radius: 3px;\n  border-top-left-radius: 3px; }\nform .row .postfix-radius.row.collapse .postfix {\n  border-radius: 0;\n  -webkit-border-bottom-right-radius: 3px;\n  -webkit-border-top-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n  border-top-right-radius: 3px; }\nform .row .prefix-round.row.collapse input,\nform .row .prefix-round.row.collapse textarea,\nform .row .prefix-round.row.collapse select,\nform .row .prefix-round.row.collapse button {\n  border-radius: 0;\n  -webkit-border-bottom-right-radius: 1000px;\n  -webkit-border-top-right-radius: 1000px;\n  border-bottom-right-radius: 1000px;\n  border-top-right-radius: 1000px; }\nform .row .prefix-round.row.collapse .prefix {\n  border-radius: 0;\n  -webkit-border-bottom-left-radius: 1000px;\n  -webkit-border-top-left-radius: 1000px;\n  border-bottom-left-radius: 1000px;\n  border-top-left-radius: 1000px; }\nform .row .postfix-round.row.collapse input,\nform .row .postfix-round.row.collapse textarea,\nform .row .postfix-round.row.collapse select,\nform .row .postfix-round.row.collapse button {\n  border-radius: 0;\n  -webkit-border-bottom-left-radius: 1000px;\n  -webkit-border-top-left-radius: 1000px;\n  border-bottom-left-radius: 1000px;\n  border-top-left-radius: 1000px; }\nform .row .postfix-round.row.collapse .postfix {\n  border-radius: 0;\n  -webkit-border-bottom-right-radius: 1000px;\n  -webkit-border-top-right-radius: 1000px;\n  border-bottom-right-radius: 1000px;\n  border-top-right-radius: 1000px; }\n\ninput[type=\"submit\"] {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  border-radius: 0; }\n\n/* Respect enforced amount of rows for textarea */\ntextarea[rows] {\n  height: auto; }\n\n/* Not allow resize out of parent */\ntextarea {\n  max-width: 100%; }\n\n::-webkit-input-placeholder {\n  color: #cccccc; }\n\n:-moz-placeholder {\n  /* Firefox 18- */\n  color: #cccccc; }\n\n::-moz-placeholder {\n  /* Firefox 19+ */\n  color: #cccccc; }\n\n:-ms-input-placeholder {\n  color: #cccccc; }\n\n/* Add height value for select elements to match text input height */\nselect {\n  -webkit-appearance: none !important;\n  -moz-appearance: none !important;\n  background-color: #FAFAFA;\n  border-radius: 0;\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgeD0iMTJweCIgeT0iMHB4IiB3aWR0aD0iMjRweCIgaGVpZ2h0PSIzcHgiIHZpZXdCb3g9IjAgMCA2IDMiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDYgMyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBvbHlnb24gcG9pbnRzPSI1Ljk5MiwwIDIuOTkyLDMgLTAuMDA4LDAgIi8+PC9zdmc+);\n  background-position: 100% center;\n  background-repeat: no-repeat;\n  border-style: solid;\n  border-width: 1px;\n  border-color: #cccccc;\n  color: rgba(0, 0, 0, 0.75);\n  font-family: inherit;\n  font-size: 0.875rem;\n  line-height: normal;\n  padding: 0.5rem;\n  border-radius: 0;\n  height: 2.3125rem; }\n  select::-ms-expand {\n    display: none; }\n  select.radius {\n    border-radius: 3px; }\n  select:hover {\n    background-color: #f3f3f3;\n    border-color: #999999; }\n  select:disabled {\n    background-color: #DDDDDD;\n    cursor: default; }\n  select[multiple] {\n    height: auto; }\n\n/* Adjust margin for form elements below */\ninput[type=\"file\"],\ninput[type=\"checkbox\"],\ninput[type=\"radio\"],\nselect {\n  margin: 0 0 1rem 0; }\n\ninput[type=\"checkbox\"] + label,\ninput[type=\"radio\"] + label {\n  display: inline-block;\n  margin-left: 0.5rem;\n  margin-right: 1rem;\n  margin-bottom: 0;\n  vertical-align: baseline; }\n\n/* Normalize file input width */\ninput[type=\"file\"] {\n  width: 100%; }\n\n/* HTML5 Number spinners settings */\n/* We add basic fieldset styling */\nfieldset {\n  border: 1px solid #DDDDDD;\n  margin: 1.125rem 0;\n  padding: 1.25rem; }\n  fieldset legend {\n    background: #FFFFFF;\n    font-weight: bold;\n    margin-left: -0.1875rem;\n    margin: 0;\n    padding: 0 0.1875rem; }\n\n/* Error Handling */\n[data-abide] .error small.error, [data-abide] .error span.error, [data-abide] span.error, [data-abide] small.error {\n  display: block;\n  font-size: 0.75rem;\n  font-style: italic;\n  font-weight: normal;\n  margin-bottom: 1rem;\n  margin-top: -1px;\n  padding: 0.375rem 0.5625rem 0.5625rem;\n  background: #f04124;\n  color: #FFFFFF; }\n[data-abide] span.error, [data-abide] small.error {\n  display: none; }\n\nspan.error, small.error {\n  display: block;\n  font-size: 0.75rem;\n  font-style: italic;\n  font-weight: normal;\n  margin-bottom: 1rem;\n  margin-top: -1px;\n  padding: 0.375rem 0.5625rem 0.5625rem;\n  background: #f04124;\n  color: #FFFFFF; }\n\n.error input,\n.error textarea,\n.error select {\n  margin-bottom: 0; }\n.error input[type=\"checkbox\"],\n.error input[type=\"radio\"] {\n  margin-bottom: 1rem; }\n.error label,\n.error label.error {\n  color: #f04124; }\n.error small.error {\n  display: block;\n  font-size: 0.75rem;\n  font-style: italic;\n  font-weight: normal;\n  margin-bottom: 1rem;\n  margin-top: -1px;\n  padding: 0.375rem 0.5625rem 0.5625rem;\n  background: #f04124;\n  color: #FFFFFF; }\n.error > label > small {\n  background: transparent;\n  color: #676767;\n  display: inline;\n  font-size: 60%;\n  font-style: normal;\n  margin: 0;\n  padding: 0;\n  text-transform: capitalize; }\n.error span.error-message {\n  display: block; }\n\ninput.error,\ntextarea.error,\nselect.error {\n  margin-bottom: 0; }\n\nlabel.error {\n  color: #f04124; }\n\n.icon-bar {\n  display: inline-block;\n  font-size: 0;\n  width: 100%;\n  background: #333333; }\n  .icon-bar > * {\n    display: block;\n    float: left;\n    font-size: 1rem;\n    margin: 0 auto;\n    padding: 1.25rem;\n    text-align: center;\n    width: 25%; }\n    .icon-bar > * i, .icon-bar > * img {\n      display: block;\n      margin: 0 auto; }\n      .icon-bar > * i + label, .icon-bar > * img + label {\n        margin-top: .0625rem; }\n    .icon-bar > * i {\n      font-size: 1.875rem;\n      vertical-align: middle; }\n    .icon-bar > * img {\n      height: 1.875rem;\n      width: 1.875rem; }\n  .icon-bar.label-right > * i, .icon-bar.label-right > * img {\n    display: inline-block;\n    margin: 0 .0625rem 0 0; }\n    .icon-bar.label-right > * i + label, .icon-bar.label-right > * img + label {\n      margin-top: 0; }\n  .icon-bar.label-right > * label {\n    display: inline-block; }\n  .icon-bar.vertical.label-right > * {\n    text-align: left; }\n  .icon-bar.vertical, .icon-bar.small-vertical {\n    height: 100%;\n    width: auto; }\n    .icon-bar.vertical .item, .icon-bar.small-vertical .item {\n      float: none;\n      margin: auto;\n      width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.medium-vertical {\n      height: 100%;\n      width: auto; }\n      .icon-bar.medium-vertical .item {\n        float: none;\n        margin: auto;\n        width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.large-vertical {\n      height: 100%;\n      width: auto; }\n      .icon-bar.large-vertical .item {\n        float: none;\n        margin: auto;\n        width: auto; } }\n  .icon-bar > * {\n    font-size: 1rem;\n    padding: 1.25rem; }\n    .icon-bar > * i + label, .icon-bar > * img + label {\n      margin-top: .0625rem;\n      font-size: 1rem; }\n    .icon-bar > * i {\n      font-size: 1.875rem; }\n    .icon-bar > * img {\n      height: 1.875rem;\n      width: 1.875rem; }\n  .icon-bar > * label {\n    color: #FFFFFF; }\n  .icon-bar > * i {\n    color: #FFFFFF; }\n  .icon-bar > a:hover {\n    background: #008CBA; }\n    .icon-bar > a:hover label {\n      color: #FFFFFF; }\n    .icon-bar > a:hover i {\n      color: #FFFFFF; }\n  .icon-bar > a.active {\n    background: #008CBA; }\n    .icon-bar > a.active label {\n      color: #FFFFFF; }\n    .icon-bar > a.active i {\n      color: #FFFFFF; }\n  .icon-bar .item.disabled {\n    cursor: not-allowed;\n    opacity: 0.7;\n    pointer-events: none; }\n    .icon-bar .item.disabled > * {\n      opacity: 0.7;\n      cursor: not-allowed; }\n  .icon-bar.two-up .item {\n    width: 50%; }\n  .icon-bar.two-up.vertical .item, .icon-bar.two-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.two-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.two-up.large-vertical .item {\n      width: auto; } }\n  .icon-bar.three-up .item {\n    width: 33.3333%; }\n  .icon-bar.three-up.vertical .item, .icon-bar.three-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.three-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.three-up.large-vertical .item {\n      width: auto; } }\n  .icon-bar.four-up .item {\n    width: 25%; }\n  .icon-bar.four-up.vertical .item, .icon-bar.four-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.four-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.four-up.large-vertical .item {\n      width: auto; } }\n  .icon-bar.five-up .item {\n    width: 20%; }\n  .icon-bar.five-up.vertical .item, .icon-bar.five-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.five-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.five-up.large-vertical .item {\n      width: auto; } }\n  .icon-bar.six-up .item {\n    width: 16.66667%; }\n  .icon-bar.six-up.vertical .item, .icon-bar.six-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.six-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.six-up.large-vertical .item {\n      width: auto; } }\n  .icon-bar.seven-up .item {\n    width: 14.28571%; }\n  .icon-bar.seven-up.vertical .item, .icon-bar.seven-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.seven-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.seven-up.large-vertical .item {\n      width: auto; } }\n  .icon-bar.eight-up .item {\n    width: 12.5%; }\n  .icon-bar.eight-up.vertical .item, .icon-bar.eight-up.small-vertical .item {\n    width: auto; }\n  @media only screen and (min-width: 40.0625em) {\n    .icon-bar.eight-up.medium-vertical .item {\n      width: auto; } }\n  @media only screen and (min-width: 64.0625em) {\n    .icon-bar.eight-up.large-vertical .item {\n      width: auto; } }\n\n.icon-bar.two-up .item {\n  width: 50%; }\n.icon-bar.two-up.vertical .item, .icon-bar.two-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.two-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.two-up.large-vertical .item {\n    width: auto; } }\n.icon-bar.three-up .item {\n  width: 33.3333%; }\n.icon-bar.three-up.vertical .item, .icon-bar.three-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.three-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.three-up.large-vertical .item {\n    width: auto; } }\n.icon-bar.four-up .item {\n  width: 25%; }\n.icon-bar.four-up.vertical .item, .icon-bar.four-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.four-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.four-up.large-vertical .item {\n    width: auto; } }\n.icon-bar.five-up .item {\n  width: 20%; }\n.icon-bar.five-up.vertical .item, .icon-bar.five-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.five-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.five-up.large-vertical .item {\n    width: auto; } }\n.icon-bar.six-up .item {\n  width: 16.66667%; }\n.icon-bar.six-up.vertical .item, .icon-bar.six-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.six-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.six-up.large-vertical .item {\n    width: auto; } }\n.icon-bar.seven-up .item {\n  width: 14.28571%; }\n.icon-bar.seven-up.vertical .item, .icon-bar.seven-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.seven-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.seven-up.large-vertical .item {\n    width: auto; } }\n.icon-bar.eight-up .item {\n  width: 12.5%; }\n.icon-bar.eight-up.vertical .item, .icon-bar.eight-up.small-vertical .item {\n  width: auto; }\n@media only screen and (min-width: 40.0625em) {\n  .icon-bar.eight-up.medium-vertical .item {\n    width: auto; } }\n@media only screen and (min-width: 64.0625em) {\n  .icon-bar.eight-up.large-vertical .item {\n    width: auto; } }\n\n.inline-list {\n  list-style: none;\n  margin-left: -1.375rem;\n  margin-right: 0;\n  margin: 0 auto 1.0625rem auto;\n  overflow: hidden;\n  padding: 0; }\n  .inline-list > li {\n    display: block;\n    float: left;\n    list-style: none;\n    margin-left: 1.375rem; }\n    .inline-list > li > * {\n      display: block; }\n\n/* Foundation Joyride */\n.joyride-list {\n  display: none; }\n\n/* Default styles for the container */\n.joyride-tip-guide {\n  background: #333333;\n  color: #FFFFFF;\n  display: none;\n  font-family: inherit;\n  font-weight: normal;\n  position: absolute;\n  top: 0;\n  width: 95%;\n  z-index: 101;\n  left: 2.5%; }\n\n.lt-ie9 .joyride-tip-guide {\n  margin-left: -400px;\n  max-width: 800px;\n  left: 50%; }\n\n.joyride-content-wrapper {\n  padding: 1.125rem 1.25rem 1.5rem;\n  width: 100%; }\n  .joyride-content-wrapper .button {\n    margin-bottom: 0 !important; }\n  .joyride-content-wrapper .joyride-prev-tip {\n    margin-right: 10px; }\n\n/* Add a little css triangle pip, older browser just miss out on the fanciness of it */\n.joyride-tip-guide .joyride-nub {\n  border: 10px solid #333333;\n  display: block;\n  height: 0;\n  position: absolute;\n  width: 0;\n  left: 22px; }\n  .joyride-tip-guide .joyride-nub.top {\n    border-color: #333333;\n    border-top-color: transparent !important;\n    border-top-style: solid;\n    border-left-color: transparent !important;\n    border-right-color: transparent !important;\n    top: -20px; }\n  .joyride-tip-guide .joyride-nub.bottom {\n    border-color: #333333 !important;\n    border-bottom-color: transparent !important;\n    border-bottom-style: solid;\n    border-left-color: transparent !important;\n    border-right-color: transparent !important;\n    bottom: -20px; }\n  .joyride-tip-guide .joyride-nub.right {\n    right: -20px; }\n  .joyride-tip-guide .joyride-nub.left {\n    left: -20px; }\n\n/* Typography */\n.joyride-tip-guide h1,\n.joyride-tip-guide h2,\n.joyride-tip-guide h3,\n.joyride-tip-guide h4,\n.joyride-tip-guide h5,\n.joyride-tip-guide h6 {\n  color: #FFFFFF;\n  font-weight: bold;\n  line-height: 1.25;\n  margin: 0; }\n\n.joyride-tip-guide p {\n  font-size: 0.875rem;\n  line-height: 1.3;\n  margin: 0 0 1.125rem 0; }\n\n.joyride-timer-indicator-wrap {\n  border: solid 1px #555555;\n  bottom: 1rem;\n  height: 3px;\n  position: absolute;\n  width: 50px;\n  right: 1.0625rem; }\n\n.joyride-timer-indicator {\n  background: #666666;\n  display: block;\n  height: inherit;\n  width: 0; }\n\n.joyride-close-tip {\n  color: #777777 !important;\n  font-size: 24px;\n  font-weight: normal;\n  line-height: .5 !important;\n  position: absolute;\n  text-decoration: none;\n  top: 10px;\n  right: 12px; }\n  .joyride-close-tip:hover, .joyride-close-tip:focus {\n    color: #EEEEEE !important; }\n\n.joyride-modal-bg {\n  background: rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  display: none;\n  height: 100%;\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 100;\n  left: 0; }\n\n.joyride-expose-wrapper {\n  background-color: #FFFFFF;\n  border-radius: 3px;\n  box-shadow: 0 0 15px #FFFFFF;\n  position: absolute;\n  z-index: 102; }\n\n.joyride-expose-cover {\n  background: transparent;\n  border-radius: 3px;\n  left: 0;\n  position: absolute;\n  top: 0;\n  z-index: 9999; }\n\n/* Styles for screens that are at least 768px; */\n@media only screen and (min-width: 40.0625em) {\n  .joyride-tip-guide {\n    width: 300px;\n    left: inherit; }\n    .joyride-tip-guide .joyride-nub.bottom {\n      border-color: #333333 !important;\n      border-bottom-color: transparent !important;\n      border-left-color: transparent !important;\n      border-right-color: transparent !important;\n      bottom: -20px; }\n    .joyride-tip-guide .joyride-nub.right {\n      border-color: #333333 !important;\n      border-right-color: transparent !important;\n      border-bottom-color: transparent !important;\n      border-top-color: transparent !important;\n      left: auto;\n      right: -20px;\n      top: 22px; }\n    .joyride-tip-guide .joyride-nub.left {\n      border-color: #333333 !important;\n      border-bottom-color: transparent !important;\n      border-left-color: transparent !important;\n      border-top-color: transparent !important;\n      left: -20px;\n      right: auto;\n      top: 22px; } }\n.keystroke,\nkbd {\n  background-color: #ededed;\n  border-color: #dddddd;\n  color: #222222;\n  border-style: solid;\n  border-width: 1px;\n  font-family: \"Consolas\", \"Menlo\", \"Courier\", monospace;\n  font-size: inherit;\n  margin: 0;\n  padding: 0.125rem 0.25rem 0;\n  border-radius: 3px; }\n\n.label {\n  display: inline-block;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-weight: normal;\n  line-height: 1;\n  margin-bottom: auto;\n  position: relative;\n  text-align: center;\n  text-decoration: none;\n  white-space: nowrap;\n  padding: 0.25rem 0.5rem 0.25rem;\n  font-size: 0.6875rem;\n  background-color: #008CBA;\n  color: #FFFFFF; }\n  .label.radius {\n    border-radius: 3px; }\n  .label.round {\n    border-radius: 1000px; }\n  .label.alert {\n    background-color: #f04124;\n    color: #FFFFFF; }\n  .label.warning {\n    background-color: #f08a24;\n    color: #FFFFFF; }\n  .label.success {\n    background-color: #43AC6A;\n    color: #FFFFFF; }\n  .label.secondary {\n    background-color: #e7e7e7;\n    color: #333333; }\n  .label.info {\n    background-color: #a0d3e8;\n    color: #333333; }\n\n[data-magellan-expedition], [data-magellan-expedition-clone] {\n  background: #FFFFFF;\n  min-width: 100%;\n  padding: 10px;\n  z-index: 50; }\n  [data-magellan-expedition] .sub-nav, [data-magellan-expedition-clone] .sub-nav {\n    margin-bottom: 0; }\n    [data-magellan-expedition] .sub-nav dd, [data-magellan-expedition-clone] .sub-nav dd {\n      margin-bottom: 0; }\n    [data-magellan-expedition] .sub-nav a, [data-magellan-expedition-clone] .sub-nav a {\n      line-height: 1.8em; }\n\n@-webkit-keyframes rotate {\n  from {\n    -webkit-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n@keyframes rotate {\n  from {\n    -webkit-transform: rotate(0deg);\n    -moz-transform: rotate(0deg);\n    -ms-transform: rotate(0deg);\n    transform: rotate(0deg); }\n  to {\n    -webkit-transform: rotate(360deg);\n    -moz-transform: rotate(360deg);\n    -ms-transform: rotate(360deg);\n    transform: rotate(360deg); } }\n/* Orbit Graceful Loading */\n.slideshow-wrapper {\n  position: relative; }\n  .slideshow-wrapper ul {\n    list-style-type: none;\n    margin: 0; }\n    .slideshow-wrapper ul li,\n    .slideshow-wrapper ul li .orbit-caption {\n      display: none; }\n    .slideshow-wrapper ul li:first-child {\n      display: block; }\n  .slideshow-wrapper .orbit-container {\n    background-color: transparent; }\n    .slideshow-wrapper .orbit-container li {\n      display: block; }\n      .slideshow-wrapper .orbit-container li .orbit-caption {\n        display: block; }\n    .slideshow-wrapper .orbit-container .orbit-bullets li {\n      display: inline-block; }\n  .slideshow-wrapper .preloader {\n    border-radius: 1000px;\n    animation-duration: 1.5s;\n    animation-iteration-count: infinite;\n    animation-name: rotate;\n    animation-timing-function: linear;\n    border-color: #555555 #FFFFFF;\n    border: solid 3px;\n    display: block;\n    height: 40px;\n    left: 50%;\n    margin-left: -20px;\n    margin-top: -20px;\n    position: absolute;\n    top: 50%;\n    width: 40px; }\n\n.orbit-container {\n  background: none;\n  overflow: hidden;\n  position: relative;\n  width: 100%; }\n  .orbit-container .orbit-slides-container {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    position: relative;\n    -webkit-transform: translateZ(0);\n    -moz-transform: translateZ(0);\n    -ms-transform: translateZ(0);\n    -o-transform: translateZ(0);\n    transform: translateZ(0); }\n    .orbit-container .orbit-slides-container img {\n      display: block;\n      max-width: 100%; }\n    .orbit-container .orbit-slides-container > * {\n      position: absolute;\n      top: 0;\n      width: 100%;\n      margin-left: 100%; }\n      .orbit-container .orbit-slides-container > *:first-child {\n        margin-left: 0; }\n      .orbit-container .orbit-slides-container > * .orbit-caption {\n        bottom: 0;\n        position: absolute;\n        background-color: rgba(51, 51, 51, 0.8);\n        color: #FFFFFF;\n        font-size: 0.875rem;\n        padding: 0.625rem 0.875rem;\n        width: 100%; }\n  .orbit-container .orbit-slide-number {\n    left: 10px;\n    background: transparent;\n    color: #FFFFFF;\n    font-size: 12px;\n    position: absolute;\n    top: 10px;\n    z-index: 10; }\n    .orbit-container .orbit-slide-number span {\n      font-weight: 700;\n      padding: 0.3125rem; }\n  .orbit-container .orbit-timer {\n    position: absolute;\n    top: 12px;\n    right: 10px;\n    height: 6px;\n    width: 100px;\n    z-index: 10; }\n    .orbit-container .orbit-timer .orbit-progress {\n      height: 3px;\n      background-color: rgba(255, 255, 255, 0.3);\n      display: block;\n      width: 0;\n      position: relative;\n      right: 20px;\n      top: 5px; }\n    .orbit-container .orbit-timer > span {\n      border: solid 4px #FFFFFF;\n      border-bottom: none;\n      border-top: none;\n      display: none;\n      height: 14px;\n      position: absolute;\n      top: 0;\n      width: 11px;\n      right: 0; }\n    .orbit-container .orbit-timer.paused > span {\n      top: 0;\n      width: 11px;\n      height: 14px;\n      border: inset 8px;\n      border-left-style: solid;\n      border-color: transparent;\n      border-left-color: #FFFFFF;\n      right: -4px; }\n      .orbit-container .orbit-timer.paused > span.dark {\n        border-left-color: #333333; }\n  .orbit-container:hover .orbit-timer > span {\n    display: block; }\n  .orbit-container .orbit-prev,\n  .orbit-container .orbit-next {\n    background-color: transparent;\n    color: white;\n    height: 60px;\n    line-height: 50px;\n    margin-top: -25px;\n    position: absolute;\n    text-indent: -9999px !important;\n    top: 45%;\n    width: 36px;\n    z-index: 10; }\n    .orbit-container .orbit-prev:hover,\n    .orbit-container .orbit-next:hover {\n      background-color: rgba(0, 0, 0, 0.3); }\n    .orbit-container .orbit-prev > span,\n    .orbit-container .orbit-next > span {\n      border: inset 10px;\n      display: block;\n      height: 0;\n      margin-top: -10px;\n      position: absolute;\n      top: 50%;\n      width: 0; }\n  .orbit-container .orbit-prev {\n    left: 0; }\n    .orbit-container .orbit-prev > span {\n      border-right-style: solid;\n      border-color: transparent;\n      border-right-color: #FFFFFF; }\n    .orbit-container .orbit-prev:hover > span {\n      border-right-color: #FFFFFF; }\n  .orbit-container .orbit-next {\n    right: 0; }\n    .orbit-container .orbit-next > span {\n      border-color: transparent;\n      border-left-style: solid;\n      border-left-color: #FFFFFF;\n      left: 50%;\n      margin-left: -4px; }\n    .orbit-container .orbit-next:hover > span {\n      border-left-color: #FFFFFF; }\n\n.orbit-bullets-container {\n  text-align: center; }\n\n.orbit-bullets {\n  display: block;\n  float: none;\n  margin: 0 auto 30px auto;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  top: 10px; }\n  .orbit-bullets li {\n    background: #CCCCCC;\n    cursor: pointer;\n    display: inline-block;\n    float: none;\n    height: 0.5625rem;\n    margin-right: 6px;\n    width: 0.5625rem;\n    border-radius: 1000px; }\n    .orbit-bullets li.active {\n      background: #999999; }\n    .orbit-bullets li:last-child {\n      margin-right: 0; }\n\n.touch .orbit-container .orbit-prev,\n.touch .orbit-container .orbit-next {\n  display: none; }\n.touch .orbit-bullets {\n  display: none; }\n\n@media only screen and (min-width: 40.0625em) {\n  .touch .orbit-container .orbit-prev,\n  .touch .orbit-container .orbit-next {\n    display: inherit; }\n  .touch .orbit-bullets {\n    display: block; } }\n@media only screen and (max-width: 40em) {\n  .orbit-stack-on-small .orbit-slides-container {\n    height: auto !important; }\n  .orbit-stack-on-small .orbit-slides-container > * {\n    margin: 0  !important;\n    opacity: 1 !important;\n    position: relative; }\n  .orbit-stack-on-small .orbit-slide-number {\n    display: none; }\n\n  .orbit-timer {\n    display: none; }\n\n  .orbit-next, .orbit-prev {\n    display: none; }\n\n  .orbit-bullets {\n    display: none; } }\nul.pagination {\n  display: block;\n  margin-left: -0.3125rem;\n  min-height: 1.5rem; }\n  ul.pagination li {\n    color: #222222;\n    font-size: 0.875rem;\n    height: 1.5rem;\n    margin-left: 0.3125rem; }\n    ul.pagination li a, ul.pagination li button {\n      border-radius: 3px;\n      transition: background-color 300ms ease-out;\n      background: none;\n      color: #999999;\n      display: block;\n      font-size: 1em;\n      font-weight: normal;\n      line-height: inherit;\n      padding: 0.0625rem 0.625rem 0.0625rem; }\n    ul.pagination li:hover a,\n    ul.pagination li a:focus, ul.pagination li:hover button,\n    ul.pagination li button:focus {\n      background: #e6e6e6; }\n    ul.pagination li.unavailable a, ul.pagination li.unavailable button {\n      cursor: default;\n      color: #999999; }\n    ul.pagination li.unavailable:hover a, ul.pagination li.unavailable a:focus, ul.pagination li.unavailable:hover button, ul.pagination li.unavailable button:focus {\n      background: transparent; }\n    ul.pagination li.current a, ul.pagination li.current button {\n      background: #008CBA;\n      color: #FFFFFF;\n      cursor: default;\n      font-weight: bold; }\n      ul.pagination li.current a:hover, ul.pagination li.current a:focus, ul.pagination li.current button:hover, ul.pagination li.current button:focus {\n        background: #008CBA; }\n  ul.pagination li {\n    display: block;\n    float: left; }\n\n/* Pagination centred wrapper */\n.pagination-centered {\n  text-align: center; }\n  .pagination-centered ul.pagination li {\n    display: inline-block;\n    float: none; }\n\n/* Panels */\n.panel {\n  border-style: solid;\n  border-width: 1px;\n  border-color: #d8d8d8;\n  margin-bottom: 1.25rem;\n  padding: 1.25rem;\n  background: #f2f2f2;\n  color: #333333; }\n  .panel > :first-child {\n    margin-top: 0; }\n  .panel > :last-child {\n    margin-bottom: 0; }\n  .panel h1, .panel h2, .panel h3, .panel h4, .panel h5, .panel h6, .panel p, .panel li, .panel dl {\n    color: #333333; }\n  .panel h1, .panel h2, .panel h3, .panel h4, .panel h5, .panel h6 {\n    line-height: 1;\n    margin-bottom: 0.625rem; }\n    .panel h1.subheader, .panel h2.subheader, .panel h3.subheader, .panel h4.subheader, .panel h5.subheader, .panel h6.subheader {\n      line-height: 1.4; }\n  .panel.callout {\n    border-style: solid;\n    border-width: 1px;\n    border-color: #d8d8d8;\n    margin-bottom: 1.25rem;\n    padding: 1.25rem;\n    background: #ecfaff;\n    color: #333333; }\n    .panel.callout > :first-child {\n      margin-top: 0; }\n    .panel.callout > :last-child {\n      margin-bottom: 0; }\n    .panel.callout h1, .panel.callout h2, .panel.callout h3, .panel.callout h4, .panel.callout h5, .panel.callout h6, .panel.callout p, .panel.callout li, .panel.callout dl {\n      color: #333333; }\n    .panel.callout h1, .panel.callout h2, .panel.callout h3, .panel.callout h4, .panel.callout h5, .panel.callout h6 {\n      line-height: 1;\n      margin-bottom: 0.625rem; }\n      .panel.callout h1.subheader, .panel.callout h2.subheader, .panel.callout h3.subheader, .panel.callout h4.subheader, .panel.callout h5.subheader, .panel.callout h6.subheader {\n        line-height: 1.4; }\n    .panel.callout a:not(.button) {\n      color: #008CBA; }\n      .panel.callout a:not(.button):hover, .panel.callout a:not(.button):focus {\n        color: #0078a0; }\n  .panel.radius {\n    border-radius: 3px; }\n\n/* Pricing Tables */\n.pricing-table {\n  border: solid 1px #DDDDDD;\n  margin-left: 0;\n  margin-bottom: 1.25rem; }\n  .pricing-table * {\n    list-style: none;\n    line-height: 1; }\n  .pricing-table .title {\n    background-color: #333333;\n    color: #EEEEEE;\n    font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n    font-size: 1rem;\n    font-weight: normal;\n    padding: 0.9375rem 1.25rem;\n    text-align: center; }\n  .pricing-table .price {\n    background-color: #F6F6F6;\n    color: #333333;\n    font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n    font-size: 2rem;\n    font-weight: normal;\n    padding: 0.9375rem 1.25rem;\n    text-align: center; }\n  .pricing-table .description {\n    background-color: #FFFFFF;\n    border-bottom: dotted 1px #DDDDDD;\n    color: #777777;\n    font-size: 0.75rem;\n    font-weight: normal;\n    line-height: 1.4;\n    padding: 0.9375rem;\n    text-align: center; }\n  .pricing-table .bullet-item {\n    background-color: #FFFFFF;\n    border-bottom: dotted 1px #DDDDDD;\n    color: #333333;\n    font-size: 0.875rem;\n    font-weight: normal;\n    padding: 0.9375rem;\n    text-align: center; }\n  .pricing-table .cta-button {\n    background-color: #FFFFFF;\n    padding: 1.25rem 1.25rem 0;\n    text-align: center; }\n\n/* Progress Bar */\n.progress {\n  background-color: #F6F6F6;\n  border: 1px solid white;\n  height: 1.5625rem;\n  margin-bottom: 0.625rem;\n  padding: 0.125rem; }\n  .progress .meter {\n    background: #008CBA;\n    display: block;\n    height: 100%; }\n  .progress.secondary .meter {\n    background: #e7e7e7;\n    display: block;\n    height: 100%; }\n  .progress.success .meter {\n    background: #43AC6A;\n    display: block;\n    height: 100%; }\n  .progress.alert .meter {\n    background: #f04124;\n    display: block;\n    height: 100%; }\n  .progress.radius {\n    border-radius: 3px; }\n    .progress.radius .meter {\n      border-radius: 2px; }\n  .progress.round {\n    border-radius: 1000px; }\n    .progress.round .meter {\n      border-radius: 999px; }\n\n.range-slider {\n  border: 1px solid #DDDDDD;\n  margin: 1.25rem 0;\n  position: relative;\n  -ms-touch-action: none;\n  touch-action: none;\n  display: block;\n  height: 1rem;\n  width: 100%;\n  background: #FAFAFA; }\n  .range-slider.vertical-range {\n    border: 1px solid #DDDDDD;\n    margin: 1.25rem 0;\n    position: relative;\n    -ms-touch-action: none;\n    touch-action: none;\n    display: inline-block;\n    height: 12.5rem;\n    width: 1rem; }\n    .range-slider.vertical-range .range-slider-handle {\n      bottom: -10.5rem;\n      margin-left: -0.5rem;\n      margin-top: 0;\n      position: absolute; }\n    .range-slider.vertical-range .range-slider-active-segment {\n      border-bottom-left-radius: inherit;\n      border-bottom-right-radius: inherit;\n      border-top-left-radius: initial;\n      bottom: 0;\n      height: auto;\n      width: 0.875rem; }\n  .range-slider.radius {\n    background: #FAFAFA;\n    border-radius: 3px; }\n    .range-slider.radius .range-slider-handle {\n      background: #008CBA;\n      border-radius: 3px; }\n      .range-slider.radius .range-slider-handle:hover {\n        background: #007ba4; }\n  .range-slider.round {\n    background: #FAFAFA;\n    border-radius: 1000px; }\n    .range-slider.round .range-slider-handle {\n      background: #008CBA;\n      border-radius: 1000px; }\n      .range-slider.round .range-slider-handle:hover {\n        background: #007ba4; }\n  .range-slider.disabled, .range-slider[disabled] {\n    background: #FAFAFA;\n    cursor: not-allowed;\n    opacity: 0.7; }\n    .range-slider.disabled .range-slider-handle, .range-slider[disabled] .range-slider-handle {\n      background: #008CBA;\n      cursor: default;\n      opacity: 0.7; }\n      .range-slider.disabled .range-slider-handle:hover, .range-slider[disabled] .range-slider-handle:hover {\n        background: #007ba4; }\n\n.range-slider-active-segment {\n  background: #e5e5e5;\n  border-bottom-left-radius: inherit;\n  border-top-left-radius: inherit;\n  display: inline-block;\n  height: 0.875rem;\n  position: absolute; }\n\n.range-slider-handle {\n  border: 1px solid none;\n  cursor: pointer;\n  display: inline-block;\n  height: 1.375rem;\n  position: absolute;\n  top: -0.3125rem;\n  width: 2rem;\n  z-index: 1;\n  -ms-touch-action: manipulation;\n  touch-action: manipulation;\n  background: #008CBA; }\n  .range-slider-handle:hover {\n    background: #007ba4; }\n\n.reveal-modal-bg {\n  background: #000000;\n  background: rgba(0, 0, 0, 0.45);\n  bottom: 0;\n  display: none;\n  left: 0;\n  position: fixed;\n  right: 0;\n  top: 0;\n  z-index: 1004;\n  left: 0; }\n\n.reveal-modal {\n  border-radius: 3px;\n  display: none;\n  position: absolute;\n  top: 0;\n  visibility: hidden;\n  width: 100%;\n  z-index: 1005;\n  left: 0;\n  background-color: #FFFFFF;\n  padding: 1.875rem;\n  border: solid 1px #666666;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.4); }\n  @media only screen and (max-width: 40em) {\n    .reveal-modal {\n      min-height: 100vh; } }\n  .reveal-modal .column, .reveal-modal .columns {\n    min-width: 0; }\n  .reveal-modal > :first-child {\n    margin-top: 0; }\n  .reveal-modal > :last-child {\n    margin-bottom: 0; }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal {\n      left: 0;\n      margin: 0 auto;\n      max-width: 62.5rem;\n      right: 0;\n      width: 80%; } }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal {\n      top: 6.25rem; } }\n  .reveal-modal.radius {\n    border-radius: 3px; }\n  .reveal-modal.round {\n    border-radius: 1000px; }\n  .reveal-modal.collapse {\n    padding: 0; }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal.tiny {\n      left: 0;\n      margin: 0 auto;\n      max-width: 62.5rem;\n      right: 0;\n      width: 30%; } }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal.small {\n      left: 0;\n      margin: 0 auto;\n      max-width: 62.5rem;\n      right: 0;\n      width: 40%; } }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal.medium {\n      left: 0;\n      margin: 0 auto;\n      max-width: 62.5rem;\n      right: 0;\n      width: 60%; } }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal.large {\n      left: 0;\n      margin: 0 auto;\n      max-width: 62.5rem;\n      right: 0;\n      width: 70%; } }\n  @media only screen and (min-width: 40.0625em) {\n    .reveal-modal.xlarge {\n      left: 0;\n      margin: 0 auto;\n      max-width: 62.5rem;\n      right: 0;\n      width: 95%; } }\n  .reveal-modal.full {\n    height: 100vh;\n    height: 100%;\n    left: 0;\n    margin-left: 0 !important;\n    max-width: none !important;\n    min-height: 100vh;\n    top: 0; }\n    @media only screen and (min-width: 40.0625em) {\n      .reveal-modal.full {\n        left: 0;\n        margin: 0 auto;\n        max-width: 62.5rem;\n        right: 0;\n        width: 100%; } }\n  .reveal-modal.toback {\n    z-index: 1003; }\n  .reveal-modal .close-reveal-modal {\n    color: #AAAAAA;\n    cursor: pointer;\n    font-size: 2.5rem;\n    font-weight: bold;\n    line-height: 1;\n    position: absolute;\n    top: 0.625rem;\n    right: 1.375rem; }\n\n.side-nav {\n  display: block;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  list-style-position: outside;\n  list-style-type: none;\n  margin: 0;\n  padding: 0.875rem 0; }\n  .side-nav li {\n    font-size: 0.875rem;\n    font-weight: normal;\n    margin: 0 0 0.4375rem 0; }\n    .side-nav li a:not(.button) {\n      color: #008CBA;\n      display: block;\n      margin: 0;\n      padding: 0.4375rem 0.875rem; }\n      .side-nav li a:not(.button):hover, .side-nav li a:not(.button):focus {\n        background: rgba(0, 0, 0, 0.025);\n        color: #1cc7ff; }\n      .side-nav li a:not(.button):active {\n        color: #1cc7ff; }\n    .side-nav li.active > a:first-child:not(.button) {\n      color: #1cc7ff;\n      font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n      font-weight: normal; }\n    .side-nav li.divider {\n      border-top: 1px solid;\n      height: 0;\n      list-style: none;\n      padding: 0;\n      border-top-color: #e6e6e6; }\n    .side-nav li.heading {\n      color: #008CBA;\n      font-size: 0.875rem;\n      font-weight: bold;\n      text-transform: uppercase; }\n\n.split.button {\n  position: relative;\n  padding-right: 5.0625rem; }\n  .split.button span {\n    display: block;\n    height: 100%;\n    position: absolute;\n    right: 0;\n    top: 0;\n    border-left: solid 1px; }\n    .split.button span:after {\n      position: absolute;\n      content: \"\";\n      width: 0;\n      height: 0;\n      display: block;\n      border-style: inset;\n      top: 50%;\n      left: 50%; }\n    .split.button span:active {\n      background-color: rgba(0, 0, 0, 0.1); }\n  .split.button span {\n    border-left-color: rgba(255, 255, 255, 0.5); }\n  .split.button span {\n    width: 3.09375rem; }\n    .split.button span:after {\n      border-top-style: solid;\n      border-width: 0.375rem;\n      margin-left: -0.375rem;\n      top: 48%; }\n  .split.button span:after {\n    border-color: #FFFFFF transparent transparent transparent; }\n  .split.button.secondary span {\n    border-left-color: rgba(255, 255, 255, 0.5); }\n  .split.button.secondary span:after {\n    border-color: #FFFFFF transparent transparent transparent; }\n  .split.button.alert span {\n    border-left-color: rgba(255, 255, 255, 0.5); }\n  .split.button.success span {\n    border-left-color: rgba(255, 255, 255, 0.5); }\n  .split.button.tiny {\n    padding-right: 3.75rem; }\n    .split.button.tiny span {\n      width: 2.25rem; }\n      .split.button.tiny span:after {\n        border-top-style: solid;\n        border-width: 0.375rem;\n        margin-left: -0.375rem;\n        top: 48%; }\n  .split.button.small {\n    padding-right: 4.375rem; }\n    .split.button.small span {\n      width: 2.625rem; }\n      .split.button.small span:after {\n        border-top-style: solid;\n        border-width: 0.4375rem;\n        margin-left: -0.375rem;\n        top: 48%; }\n  .split.button.large {\n    padding-right: 5.5rem; }\n    .split.button.large span {\n      width: 3.4375rem; }\n      .split.button.large span:after {\n        border-top-style: solid;\n        border-width: 0.3125rem;\n        margin-left: -0.375rem;\n        top: 48%; }\n  .split.button.expand {\n    padding-left: 2rem; }\n  .split.button.secondary span:after {\n    border-color: #333333 transparent transparent transparent; }\n  .split.button.radius span {\n    -webkit-border-bottom-right-radius: 3px;\n    -webkit-border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px;\n    border-top-right-radius: 3px; }\n  .split.button.round span {\n    -webkit-border-bottom-right-radius: 1000px;\n    -webkit-border-top-right-radius: 1000px;\n    border-bottom-right-radius: 1000px;\n    border-top-right-radius: 1000px; }\n  .split.button.no-pip span:before {\n    border-style: none; }\n  .split.button.no-pip span:after {\n    border-style: none; }\n  .split.button.no-pip span > i {\n    display: block;\n    left: 50%;\n    margin-left: -0.28889em;\n    margin-top: -0.48889em;\n    position: absolute;\n    top: 50%; }\n\n.sub-nav {\n  display: block;\n  margin: -0.25rem 0 1.125rem;\n  overflow: hidden;\n  padding-top: 0.25rem;\n  width: auto; }\n  .sub-nav dt {\n    text-transform: uppercase; }\n  .sub-nav dt,\n  .sub-nav dd,\n  .sub-nav li {\n    color: #999999;\n    float: left;\n    font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n    font-size: 0.875rem;\n    font-weight: normal;\n    margin-left: 1rem;\n    margin-bottom: 0; }\n    .sub-nav dt a,\n    .sub-nav dd a,\n    .sub-nav li a {\n      color: #999999;\n      padding: 0.1875rem 1rem;\n      text-decoration: none; }\n      .sub-nav dt a:hover,\n      .sub-nav dd a:hover,\n      .sub-nav li a:hover {\n        color: #737373; }\n    .sub-nav dt.active a,\n    .sub-nav dd.active a,\n    .sub-nav li.active a {\n      border-radius: 3px;\n      background: #008CBA;\n      color: #FFFFFF;\n      cursor: default;\n      font-weight: normal;\n      padding: 0.1875rem 1rem; }\n      .sub-nav dt.active a:hover,\n      .sub-nav dd.active a:hover,\n      .sub-nav li.active a:hover {\n        background: #0078a0; }\n\n.switch {\n  border: none;\n  margin-bottom: 1.5rem;\n  outline: 0;\n  padding: 0;\n  position: relative;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none; }\n  .switch label {\n    background: #DDDDDD;\n    color: transparent;\n    cursor: pointer;\n    display: block;\n    margin-bottom: 1rem;\n    position: relative;\n    text-indent: 100%;\n    width: 4rem;\n    height: 2rem;\n    transition: left 0.15s ease-out; }\n  .switch input {\n    left: 10px;\n    opacity: 0;\n    padding: 0;\n    position: absolute;\n    top: 9px; }\n    .switch input + label {\n      margin-left: 0;\n      margin-right: 0; }\n  .switch label:after {\n    background: #FFFFFF;\n    content: \"\";\n    display: block;\n    height: 1.5rem;\n    left: .25rem;\n    position: absolute;\n    top: .25rem;\n    width: 1.5rem;\n    -webkit-transition: left 0.15s ease-out;\n    -moz-transition: left 0.15s ease-out;\n    -o-transition: translate3d(0, 0, 0);\n    transition: left 0.15s ease-out;\n    -webkit-transform: translate3d(0, 0, 0);\n    -moz-transform: translate3d(0, 0, 0);\n    -ms-transform: translate3d(0, 0, 0);\n    -o-transform: translate3d(0, 0, 0);\n    transform: translate3d(0, 0, 0); }\n  .switch input:checked + label {\n    background: #008CBA; }\n  .switch input:checked + label:after {\n    left: 2.25rem; }\n  .switch label {\n    height: 2rem;\n    width: 4rem; }\n  .switch label:after {\n    height: 1.5rem;\n    width: 1.5rem; }\n  .switch input:checked + label:after {\n    left: 2.25rem; }\n  .switch label {\n    color: transparent;\n    background: #DDDDDD; }\n  .switch label:after {\n    background: #FFFFFF; }\n  .switch input:checked + label {\n    background: #008CBA; }\n  .switch.large label {\n    height: 2.5rem;\n    width: 5rem; }\n  .switch.large label:after {\n    height: 2rem;\n    width: 2rem; }\n  .switch.large input:checked + label:after {\n    left: 2.75rem; }\n  .switch.small label {\n    height: 1.75rem;\n    width: 3.5rem; }\n  .switch.small label:after {\n    height: 1.25rem;\n    width: 1.25rem; }\n  .switch.small input:checked + label:after {\n    left: 2rem; }\n  .switch.tiny label {\n    height: 1.5rem;\n    width: 3rem; }\n  .switch.tiny label:after {\n    height: 1rem;\n    width: 1rem; }\n  .switch.tiny input:checked + label:after {\n    left: 1.75rem; }\n  .switch.radius label {\n    border-radius: 4px; }\n  .switch.radius label:after {\n    border-radius: 3px; }\n  .switch.round {\n    border-radius: 1000px; }\n    .switch.round label {\n      border-radius: 2rem; }\n    .switch.round label:after {\n      border-radius: 2rem; }\n\ntable {\n  background: #FFFFFF;\n  border: solid 1px #DDDDDD;\n  margin-bottom: 1.25rem;\n  table-layout: auto; }\n  table caption {\n    background: transparent;\n    color: #222222;\n    font-size: 1rem;\n    font-weight: bold; }\n  table thead {\n    background: #F5F5F5; }\n    table thead tr th,\n    table thead tr td {\n      color: #222222;\n      font-size: 0.875rem;\n      font-weight: bold;\n      padding: 0.5rem 0.625rem 0.625rem; }\n  table tfoot {\n    background: #F5F5F5; }\n    table tfoot tr th,\n    table tfoot tr td {\n      color: #222222;\n      font-size: 0.875rem;\n      font-weight: bold;\n      padding: 0.5rem 0.625rem 0.625rem; }\n  table tr th,\n  table tr td {\n    color: #222222;\n    font-size: 0.875rem;\n    padding: 0.5625rem 0.625rem;\n    text-align: left; }\n  table tr.even, table tr.alt, table tr:nth-of-type(even) {\n    background: #F9F9F9; }\n  table thead tr th,\n  table tfoot tr th,\n  table tfoot tr td,\n  table tbody tr th,\n  table tbody tr td,\n  table tr td {\n    display: table-cell;\n    line-height: 1.125rem; }\n\n.tabs {\n  margin-bottom: 0 !important;\n  margin-left: 0; }\n  .tabs:before, .tabs:after {\n    content: \" \";\n    display: table; }\n  .tabs:after {\n    clear: both; }\n  .tabs dd,\n  .tabs .tab-title {\n    float: left;\n    list-style: none;\n    margin-bottom: 0 !important;\n    position: relative; }\n    .tabs dd > a,\n    .tabs .tab-title > a {\n      display: block;\n      background-color: #EFEFEF;\n      color: #222222;\n      font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n      font-size: 1rem;\n      padding: 1rem 2rem; }\n      .tabs dd > a:hover,\n      .tabs .tab-title > a:hover {\n        background-color: #e1e1e1; }\n    .tabs dd.active a,\n    .tabs .tab-title.active a {\n      background-color: #FFFFFF;\n      color: #222222; }\n  .tabs.radius dd:first-child a,\n  .tabs.radius .tab:first-child a {\n    -webkit-border-bottom-left-radius: 3px;\n    -webkit-border-top-left-radius: 3px;\n    border-bottom-left-radius: 3px;\n    border-top-left-radius: 3px; }\n  .tabs.radius dd:last-child a,\n  .tabs.radius .tab:last-child a {\n    -webkit-border-bottom-right-radius: 3px;\n    -webkit-border-top-right-radius: 3px;\n    border-bottom-right-radius: 3px;\n    border-top-right-radius: 3px; }\n  .tabs.vertical dd,\n  .tabs.vertical .tab-title {\n    position: inherit;\n    float: none;\n    display: block;\n    top: auto; }\n\n.tabs-content {\n  margin-bottom: 1.5rem;\n  width: 100%; }\n  .tabs-content:before, .tabs-content:after {\n    content: \" \";\n    display: table; }\n  .tabs-content:after {\n    clear: both; }\n  .tabs-content > .content {\n    display: none;\n    float: left;\n    padding: 0.9375rem 0;\n    width: 100%; }\n    .tabs-content > .content.active {\n      display: block;\n      float: none; }\n    .tabs-content > .content.contained {\n      padding: 0.9375rem; }\n  .tabs-content.vertical {\n    display: block; }\n    .tabs-content.vertical > .content {\n      padding: 0 0.9375rem; }\n\n@media only screen and (min-width: 40.0625em) {\n  .tabs.vertical {\n    float: left;\n    margin: 0;\n    margin-bottom: 1.25rem !important;\n    max-width: 20%;\n    width: 20%; }\n\n  .tabs-content.vertical {\n    float: left;\n    margin-left: -1px;\n    max-width: 80%;\n    padding-left: 1rem;\n    width: 80%; } }\n.no-js .tabs-content > .content {\n  display: block;\n  float: none; }\n\n/* Image Thumbnails */\n.th {\n  border: solid 4px #FFFFFF;\n  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2);\n  display: inline-block;\n  line-height: 0;\n  max-width: 100%;\n  transition: all 200ms ease-out; }\n  .th:hover, .th:focus {\n    box-shadow: 0 0 6px 1px rgba(0, 140, 186, 0.5); }\n  .th.radius {\n    border-radius: 3px; }\n\n/* Tooltips */\n.has-tip {\n  border-bottom: dotted 1px #CCCCCC;\n  color: #333333;\n  cursor: help;\n  font-weight: bold; }\n  .has-tip:hover, .has-tip:focus {\n    border-bottom: dotted 1px #003f54;\n    color: #008CBA; }\n  .has-tip.tip-left, .has-tip.tip-right {\n    float: none !important; }\n\n.tooltip {\n  background: #333333;\n  color: #FFFFFF;\n  display: none;\n  font-size: 0.875rem;\n  font-weight: normal;\n  line-height: 1.3;\n  max-width: 300px;\n  padding: 0.75rem;\n  position: absolute;\n  width: 100%;\n  z-index: 1006;\n  left: 50%; }\n  .tooltip > .nub {\n    border-color: transparent transparent #333333 transparent;\n    border: solid 5px;\n    display: block;\n    height: 0;\n    pointer-events: none;\n    position: absolute;\n    top: -10px;\n    width: 0;\n    left: 5px; }\n    .tooltip > .nub.rtl {\n      left: auto;\n      right: 5px; }\n  .tooltip.radius {\n    border-radius: 3px; }\n  .tooltip.round {\n    border-radius: 1000px; }\n    .tooltip.round > .nub {\n      left: 2rem; }\n  .tooltip.opened {\n    border-bottom: dotted 1px #003f54 !important;\n    color: #008CBA !important; }\n\n.tap-to-close {\n  color: #777777;\n  display: block;\n  font-size: 0.625rem;\n  font-weight: normal; }\n\n@media only screen and (min-width: 40.0625em) {\n  .tooltip > .nub {\n    border-color: transparent transparent #333333 transparent;\n    top: -10px; }\n  .tooltip.tip-top > .nub {\n    border-color: #333333 transparent transparent transparent;\n    bottom: -10px;\n    top: auto; }\n  .tooltip.tip-left, .tooltip.tip-right {\n    float: none !important; }\n  .tooltip.tip-left > .nub {\n    border-color: transparent transparent transparent #333333;\n    left: auto;\n    margin-top: -5px;\n    right: -10px;\n    top: 50%; }\n  .tooltip.tip-right > .nub {\n    border-color: transparent #333333 transparent transparent;\n    left: -10px;\n    margin-top: -5px;\n    right: auto;\n    top: 50%; } }\nmeta.foundation-mq-topbar {\n  font-family: \"/only screen and (min-width:40.0625em)/\";\n  width: 40.0625em; }\n\n/* Wrapped around .top-bar to contain to grid width */\n.contain-to-grid {\n  width: 100%;\n  background: #333333; }\n  .contain-to-grid .top-bar {\n    margin-bottom: 0; }\n\n.fixed {\n  position: fixed;\n  top: 0;\n  width: 100%;\n  z-index: 99;\n  left: 0; }\n  .fixed.expanded:not(.top-bar) {\n    height: auto;\n    max-height: 100%;\n    overflow-y: auto;\n    width: 100%; }\n    .fixed.expanded:not(.top-bar) .title-area {\n      position: fixed;\n      width: 100%;\n      z-index: 99; }\n    .fixed.expanded:not(.top-bar) .top-bar-section {\n      margin-top: 2.8125rem;\n      z-index: 98; }\n\n.top-bar {\n  background: #333333;\n  height: 2.8125rem;\n  line-height: 2.8125rem;\n  margin-bottom: 0;\n  overflow: hidden;\n  position: relative; }\n  .top-bar ul {\n    list-style: none;\n    margin-bottom: 0; }\n  .top-bar .row {\n    max-width: none; }\n  .top-bar form,\n  .top-bar input,\n  .top-bar select {\n    margin-bottom: 0; }\n  .top-bar input,\n  .top-bar select {\n    font-size: 0.75rem;\n    height: 1.75rem;\n    padding-bottom: .35rem;\n    padding-top: .35rem; }\n  .top-bar .button, .top-bar button {\n    font-size: 0.75rem;\n    margin-bottom: 0;\n    padding-bottom: 0.4125rem;\n    padding-top: 0.4125rem; }\n    @media only screen and (max-width: 40em) {\n      .top-bar .button, .top-bar button {\n        position: relative;\n        top: -1px; } }\n  .top-bar .title-area {\n    margin: 0;\n    position: relative; }\n  .top-bar .name {\n    font-size: 16px;\n    height: 2.8125rem;\n    margin: 0; }\n    .top-bar .name h1, .top-bar .name h2, .top-bar .name h3, .top-bar .name h4, .top-bar .name p, .top-bar .name span {\n      font-size: 1.0625rem;\n      line-height: 2.8125rem;\n      margin: 0; }\n      .top-bar .name h1 a, .top-bar .name h2 a, .top-bar .name h3 a, .top-bar .name h4 a, .top-bar .name p a, .top-bar .name span a {\n        color: #FFFFFF;\n        display: block;\n        font-weight: normal;\n        padding: 0 0.9375rem;\n        width: 75%; }\n  .top-bar .toggle-topbar {\n    position: absolute;\n    right: 0;\n    top: 0; }\n    .top-bar .toggle-topbar a {\n      color: #FFFFFF;\n      display: block;\n      font-size: 0.8125rem;\n      font-weight: bold;\n      height: 2.8125rem;\n      line-height: 2.8125rem;\n      padding: 0 0.9375rem;\n      position: relative;\n      text-transform: uppercase; }\n    .top-bar .toggle-topbar.menu-icon {\n      margin-top: -16px;\n      top: 50%; }\n      .top-bar .toggle-topbar.menu-icon a {\n        color: #FFFFFF;\n        height: 34px;\n        line-height: 33px;\n        padding: 0 2.5rem 0 0.9375rem;\n        position: relative; }\n        .top-bar .toggle-topbar.menu-icon a span::after {\n          content: \"\";\n          display: block;\n          height: 0;\n          position: absolute;\n          margin-top: -8px;\n          top: 50%;\n          right: 0.9375rem;\n          box-shadow: 0 0 0 1px #FFFFFF, 0 7px 0 1px #FFFFFF, 0 14px 0 1px #FFFFFF;\n          width: 16px; }\n        .top-bar .toggle-topbar.menu-icon a span:hover:after {\n          box-shadow: 0 0 0 1px \"\", 0 7px 0 1px \"\", 0 14px 0 1px \"\"; }\n  .top-bar.expanded {\n    background: transparent;\n    height: auto; }\n    .top-bar.expanded .title-area {\n      background: #333333; }\n    .top-bar.expanded .toggle-topbar a {\n      color: #888888; }\n      .top-bar.expanded .toggle-topbar a span::after {\n        box-shadow: 0 0 0 1px #888888, 0 7px 0 1px #888888, 0 14px 0 1px #888888; }\n    @media screen and (-webkit-min-device-pixel-ratio: 0) {\n      .top-bar.expanded .top-bar-section .has-dropdown.moved > .dropdown,\n      .top-bar.expanded .top-bar-section .dropdown {\n        clip: initial; }\n      .top-bar.expanded .top-bar-section .has-dropdown:not(.moved) > ul {\n        padding: 0; } }\n\n.top-bar-section {\n  left: 0;\n  position: relative;\n  width: auto;\n  transition: left 300ms ease-out; }\n  .top-bar-section ul {\n    display: block;\n    font-size: 16px;\n    height: auto;\n    margin: 0;\n    padding: 0;\n    width: 100%; }\n  .top-bar-section .divider,\n  .top-bar-section [role=\"separator\"] {\n    border-top: solid 1px #1a1a1a;\n    clear: both;\n    height: 1px;\n    width: 100%; }\n  .top-bar-section ul li {\n    background: #333333; }\n    .top-bar-section ul li > a {\n      color: #FFFFFF;\n      display: block;\n      font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n      font-size: 0.8125rem;\n      font-weight: normal;\n      padding-left: 0.9375rem;\n      padding: 12px 0 12px 0.9375rem;\n      text-transform: none;\n      width: 100%; }\n      .top-bar-section ul li > a.button {\n        font-size: 0.8125rem;\n        padding-left: 0.9375rem;\n        padding-right: 0.9375rem;\n        background-color: #008CBA;\n        border-color: #007095;\n        color: #FFFFFF; }\n        .top-bar-section ul li > a.button:hover, .top-bar-section ul li > a.button:focus {\n          background-color: #007095; }\n        .top-bar-section ul li > a.button:hover, .top-bar-section ul li > a.button:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > a.button.secondary {\n        background-color: #e7e7e7;\n        border-color: #b9b9b9;\n        color: #333333; }\n        .top-bar-section ul li > a.button.secondary:hover, .top-bar-section ul li > a.button.secondary:focus {\n          background-color: #b9b9b9; }\n        .top-bar-section ul li > a.button.secondary:hover, .top-bar-section ul li > a.button.secondary:focus {\n          color: #333333; }\n      .top-bar-section ul li > a.button.success {\n        background-color: #43AC6A;\n        border-color: #368a55;\n        color: #FFFFFF; }\n        .top-bar-section ul li > a.button.success:hover, .top-bar-section ul li > a.button.success:focus {\n          background-color: #368a55; }\n        .top-bar-section ul li > a.button.success:hover, .top-bar-section ul li > a.button.success:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > a.button.alert {\n        background-color: #f04124;\n        border-color: #cf2a0e;\n        color: #FFFFFF; }\n        .top-bar-section ul li > a.button.alert:hover, .top-bar-section ul li > a.button.alert:focus {\n          background-color: #cf2a0e; }\n        .top-bar-section ul li > a.button.alert:hover, .top-bar-section ul li > a.button.alert:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > a.button.warning {\n        background-color: #f08a24;\n        border-color: #cf6e0e;\n        color: #FFFFFF; }\n        .top-bar-section ul li > a.button.warning:hover, .top-bar-section ul li > a.button.warning:focus {\n          background-color: #cf6e0e; }\n        .top-bar-section ul li > a.button.warning:hover, .top-bar-section ul li > a.button.warning:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > a.button.info {\n        background-color: #a0d3e8;\n        border-color: #61b6d9;\n        color: #333333; }\n        .top-bar-section ul li > a.button.info:hover, .top-bar-section ul li > a.button.info:focus {\n          background-color: #61b6d9; }\n        .top-bar-section ul li > a.button.info:hover, .top-bar-section ul li > a.button.info:focus {\n          color: #FFFFFF; }\n    .top-bar-section ul li > button {\n      font-size: 0.8125rem;\n      padding-left: 0.9375rem;\n      padding-right: 0.9375rem;\n      background-color: #008CBA;\n      border-color: #007095;\n      color: #FFFFFF; }\n      .top-bar-section ul li > button:hover, .top-bar-section ul li > button:focus {\n        background-color: #007095; }\n      .top-bar-section ul li > button:hover, .top-bar-section ul li > button:focus {\n        color: #FFFFFF; }\n      .top-bar-section ul li > button.secondary {\n        background-color: #e7e7e7;\n        border-color: #b9b9b9;\n        color: #333333; }\n        .top-bar-section ul li > button.secondary:hover, .top-bar-section ul li > button.secondary:focus {\n          background-color: #b9b9b9; }\n        .top-bar-section ul li > button.secondary:hover, .top-bar-section ul li > button.secondary:focus {\n          color: #333333; }\n      .top-bar-section ul li > button.success {\n        background-color: #43AC6A;\n        border-color: #368a55;\n        color: #FFFFFF; }\n        .top-bar-section ul li > button.success:hover, .top-bar-section ul li > button.success:focus {\n          background-color: #368a55; }\n        .top-bar-section ul li > button.success:hover, .top-bar-section ul li > button.success:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > button.alert {\n        background-color: #f04124;\n        border-color: #cf2a0e;\n        color: #FFFFFF; }\n        .top-bar-section ul li > button.alert:hover, .top-bar-section ul li > button.alert:focus {\n          background-color: #cf2a0e; }\n        .top-bar-section ul li > button.alert:hover, .top-bar-section ul li > button.alert:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > button.warning {\n        background-color: #f08a24;\n        border-color: #cf6e0e;\n        color: #FFFFFF; }\n        .top-bar-section ul li > button.warning:hover, .top-bar-section ul li > button.warning:focus {\n          background-color: #cf6e0e; }\n        .top-bar-section ul li > button.warning:hover, .top-bar-section ul li > button.warning:focus {\n          color: #FFFFFF; }\n      .top-bar-section ul li > button.info {\n        background-color: #a0d3e8;\n        border-color: #61b6d9;\n        color: #333333; }\n        .top-bar-section ul li > button.info:hover, .top-bar-section ul li > button.info:focus {\n          background-color: #61b6d9; }\n        .top-bar-section ul li > button.info:hover, .top-bar-section ul li > button.info:focus {\n          color: #FFFFFF; }\n    .top-bar-section ul li:hover:not(.has-form) > a {\n      background-color: #555555;\n      color: #FFFFFF;\n      background: #222222; }\n    .top-bar-section ul li.active > a {\n      background: #008CBA;\n      color: #FFFFFF; }\n      .top-bar-section ul li.active > a:hover {\n        background: #0078a0;\n        color: #FFFFFF; }\n  .top-bar-section .has-form {\n    padding: 0.9375rem; }\n  .top-bar-section .has-dropdown {\n    position: relative; }\n    .top-bar-section .has-dropdown > a:after {\n      border: inset 5px;\n      content: \"\";\n      display: block;\n      height: 0;\n      width: 0;\n      border-color: transparent transparent transparent rgba(255, 255, 255, 0.4);\n      border-left-style: solid;\n      margin-right: 0.9375rem;\n      margin-top: -4.5px;\n      position: absolute;\n      top: 50%;\n      right: 0; }\n    .top-bar-section .has-dropdown.moved {\n      position: static; }\n      .top-bar-section .has-dropdown.moved > .dropdown {\n        position: static !important;\n        height: auto;\n        width: auto;\n        overflow: visible;\n        clip: auto;\n        display: block;\n        position: absolute !important;\n        width: 100%; }\n      .top-bar-section .has-dropdown.moved > a:after {\n        display: none; }\n  .top-bar-section .dropdown {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    overflow: hidden;\n    position: absolute !important;\n    width: 1px;\n    display: block;\n    padding: 0;\n    position: absolute;\n    top: 0;\n    z-index: 99;\n    left: 100%; }\n    .top-bar-section .dropdown li {\n      height: auto;\n      width: 100%; }\n      .top-bar-section .dropdown li a {\n        font-weight: normal;\n        padding: 8px 0.9375rem; }\n        .top-bar-section .dropdown li a.parent-link {\n          font-weight: normal; }\n      .top-bar-section .dropdown li.title h5, .top-bar-section .dropdown li.parent-link {\n        margin-bottom: 0;\n        margin-top: 0;\n        font-size: 1.125rem; }\n        .top-bar-section .dropdown li.title h5 a, .top-bar-section .dropdown li.parent-link a {\n          color: #FFFFFF;\n          display: block; }\n          .top-bar-section .dropdown li.title h5 a:hover, .top-bar-section .dropdown li.parent-link a:hover {\n            background: none; }\n      .top-bar-section .dropdown li.has-form {\n        padding: 8px 0.9375rem; }\n      .top-bar-section .dropdown li .button,\n      .top-bar-section .dropdown li button {\n        top: auto; }\n    .top-bar-section .dropdown label {\n      color: #777777;\n      font-size: 0.625rem;\n      font-weight: bold;\n      margin-bottom: 0;\n      padding: 8px 0.9375rem 2px;\n      text-transform: uppercase; }\n\n.js-generated {\n  display: block; }\n\n@media only screen and (min-width: 40.0625em) {\n  .top-bar {\n    background: #333333;\n    overflow: visible; }\n    .top-bar:before, .top-bar:after {\n      content: \" \";\n      display: table; }\n    .top-bar:after {\n      clear: both; }\n    .top-bar .toggle-topbar {\n      display: none; }\n    .top-bar .title-area {\n      float: left; }\n    .top-bar .name h1 a,\n    .top-bar .name h2 a,\n    .top-bar .name h3 a,\n    .top-bar .name h4 a,\n    .top-bar .name h5 a,\n    .top-bar .name h6 a {\n      width: auto; }\n    .top-bar input,\n    .top-bar select,\n    .top-bar .button,\n    .top-bar button {\n      font-size: 0.875rem;\n      height: 1.75rem;\n      position: relative;\n      top: 0.53125rem; }\n    .top-bar.expanded {\n      background: #333333; }\n\n  .contain-to-grid .top-bar {\n    margin-bottom: 0;\n    margin: 0 auto;\n    max-width: 62.5rem; }\n\n  .top-bar-section {\n    transition: none 0 0;\n    left: 0 !important; }\n    .top-bar-section ul {\n      display: inline;\n      height: auto !important;\n      width: auto; }\n      .top-bar-section ul li {\n        float: left; }\n        .top-bar-section ul li .js-generated {\n          display: none; }\n    .top-bar-section li.hover > a:not(.button) {\n      background-color: #555555;\n      background: #222222;\n      color: #FFFFFF; }\n    .top-bar-section li:not(.has-form) a:not(.button) {\n      background: #333333;\n      line-height: 2.8125rem;\n      padding: 0 0.9375rem; }\n      .top-bar-section li:not(.has-form) a:not(.button):hover {\n        background-color: #555555;\n        background: #222222; }\n    .top-bar-section li.active:not(.has-form) a:not(.button) {\n      background: #008CBA;\n      color: #FFFFFF;\n      line-height: 2.8125rem;\n      padding: 0 0.9375rem; }\n      .top-bar-section li.active:not(.has-form) a:not(.button):hover {\n        background: #0078a0;\n        color: #FFFFFF; }\n    .top-bar-section .has-dropdown > a {\n      padding-right: 2.1875rem !important; }\n      .top-bar-section .has-dropdown > a:after {\n        border: inset 5px;\n        content: \"\";\n        display: block;\n        height: 0;\n        width: 0;\n        border-color: rgba(255, 255, 255, 0.4) transparent transparent transparent;\n        border-top-style: solid;\n        margin-top: -2.5px;\n        top: 1.40625rem; }\n    .top-bar-section .has-dropdown.moved {\n      position: relative; }\n      .top-bar-section .has-dropdown.moved > .dropdown {\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        overflow: hidden;\n        position: absolute !important;\n        width: 1px;\n        display: block; }\n    .top-bar-section .has-dropdown.hover > .dropdown, .top-bar-section .has-dropdown.not-click:hover > .dropdown {\n      position: static !important;\n      height: auto;\n      width: auto;\n      overflow: visible;\n      clip: auto;\n      display: block;\n      position: absolute !important; }\n    .top-bar-section .has-dropdown > a:focus + .dropdown {\n      position: static !important;\n      height: auto;\n      width: auto;\n      overflow: visible;\n      clip: auto;\n      display: block;\n      position: absolute !important; }\n    .top-bar-section .has-dropdown .dropdown li.has-dropdown > a:after {\n      border: none;\n      content: \"\\00bb\";\n      top: 0.1875rem;\n      right: 5px; }\n    .top-bar-section .dropdown {\n      left: 0;\n      background: transparent;\n      min-width: 100%;\n      top: auto; }\n      .top-bar-section .dropdown li a {\n        background: #333333;\n        color: #FFFFFF;\n        line-height: 2.8125rem;\n        padding: 12px 0.9375rem;\n        white-space: nowrap; }\n      .top-bar-section .dropdown li:not(.has-form):not(.active) > a:not(.button) {\n        background: #333333;\n        color: #FFFFFF; }\n      .top-bar-section .dropdown li:not(.has-form):not(.active):hover > a:not(.button) {\n        background-color: #555555;\n        color: #FFFFFF;\n        background: #222222; }\n      .top-bar-section .dropdown li label {\n        background: #333333;\n        white-space: nowrap; }\n      .top-bar-section .dropdown li .dropdown {\n        left: 100%;\n        top: 0; }\n    .top-bar-section > ul > .divider,\n    .top-bar-section > ul > [role=\"separator\"] {\n      border-right: solid 1px #4e4e4e;\n      border-bottom: none;\n      border-top: none;\n      clear: none;\n      height: 2.8125rem;\n      width: 0; }\n    .top-bar-section .has-form {\n      background: #333333;\n      height: 2.8125rem;\n      padding: 0 0.9375rem; }\n    .top-bar-section .right li .dropdown {\n      left: auto;\n      right: 0; }\n      .top-bar-section .right li .dropdown li .dropdown {\n        right: 100%; }\n    .top-bar-section .left li .dropdown {\n      right: auto;\n      left: 0; }\n      .top-bar-section .left li .dropdown li .dropdown {\n        left: 100%; }\n\n  .no-js .top-bar-section ul li:hover > a {\n    background-color: #555555;\n    background: #222222;\n    color: #FFFFFF; }\n  .no-js .top-bar-section ul li:active > a {\n    background: #008CBA;\n    color: #FFFFFF; }\n  .no-js .top-bar-section .has-dropdown:hover > .dropdown {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto;\n    display: block;\n    position: absolute !important; }\n  .no-js .top-bar-section .has-dropdown > a:focus + .dropdown {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto;\n    display: block;\n    position: absolute !important; } }\n.text-left {\n  text-align: left !important; }\n\n.text-right {\n  text-align: right !important; }\n\n.text-center {\n  text-align: center !important; }\n\n.text-justify {\n  text-align: justify !important; }\n\n@media only screen and (max-width: 40em) {\n  .small-only-text-left {\n    text-align: left !important; }\n\n  .small-only-text-right {\n    text-align: right !important; }\n\n  .small-only-text-center {\n    text-align: center !important; }\n\n  .small-only-text-justify {\n    text-align: justify !important; } }\n@media only screen {\n  .small-text-left {\n    text-align: left !important; }\n\n  .small-text-right {\n    text-align: right !important; }\n\n  .small-text-center {\n    text-align: center !important; }\n\n  .small-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 40.0625em) and (max-width: 64em) {\n  .medium-only-text-left {\n    text-align: left !important; }\n\n  .medium-only-text-right {\n    text-align: right !important; }\n\n  .medium-only-text-center {\n    text-align: center !important; }\n\n  .medium-only-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 40.0625em) {\n  .medium-text-left {\n    text-align: left !important; }\n\n  .medium-text-right {\n    text-align: right !important; }\n\n  .medium-text-center {\n    text-align: center !important; }\n\n  .medium-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 64.0625em) and (max-width: 90em) {\n  .large-only-text-left {\n    text-align: left !important; }\n\n  .large-only-text-right {\n    text-align: right !important; }\n\n  .large-only-text-center {\n    text-align: center !important; }\n\n  .large-only-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 64.0625em) {\n  .large-text-left {\n    text-align: left !important; }\n\n  .large-text-right {\n    text-align: right !important; }\n\n  .large-text-center {\n    text-align: center !important; }\n\n  .large-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 90.0625em) and (max-width: 120em) {\n  .xlarge-only-text-left {\n    text-align: left !important; }\n\n  .xlarge-only-text-right {\n    text-align: right !important; }\n\n  .xlarge-only-text-center {\n    text-align: center !important; }\n\n  .xlarge-only-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 90.0625em) {\n  .xlarge-text-left {\n    text-align: left !important; }\n\n  .xlarge-text-right {\n    text-align: right !important; }\n\n  .xlarge-text-center {\n    text-align: center !important; }\n\n  .xlarge-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 120.0625em) and (max-width: 6249999.9375em) {\n  .xxlarge-only-text-left {\n    text-align: left !important; }\n\n  .xxlarge-only-text-right {\n    text-align: right !important; }\n\n  .xxlarge-only-text-center {\n    text-align: center !important; }\n\n  .xxlarge-only-text-justify {\n    text-align: justify !important; } }\n@media only screen and (min-width: 120.0625em) {\n  .xxlarge-text-left {\n    text-align: left !important; }\n\n  .xxlarge-text-right {\n    text-align: right !important; }\n\n  .xxlarge-text-center {\n    text-align: center !important; }\n\n  .xxlarge-text-justify {\n    text-align: justify !important; } }\n/* Typography resets */\ndiv,\ndl,\ndt,\ndd,\nul,\nol,\nli,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\npre,\nform,\np,\nblockquote,\nth,\ntd {\n  margin: 0;\n  padding: 0; }\n\n/* Default Link Styles */\na {\n  color: #008CBA;\n  line-height: inherit;\n  text-decoration: none; }\n  a:hover, a:focus {\n    color: #0078a0; }\n  a img {\n    border: none; }\n\n/* Default paragraph styles */\np {\n  font-family: inherit;\n  font-size: 1rem;\n  font-weight: normal;\n  line-height: 1.6;\n  margin-bottom: 1.25rem;\n  text-rendering: optimizeLegibility; }\n  p.lead {\n    font-size: 1.21875rem;\n    line-height: 1.6; }\n  p aside {\n    font-size: 0.875rem;\n    font-style: italic;\n    line-height: 1.35; }\n\n/* Default header styles */\nh1, h2, h3, h4, h5, h6 {\n  color: #222222;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-style: normal;\n  font-weight: normal;\n  line-height: 1.4;\n  margin-bottom: 0.5rem;\n  margin-top: 0.2rem;\n  text-rendering: optimizeLegibility; }\n  h1 small, h2 small, h3 small, h4 small, h5 small, h6 small {\n    color: #6f6f6f;\n    font-size: 60%;\n    line-height: 0; }\n\nh1 {\n  font-size: 2.125rem; }\n\nh2 {\n  font-size: 1.6875rem; }\n\nh3 {\n  font-size: 1.375rem; }\n\nh4 {\n  font-size: 1.125rem; }\n\nh5 {\n  font-size: 1.125rem; }\n\nh6 {\n  font-size: 1rem; }\n\n.subheader {\n  line-height: 1.4;\n  color: #6f6f6f;\n  font-weight: normal;\n  margin-top: 0.2rem;\n  margin-bottom: 0.5rem; }\n\nhr {\n  border: solid #DDDDDD;\n  border-width: 1px 0 0;\n  clear: both;\n  height: 0;\n  margin: 1.25rem 0 1.1875rem; }\n\n/* Helpful Typography Defaults */\nem,\ni {\n  font-style: italic;\n  line-height: inherit; }\n\nstrong,\nb {\n  font-weight: bold;\n  line-height: inherit; }\n\nsmall {\n  font-size: 60%;\n  line-height: inherit; }\n\ncode {\n  background-color: #f8f8f8;\n  border-color: #dfdfdf;\n  border-style: solid;\n  border-width: 1px;\n  color: #333333;\n  font-family: Consolas, \"Liberation Mono\", Courier, monospace;\n  font-weight: normal;\n  padding: 0.125rem 0.3125rem 0.0625rem; }\n\n/* Lists */\nul,\nol,\ndl {\n  font-family: inherit;\n  font-size: 1rem;\n  line-height: 1.6;\n  list-style-position: outside;\n  margin-bottom: 1.25rem; }\n\nul {\n  margin-left: 1.1rem; }\n  ul.no-bullet {\n    margin-left: 0; }\n    ul.no-bullet li ul,\n    ul.no-bullet li ol {\n      margin-left: 1.25rem;\n      margin-bottom: 0;\n      list-style: none; }\n\n/* Unordered Lists */\nul li ul,\nul li ol {\n  margin-left: 1.25rem;\n  margin-bottom: 0; }\nul.square li ul, ul.circle li ul, ul.disc li ul {\n  list-style: inherit; }\nul.square {\n  list-style-type: square;\n  margin-left: 1.1rem; }\nul.circle {\n  list-style-type: circle;\n  margin-left: 1.1rem; }\nul.disc {\n  list-style-type: disc;\n  margin-left: 1.1rem; }\nul.no-bullet {\n  list-style: none; }\n\n/* Ordered Lists */\nol {\n  margin-left: 1.4rem; }\n  ol li ul,\n  ol li ol {\n    margin-left: 1.25rem;\n    margin-bottom: 0; }\n\n/* Definition Lists */\ndl dt {\n  margin-bottom: 0.3rem;\n  font-weight: bold; }\ndl dd {\n  margin-bottom: 0.75rem; }\n\n/* Abbreviations */\nabbr,\nacronym {\n  text-transform: uppercase;\n  font-size: 90%;\n  color: #222;\n  cursor: help; }\n\nabbr {\n  text-transform: none; }\n  abbr[title] {\n    border-bottom: 1px dotted #DDDDDD; }\n\n/* Blockquotes */\nblockquote {\n  margin: 0 0 1.25rem;\n  padding: 0.5625rem 1.25rem 0 1.1875rem;\n  border-left: 1px solid #DDDDDD; }\n  blockquote cite {\n    display: block;\n    font-size: 0.8125rem;\n    color: #555555; }\n    blockquote cite:before {\n      content: \"\\2014 \\0020\"; }\n    blockquote cite a,\n    blockquote cite a:visited {\n      color: #555555; }\n\nblockquote,\nblockquote p {\n  line-height: 1.6;\n  color: #6f6f6f; }\n\n/* Microformats */\n.vcard {\n  display: inline-block;\n  margin: 0 0 1.25rem 0;\n  border: 1px solid #DDDDDD;\n  padding: 0.625rem 0.75rem; }\n  .vcard li {\n    margin: 0;\n    display: block; }\n  .vcard .fn {\n    font-weight: bold;\n    font-size: 0.9375rem; }\n\n.vevent .summary {\n  font-weight: bold; }\n.vevent abbr {\n  cursor: default;\n  text-decoration: none;\n  font-weight: bold;\n  border: none;\n  padding: 0 0.0625rem; }\n\n@media only screen and (min-width: 40.0625em) {\n  h1, h2, h3, h4, h5, h6 {\n    line-height: 1.4; }\n\n  h1 {\n    font-size: 2.75rem; }\n\n  h2 {\n    font-size: 2.3125rem; }\n\n  h3 {\n    font-size: 1.6875rem; }\n\n  h4 {\n    font-size: 1.4375rem; }\n\n  h5 {\n    font-size: 1.125rem; }\n\n  h6 {\n    font-size: 1rem; } }\n.off-canvas-wrap {\n  -webkit-backface-visibility: hidden;\n  position: relative;\n  width: 100%;\n  overflow: hidden; }\n  .off-canvas-wrap.move-right, .off-canvas-wrap.move-left {\n    min-height: 100%;\n    -webkit-overflow-scrolling: touch; }\n\n.inner-wrap {\n  position: relative;\n  width: 100%;\n  -webkit-transition: -webkit-transform 500ms ease;\n  -moz-transition: -moz-transform 500ms ease;\n  -ms-transition: -ms-transform 500ms ease;\n  -o-transition: -o-transform 500ms ease;\n  transition: transform 500ms ease; }\n  .inner-wrap:before, .inner-wrap:after {\n    content: \" \";\n    display: table; }\n  .inner-wrap:after {\n    clear: both; }\n\n.tab-bar {\n  -webkit-backface-visibility: hidden;\n  background: #333333;\n  color: #FFFFFF;\n  height: 2.8125rem;\n  line-height: 2.8125rem;\n  position: relative; }\n  .tab-bar h1, .tab-bar h2, .tab-bar h3, .tab-bar h4, .tab-bar h5, .tab-bar h6 {\n    color: #FFFFFF;\n    font-weight: bold;\n    line-height: 2.8125rem;\n    margin: 0; }\n  .tab-bar h1, .tab-bar h2, .tab-bar h3, .tab-bar h4 {\n    font-size: 1.125rem; }\n\n.left-small {\n  height: 2.8125rem;\n  position: absolute;\n  top: 0;\n  width: 2.8125rem;\n  border-right: solid 1px #1a1a1a;\n  left: 0; }\n\n.right-small {\n  height: 2.8125rem;\n  position: absolute;\n  top: 0;\n  width: 2.8125rem;\n  border-left: solid 1px #1a1a1a;\n  right: 0; }\n\n.tab-bar-section {\n  height: 2.8125rem;\n  padding: 0 0.625rem;\n  position: absolute;\n  text-align: center;\n  top: 0; }\n  .tab-bar-section.left {\n    text-align: left; }\n  .tab-bar-section.right {\n    text-align: right; }\n  .tab-bar-section.left {\n    left: 0;\n    right: 2.8125rem; }\n  .tab-bar-section.right {\n    left: 2.8125rem;\n    right: 0; }\n  .tab-bar-section.middle {\n    left: 2.8125rem;\n    right: 2.8125rem; }\n\n.tab-bar .menu-icon {\n  color: #FFFFFF;\n  display: block;\n  height: 2.8125rem;\n  padding: 0;\n  position: relative;\n  text-indent: 2.1875rem;\n  transform: translate3d(0, 0, 0);\n  width: 2.8125rem; }\n  .tab-bar .menu-icon span::after {\n    content: \"\";\n    display: block;\n    height: 0;\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n    left: 0.90625rem;\n    box-shadow: 0 0 0 1px #FFFFFF, 0 7px 0 1px #FFFFFF, 0 14px 0 1px #FFFFFF;\n    width: 1rem; }\n  .tab-bar .menu-icon span:hover:after {\n    box-shadow: 0 0 0 1px #b3b3b3, 0 7px 0 1px #b3b3b3, 0 14px 0 1px #b3b3b3; }\n\n.left-off-canvas-menu {\n  -webkit-backface-visibility: hidden;\n  background: #333333;\n  bottom: 0;\n  box-sizing: content-box;\n  -webkit-overflow-scrolling: touch;\n  -ms-overflow-style: -ms-autohiding-scrollbar;\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: absolute;\n  top: 0;\n  transition: transform 500ms ease 0s;\n  width: 15.625rem;\n  z-index: 1001;\n  -webkit-transform: translate3d(-100%, 0, 0);\n  -moz-transform: translate3d(-100%, 0, 0);\n  -ms-transform: translate(-100%, 0);\n  -ms-transform: translate3d(-100%, 0, 0);\n  -o-transform: translate3d(-100%, 0, 0);\n  transform: translate3d(-100%, 0, 0);\n  left: 0; }\n  .left-off-canvas-menu * {\n    -webkit-backface-visibility: hidden; }\n\n.right-off-canvas-menu {\n  -webkit-backface-visibility: hidden;\n  background: #333333;\n  bottom: 0;\n  box-sizing: content-box;\n  -webkit-overflow-scrolling: touch;\n  -ms-overflow-style: -ms-autohiding-scrollbar;\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: absolute;\n  top: 0;\n  transition: transform 500ms ease 0s;\n  width: 15.625rem;\n  z-index: 1001;\n  -webkit-transform: translate3d(100%, 0, 0);\n  -moz-transform: translate3d(100%, 0, 0);\n  -ms-transform: translate(100%, 0);\n  -ms-transform: translate3d(100%, 0, 0);\n  -o-transform: translate3d(100%, 0, 0);\n  transform: translate3d(100%, 0, 0);\n  right: 0; }\n  .right-off-canvas-menu * {\n    -webkit-backface-visibility: hidden; }\n\nul.off-canvas-list {\n  list-style-type: none;\n  margin: 0;\n  padding: 0; }\n  ul.off-canvas-list li label {\n    background: #444444;\n    border-bottom: none;\n    border-top: 1px solid #5e5e5e;\n    color: #999999;\n    display: block;\n    font-size: 0.75rem;\n    font-weight: bold;\n    margin: 0;\n    padding: 0.3rem 0.9375rem;\n    text-transform: uppercase; }\n  ul.off-canvas-list li a {\n    border-bottom: 1px solid #262626;\n    color: rgba(255, 255, 255, 0.7);\n    display: block;\n    padding: 0.66667rem;\n    transition: background 300ms ease; }\n    ul.off-canvas-list li a:hover {\n      background: #242424; }\n    ul.off-canvas-list li a:active {\n      background: #242424; }\n\n.move-right > .inner-wrap {\n  -webkit-transform: translate3d(15.625rem, 0, 0);\n  -moz-transform: translate3d(15.625rem, 0, 0);\n  -ms-transform: translate(15.625rem, 0);\n  -ms-transform: translate3d(15.625rem, 0, 0);\n  -o-transform: translate3d(15.625rem, 0, 0);\n  transform: translate3d(15.625rem, 0, 0); }\n.move-right .exit-off-canvas {\n  -webkit-backface-visibility: hidden;\n  box-shadow: -4px 0 4px rgba(0, 0, 0, 0.5), 4px 0 4px rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  transition: background 300ms ease;\n  -webkit-tap-highlight-color: transparent;\n  background: rgba(255, 255, 255, 0.2);\n  bottom: 0;\n  display: block;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1002; }\n  @media only screen and (min-width: 40.0625em) {\n    .move-right .exit-off-canvas:hover {\n      background: rgba(255, 255, 255, 0.05); } }\n\n.move-left > .inner-wrap {\n  -webkit-transform: translate3d(-15.625rem, 0, 0);\n  -moz-transform: translate3d(-15.625rem, 0, 0);\n  -ms-transform: translate(-15.625rem, 0);\n  -ms-transform: translate3d(-15.625rem, 0, 0);\n  -o-transform: translate3d(-15.625rem, 0, 0);\n  transform: translate3d(-15.625rem, 0, 0); }\n.move-left .exit-off-canvas {\n  -webkit-backface-visibility: hidden;\n  box-shadow: -4px 0 4px rgba(0, 0, 0, 0.5), 4px 0 4px rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  transition: background 300ms ease;\n  -webkit-tap-highlight-color: transparent;\n  background: rgba(255, 255, 255, 0.2);\n  bottom: 0;\n  display: block;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1002; }\n  @media only screen and (min-width: 40.0625em) {\n    .move-left .exit-off-canvas:hover {\n      background: rgba(255, 255, 255, 0.05); } }\n\n.offcanvas-overlap .left-off-canvas-menu, .offcanvas-overlap .right-off-canvas-menu {\n  -ms-transform: none;\n  -webkit-transform: none;\n  -moz-transform: none;\n  -o-transform: none;\n  transform: none;\n  z-index: 1003; }\n.offcanvas-overlap .exit-off-canvas {\n  -webkit-backface-visibility: hidden;\n  box-shadow: -4px 0 4px rgba(0, 0, 0, 0.5), 4px 0 4px rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  transition: background 300ms ease;\n  -webkit-tap-highlight-color: transparent;\n  background: rgba(255, 255, 255, 0.2);\n  bottom: 0;\n  display: block;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1002; }\n  @media only screen and (min-width: 40.0625em) {\n    .offcanvas-overlap .exit-off-canvas:hover {\n      background: rgba(255, 255, 255, 0.05); } }\n\n.offcanvas-overlap-left .right-off-canvas-menu {\n  -ms-transform: none;\n  -webkit-transform: none;\n  -moz-transform: none;\n  -o-transform: none;\n  transform: none;\n  z-index: 1003; }\n.offcanvas-overlap-left .exit-off-canvas {\n  -webkit-backface-visibility: hidden;\n  box-shadow: -4px 0 4px rgba(0, 0, 0, 0.5), 4px 0 4px rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  transition: background 300ms ease;\n  -webkit-tap-highlight-color: transparent;\n  background: rgba(255, 255, 255, 0.2);\n  bottom: 0;\n  display: block;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1002; }\n  @media only screen and (min-width: 40.0625em) {\n    .offcanvas-overlap-left .exit-off-canvas:hover {\n      background: rgba(255, 255, 255, 0.05); } }\n\n.offcanvas-overlap-right .left-off-canvas-menu {\n  -ms-transform: none;\n  -webkit-transform: none;\n  -moz-transform: none;\n  -o-transform: none;\n  transform: none;\n  z-index: 1003; }\n.offcanvas-overlap-right .exit-off-canvas {\n  -webkit-backface-visibility: hidden;\n  box-shadow: -4px 0 4px rgba(0, 0, 0, 0.5), 4px 0 4px rgba(0, 0, 0, 0.5);\n  cursor: pointer;\n  transition: background 300ms ease;\n  -webkit-tap-highlight-color: transparent;\n  background: rgba(255, 255, 255, 0.2);\n  bottom: 0;\n  display: block;\n  left: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 1002; }\n  @media only screen and (min-width: 40.0625em) {\n    .offcanvas-overlap-right .exit-off-canvas:hover {\n      background: rgba(255, 255, 255, 0.05); } }\n\n.no-csstransforms .left-off-canvas-menu {\n  left: -15.625rem; }\n.no-csstransforms .right-off-canvas-menu {\n  right: -15.625rem; }\n.no-csstransforms .move-left > .inner-wrap {\n  right: 15.625rem; }\n.no-csstransforms .move-right > .inner-wrap {\n  left: 15.625rem; }\n\n.left-submenu {\n  -webkit-backface-visibility: hidden;\n  -webkit-overflow-scrolling: touch;\n  background: #333333;\n  bottom: 0;\n  box-sizing: content-box;\n  margin: 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: absolute;\n  top: 0;\n  width: 15.625rem;\n  z-index: 1002;\n  -webkit-transform: translate3d(-100%, 0, 0);\n  -moz-transform: translate3d(-100%, 0, 0);\n  -ms-transform: translate(-100%, 0);\n  -ms-transform: translate3d(-100%, 0, 0);\n  -o-transform: translate3d(-100%, 0, 0);\n  transform: translate3d(-100%, 0, 0);\n  left: 0;\n  -webkit-transition: -webkit-transform 500ms ease;\n  -moz-transition: -moz-transform 500ms ease;\n  -ms-transition: -ms-transform 500ms ease;\n  -o-transition: -o-transform 500ms ease;\n  transition: transform 500ms ease; }\n  .left-submenu * {\n    -webkit-backface-visibility: hidden; }\n  .left-submenu .back > a {\n    background: #444;\n    border-bottom: none;\n    border-top: 1px solid #5e5e5e;\n    color: #999999;\n    font-weight: bold;\n    padding: 0.3rem 0.9375rem;\n    text-transform: uppercase;\n    margin: 0; }\n    .left-submenu .back > a:hover {\n      background: #303030;\n      border-bottom: none;\n      border-top: 1px solid #5e5e5e; }\n    .left-submenu .back > a:before {\n      content: \"\\AB\";\n      margin-right: .5rem;\n      display: inline; }\n  .left-submenu.move-right, .left-submenu.offcanvas-overlap-right, .left-submenu.offcanvas-overlap {\n    -webkit-transform: translate3d(0%, 0, 0);\n    -moz-transform: translate3d(0%, 0, 0);\n    -ms-transform: translate(0%, 0);\n    -ms-transform: translate3d(0%, 0, 0);\n    -o-transform: translate3d(0%, 0, 0);\n    transform: translate3d(0%, 0, 0); }\n\n.right-submenu {\n  -webkit-backface-visibility: hidden;\n  -webkit-overflow-scrolling: touch;\n  background: #333333;\n  bottom: 0;\n  box-sizing: content-box;\n  margin: 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n  position: absolute;\n  top: 0;\n  width: 15.625rem;\n  z-index: 1002;\n  -webkit-transform: translate3d(100%, 0, 0);\n  -moz-transform: translate3d(100%, 0, 0);\n  -ms-transform: translate(100%, 0);\n  -ms-transform: translate3d(100%, 0, 0);\n  -o-transform: translate3d(100%, 0, 0);\n  transform: translate3d(100%, 0, 0);\n  right: 0;\n  -webkit-transition: -webkit-transform 500ms ease;\n  -moz-transition: -moz-transform 500ms ease;\n  -ms-transition: -ms-transform 500ms ease;\n  -o-transition: -o-transform 500ms ease;\n  transition: transform 500ms ease; }\n  .right-submenu * {\n    -webkit-backface-visibility: hidden; }\n  .right-submenu .back > a {\n    background: #444;\n    border-bottom: none;\n    border-top: 1px solid #5e5e5e;\n    color: #999999;\n    font-weight: bold;\n    padding: 0.3rem 0.9375rem;\n    text-transform: uppercase;\n    margin: 0; }\n    .right-submenu .back > a:hover {\n      background: #303030;\n      border-bottom: none;\n      border-top: 1px solid #5e5e5e; }\n    .right-submenu .back > a:after {\n      content: \"\\BB\";\n      margin-left: .5rem;\n      display: inline; }\n  .right-submenu.move-left, .right-submenu.offcanvas-overlap-left, .right-submenu.offcanvas-overlap {\n    -webkit-transform: translate3d(0%, 0, 0);\n    -moz-transform: translate3d(0%, 0, 0);\n    -ms-transform: translate(0%, 0);\n    -ms-transform: translate3d(0%, 0, 0);\n    -o-transform: translate3d(0%, 0, 0);\n    transform: translate3d(0%, 0, 0); }\n\n.left-off-canvas-menu ul.off-canvas-list li.has-submenu > a:after {\n  content: \"\\BB\";\n  margin-left: .5rem;\n  display: inline; }\n\n.right-off-canvas-menu ul.off-canvas-list li.has-submenu > a:before {\n  content: \"\\AB\";\n  margin-right: .5rem;\n  display: inline; }\n\n/* small displays */\n@media only screen {\n  .show-for-small-only, .show-for-small-up, .show-for-small, .show-for-small-down, .hide-for-medium-only, .hide-for-medium-up, .hide-for-medium, .show-for-medium-down, .hide-for-large-only, .hide-for-large-up, .hide-for-large, .show-for-large-down, .hide-for-xlarge-only, .hide-for-xlarge-up, .hide-for-xlarge, .show-for-xlarge-down, .hide-for-xxlarge-only, .hide-for-xxlarge-up, .hide-for-xxlarge, .show-for-xxlarge-down {\n    display: inherit !important; }\n\n  .hide-for-small-only, .hide-for-small-up, .hide-for-small, .hide-for-small-down, .show-for-medium-only, .show-for-medium-up, .show-for-medium, .hide-for-medium-down, .show-for-large-only, .show-for-large-up, .show-for-large, .hide-for-large-down, .show-for-xlarge-only, .show-for-xlarge-up, .show-for-xlarge, .hide-for-xlarge-down, .show-for-xxlarge-only, .show-for-xxlarge-up, .show-for-xxlarge, .hide-for-xxlarge-down {\n    display: none !important; }\n\n  .visible-for-small-only, .visible-for-small-up, .visible-for-small, .visible-for-small-down, .hidden-for-medium-only, .hidden-for-medium-up, .hidden-for-medium, .visible-for-medium-down, .hidden-for-large-only, .hidden-for-large-up, .hidden-for-large, .visible-for-large-down, .hidden-for-xlarge-only, .hidden-for-xlarge-up, .hidden-for-xlarge, .visible-for-xlarge-down, .hidden-for-xxlarge-only, .hidden-for-xxlarge-up, .hidden-for-xxlarge, .visible-for-xxlarge-down {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto; }\n\n  .hidden-for-small-only, .hidden-for-small-up, .hidden-for-small, .hidden-for-small-down, .visible-for-medium-only, .visible-for-medium-up, .visible-for-medium, .hidden-for-medium-down, .visible-for-large-only, .visible-for-large-up, .visible-for-large, .hidden-for-large-down, .visible-for-xlarge-only, .visible-for-xlarge-up, .visible-for-xlarge, .hidden-for-xlarge-down, .visible-for-xxlarge-only, .visible-for-xxlarge-up, .visible-for-xxlarge, .hidden-for-xxlarge-down {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    overflow: hidden;\n    position: absolute !important;\n    width: 1px; }\n\n  table.show-for-small-only, table.show-for-small-up, table.show-for-small, table.show-for-small-down, table.hide-for-medium-only, table.hide-for-medium-up, table.hide-for-medium, table.show-for-medium-down, table.hide-for-large-only, table.hide-for-large-up, table.hide-for-large, table.show-for-large-down, table.hide-for-xlarge-only, table.hide-for-xlarge-up, table.hide-for-xlarge, table.show-for-xlarge-down, table.hide-for-xxlarge-only, table.hide-for-xxlarge-up, table.hide-for-xxlarge, table.show-for-xxlarge-down {\n    display: table !important; }\n\n  thead.show-for-small-only, thead.show-for-small-up, thead.show-for-small, thead.show-for-small-down, thead.hide-for-medium-only, thead.hide-for-medium-up, thead.hide-for-medium, thead.show-for-medium-down, thead.hide-for-large-only, thead.hide-for-large-up, thead.hide-for-large, thead.show-for-large-down, thead.hide-for-xlarge-only, thead.hide-for-xlarge-up, thead.hide-for-xlarge, thead.show-for-xlarge-down, thead.hide-for-xxlarge-only, thead.hide-for-xxlarge-up, thead.hide-for-xxlarge, thead.show-for-xxlarge-down {\n    display: table-header-group !important; }\n\n  tbody.show-for-small-only, tbody.show-for-small-up, tbody.show-for-small, tbody.show-for-small-down, tbody.hide-for-medium-only, tbody.hide-for-medium-up, tbody.hide-for-medium, tbody.show-for-medium-down, tbody.hide-for-large-only, tbody.hide-for-large-up, tbody.hide-for-large, tbody.show-for-large-down, tbody.hide-for-xlarge-only, tbody.hide-for-xlarge-up, tbody.hide-for-xlarge, tbody.show-for-xlarge-down, tbody.hide-for-xxlarge-only, tbody.hide-for-xxlarge-up, tbody.hide-for-xxlarge, tbody.show-for-xxlarge-down {\n    display: table-row-group !important; }\n\n  tr.show-for-small-only, tr.show-for-small-up, tr.show-for-small, tr.show-for-small-down, tr.hide-for-medium-only, tr.hide-for-medium-up, tr.hide-for-medium, tr.show-for-medium-down, tr.hide-for-large-only, tr.hide-for-large-up, tr.hide-for-large, tr.show-for-large-down, tr.hide-for-xlarge-only, tr.hide-for-xlarge-up, tr.hide-for-xlarge, tr.show-for-xlarge-down, tr.hide-for-xxlarge-only, tr.hide-for-xxlarge-up, tr.hide-for-xxlarge, tr.show-for-xxlarge-down {\n    display: table-row; }\n\n  th.show-for-small-only, td.show-for-small-only, th.show-for-small-up, td.show-for-small-up, th.show-for-small, td.show-for-small, th.show-for-small-down, td.show-for-small-down, th.hide-for-medium-only, td.hide-for-medium-only, th.hide-for-medium-up, td.hide-for-medium-up, th.hide-for-medium, td.hide-for-medium, th.show-for-medium-down, td.show-for-medium-down, th.hide-for-large-only, td.hide-for-large-only, th.hide-for-large-up, td.hide-for-large-up, th.hide-for-large, td.hide-for-large, th.show-for-large-down, td.show-for-large-down, th.hide-for-xlarge-only, td.hide-for-xlarge-only, th.hide-for-xlarge-up, td.hide-for-xlarge-up, th.hide-for-xlarge, td.hide-for-xlarge, th.show-for-xlarge-down, td.show-for-xlarge-down, th.hide-for-xxlarge-only, td.hide-for-xxlarge-only, th.hide-for-xxlarge-up, td.hide-for-xxlarge-up, th.hide-for-xxlarge, td.hide-for-xxlarge, th.show-for-xxlarge-down, td.show-for-xxlarge-down {\n    display: table-cell !important; } }\n/* medium displays */\n@media only screen and (min-width: 40.0625em) {\n  .hide-for-small-only, .show-for-small-up, .hide-for-small, .hide-for-small-down, .show-for-medium-only, .show-for-medium-up, .show-for-medium, .show-for-medium-down, .hide-for-large-only, .hide-for-large-up, .hide-for-large, .show-for-large-down, .hide-for-xlarge-only, .hide-for-xlarge-up, .hide-for-xlarge, .show-for-xlarge-down, .hide-for-xxlarge-only, .hide-for-xxlarge-up, .hide-for-xxlarge, .show-for-xxlarge-down {\n    display: inherit !important; }\n\n  .show-for-small-only, .hide-for-small-up, .show-for-small, .show-for-small-down, .hide-for-medium-only, .hide-for-medium-up, .hide-for-medium, .hide-for-medium-down, .show-for-large-only, .show-for-large-up, .show-for-large, .hide-for-large-down, .show-for-xlarge-only, .show-for-xlarge-up, .show-for-xlarge, .hide-for-xlarge-down, .show-for-xxlarge-only, .show-for-xxlarge-up, .show-for-xxlarge, .hide-for-xxlarge-down {\n    display: none !important; }\n\n  .hidden-for-small-only, .visible-for-small-up, .hidden-for-small, .hidden-for-small-down, .visible-for-medium-only, .visible-for-medium-up, .visible-for-medium, .visible-for-medium-down, .hidden-for-large-only, .hidden-for-large-up, .hidden-for-large, .visible-for-large-down, .hidden-for-xlarge-only, .hidden-for-xlarge-up, .hidden-for-xlarge, .visible-for-xlarge-down, .hidden-for-xxlarge-only, .hidden-for-xxlarge-up, .hidden-for-xxlarge, .visible-for-xxlarge-down {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto; }\n\n  .visible-for-small-only, .hidden-for-small-up, .visible-for-small, .visible-for-small-down, .hidden-for-medium-only, .hidden-for-medium-up, .hidden-for-medium, .hidden-for-medium-down, .visible-for-large-only, .visible-for-large-up, .visible-for-large, .hidden-for-large-down, .visible-for-xlarge-only, .visible-for-xlarge-up, .visible-for-xlarge, .hidden-for-xlarge-down, .visible-for-xxlarge-only, .visible-for-xxlarge-up, .visible-for-xxlarge, .hidden-for-xxlarge-down {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    overflow: hidden;\n    position: absolute !important;\n    width: 1px; }\n\n  table.hide-for-small-only, table.show-for-small-up, table.hide-for-small, table.hide-for-small-down, table.show-for-medium-only, table.show-for-medium-up, table.show-for-medium, table.show-for-medium-down, table.hide-for-large-only, table.hide-for-large-up, table.hide-for-large, table.show-for-large-down, table.hide-for-xlarge-only, table.hide-for-xlarge-up, table.hide-for-xlarge, table.show-for-xlarge-down, table.hide-for-xxlarge-only, table.hide-for-xxlarge-up, table.hide-for-xxlarge, table.show-for-xxlarge-down {\n    display: table !important; }\n\n  thead.hide-for-small-only, thead.show-for-small-up, thead.hide-for-small, thead.hide-for-small-down, thead.show-for-medium-only, thead.show-for-medium-up, thead.show-for-medium, thead.show-for-medium-down, thead.hide-for-large-only, thead.hide-for-large-up, thead.hide-for-large, thead.show-for-large-down, thead.hide-for-xlarge-only, thead.hide-for-xlarge-up, thead.hide-for-xlarge, thead.show-for-xlarge-down, thead.hide-for-xxlarge-only, thead.hide-for-xxlarge-up, thead.hide-for-xxlarge, thead.show-for-xxlarge-down {\n    display: table-header-group !important; }\n\n  tbody.hide-for-small-only, tbody.show-for-small-up, tbody.hide-for-small, tbody.hide-for-small-down, tbody.show-for-medium-only, tbody.show-for-medium-up, tbody.show-for-medium, tbody.show-for-medium-down, tbody.hide-for-large-only, tbody.hide-for-large-up, tbody.hide-for-large, tbody.show-for-large-down, tbody.hide-for-xlarge-only, tbody.hide-for-xlarge-up, tbody.hide-for-xlarge, tbody.show-for-xlarge-down, tbody.hide-for-xxlarge-only, tbody.hide-for-xxlarge-up, tbody.hide-for-xxlarge, tbody.show-for-xxlarge-down {\n    display: table-row-group !important; }\n\n  tr.hide-for-small-only, tr.show-for-small-up, tr.hide-for-small, tr.hide-for-small-down, tr.show-for-medium-only, tr.show-for-medium-up, tr.show-for-medium, tr.show-for-medium-down, tr.hide-for-large-only, tr.hide-for-large-up, tr.hide-for-large, tr.show-for-large-down, tr.hide-for-xlarge-only, tr.hide-for-xlarge-up, tr.hide-for-xlarge, tr.show-for-xlarge-down, tr.hide-for-xxlarge-only, tr.hide-for-xxlarge-up, tr.hide-for-xxlarge, tr.show-for-xxlarge-down {\n    display: table-row; }\n\n  th.hide-for-small-only, td.hide-for-small-only, th.show-for-small-up, td.show-for-small-up, th.hide-for-small, td.hide-for-small, th.hide-for-small-down, td.hide-for-small-down, th.show-for-medium-only, td.show-for-medium-only, th.show-for-medium-up, td.show-for-medium-up, th.show-for-medium, td.show-for-medium, th.show-for-medium-down, td.show-for-medium-down, th.hide-for-large-only, td.hide-for-large-only, th.hide-for-large-up, td.hide-for-large-up, th.hide-for-large, td.hide-for-large, th.show-for-large-down, td.show-for-large-down, th.hide-for-xlarge-only, td.hide-for-xlarge-only, th.hide-for-xlarge-up, td.hide-for-xlarge-up, th.hide-for-xlarge, td.hide-for-xlarge, th.show-for-xlarge-down, td.show-for-xlarge-down, th.hide-for-xxlarge-only, td.hide-for-xxlarge-only, th.hide-for-xxlarge-up, td.hide-for-xxlarge-up, th.hide-for-xxlarge, td.hide-for-xxlarge, th.show-for-xxlarge-down, td.show-for-xxlarge-down {\n    display: table-cell !important; } }\n/* large displays */\n@media only screen and (min-width: 64.0625em) {\n  .hide-for-small-only, .show-for-small-up, .hide-for-small, .hide-for-small-down, .hide-for-medium-only, .show-for-medium-up, .hide-for-medium, .hide-for-medium-down, .show-for-large-only, .show-for-large-up, .show-for-large, .show-for-large-down, .hide-for-xlarge-only, .hide-for-xlarge-up, .hide-for-xlarge, .show-for-xlarge-down, .hide-for-xxlarge-only, .hide-for-xxlarge-up, .hide-for-xxlarge, .show-for-xxlarge-down {\n    display: inherit !important; }\n\n  .show-for-small-only, .hide-for-small-up, .show-for-small, .show-for-small-down, .show-for-medium-only, .hide-for-medium-up, .show-for-medium, .show-for-medium-down, .hide-for-large-only, .hide-for-large-up, .hide-for-large, .hide-for-large-down, .show-for-xlarge-only, .show-for-xlarge-up, .show-for-xlarge, .hide-for-xlarge-down, .show-for-xxlarge-only, .show-for-xxlarge-up, .show-for-xxlarge, .hide-for-xxlarge-down {\n    display: none !important; }\n\n  .hidden-for-small-only, .visible-for-small-up, .hidden-for-small, .hidden-for-small-down, .hidden-for-medium-only, .visible-for-medium-up, .hidden-for-medium, .hidden-for-medium-down, .visible-for-large-only, .visible-for-large-up, .visible-for-large, .visible-for-large-down, .hidden-for-xlarge-only, .hidden-for-xlarge-up, .hidden-for-xlarge, .visible-for-xlarge-down, .hidden-for-xxlarge-only, .hidden-for-xxlarge-up, .hidden-for-xxlarge, .visible-for-xxlarge-down {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto; }\n\n  .visible-for-small-only, .hidden-for-small-up, .visible-for-small, .visible-for-small-down, .visible-for-medium-only, .hidden-for-medium-up, .visible-for-medium, .visible-for-medium-down, .hidden-for-large-only, .hidden-for-large-up, .hidden-for-large, .hidden-for-large-down, .visible-for-xlarge-only, .visible-for-xlarge-up, .visible-for-xlarge, .hidden-for-xlarge-down, .visible-for-xxlarge-only, .visible-for-xxlarge-up, .visible-for-xxlarge, .hidden-for-xxlarge-down {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    overflow: hidden;\n    position: absolute !important;\n    width: 1px; }\n\n  table.hide-for-small-only, table.show-for-small-up, table.hide-for-small, table.hide-for-small-down, table.hide-for-medium-only, table.show-for-medium-up, table.hide-for-medium, table.hide-for-medium-down, table.show-for-large-only, table.show-for-large-up, table.show-for-large, table.show-for-large-down, table.hide-for-xlarge-only, table.hide-for-xlarge-up, table.hide-for-xlarge, table.show-for-xlarge-down, table.hide-for-xxlarge-only, table.hide-for-xxlarge-up, table.hide-for-xxlarge, table.show-for-xxlarge-down {\n    display: table !important; }\n\n  thead.hide-for-small-only, thead.show-for-small-up, thead.hide-for-small, thead.hide-for-small-down, thead.hide-for-medium-only, thead.show-for-medium-up, thead.hide-for-medium, thead.hide-for-medium-down, thead.show-for-large-only, thead.show-for-large-up, thead.show-for-large, thead.show-for-large-down, thead.hide-for-xlarge-only, thead.hide-for-xlarge-up, thead.hide-for-xlarge, thead.show-for-xlarge-down, thead.hide-for-xxlarge-only, thead.hide-for-xxlarge-up, thead.hide-for-xxlarge, thead.show-for-xxlarge-down {\n    display: table-header-group !important; }\n\n  tbody.hide-for-small-only, tbody.show-for-small-up, tbody.hide-for-small, tbody.hide-for-small-down, tbody.hide-for-medium-only, tbody.show-for-medium-up, tbody.hide-for-medium, tbody.hide-for-medium-down, tbody.show-for-large-only, tbody.show-for-large-up, tbody.show-for-large, tbody.show-for-large-down, tbody.hide-for-xlarge-only, tbody.hide-for-xlarge-up, tbody.hide-for-xlarge, tbody.show-for-xlarge-down, tbody.hide-for-xxlarge-only, tbody.hide-for-xxlarge-up, tbody.hide-for-xxlarge, tbody.show-for-xxlarge-down {\n    display: table-row-group !important; }\n\n  tr.hide-for-small-only, tr.show-for-small-up, tr.hide-for-small, tr.hide-for-small-down, tr.hide-for-medium-only, tr.show-for-medium-up, tr.hide-for-medium, tr.hide-for-medium-down, tr.show-for-large-only, tr.show-for-large-up, tr.show-for-large, tr.show-for-large-down, tr.hide-for-xlarge-only, tr.hide-for-xlarge-up, tr.hide-for-xlarge, tr.show-for-xlarge-down, tr.hide-for-xxlarge-only, tr.hide-for-xxlarge-up, tr.hide-for-xxlarge, tr.show-for-xxlarge-down {\n    display: table-row; }\n\n  th.hide-for-small-only, td.hide-for-small-only, th.show-for-small-up, td.show-for-small-up, th.hide-for-small, td.hide-for-small, th.hide-for-small-down, td.hide-for-small-down, th.hide-for-medium-only, td.hide-for-medium-only, th.show-for-medium-up, td.show-for-medium-up, th.hide-for-medium, td.hide-for-medium, th.hide-for-medium-down, td.hide-for-medium-down, th.show-for-large-only, td.show-for-large-only, th.show-for-large-up, td.show-for-large-up, th.show-for-large, td.show-for-large, th.show-for-large-down, td.show-for-large-down, th.hide-for-xlarge-only, td.hide-for-xlarge-only, th.hide-for-xlarge-up, td.hide-for-xlarge-up, th.hide-for-xlarge, td.hide-for-xlarge, th.show-for-xlarge-down, td.show-for-xlarge-down, th.hide-for-xxlarge-only, td.hide-for-xxlarge-only, th.hide-for-xxlarge-up, td.hide-for-xxlarge-up, th.hide-for-xxlarge, td.hide-for-xxlarge, th.show-for-xxlarge-down, td.show-for-xxlarge-down {\n    display: table-cell !important; } }\n/* xlarge displays */\n@media only screen and (min-width: 90.0625em) {\n  .hide-for-small-only, .show-for-small-up, .hide-for-small, .hide-for-small-down, .hide-for-medium-only, .show-for-medium-up, .hide-for-medium, .hide-for-medium-down, .hide-for-large-only, .show-for-large-up, .hide-for-large, .hide-for-large-down, .show-for-xlarge-only, .show-for-xlarge-up, .show-for-xlarge, .show-for-xlarge-down, .hide-for-xxlarge-only, .hide-for-xxlarge-up, .hide-for-xxlarge, .show-for-xxlarge-down {\n    display: inherit !important; }\n\n  .show-for-small-only, .hide-for-small-up, .show-for-small, .show-for-small-down, .show-for-medium-only, .hide-for-medium-up, .show-for-medium, .show-for-medium-down, .show-for-large-only, .hide-for-large-up, .show-for-large, .show-for-large-down, .hide-for-xlarge-only, .hide-for-xlarge-up, .hide-for-xlarge, .hide-for-xlarge-down, .show-for-xxlarge-only, .show-for-xxlarge-up, .show-for-xxlarge, .hide-for-xxlarge-down {\n    display: none !important; }\n\n  .hidden-for-small-only, .visible-for-small-up, .hidden-for-small, .hidden-for-small-down, .hidden-for-medium-only, .visible-for-medium-up, .hidden-for-medium, .hidden-for-medium-down, .hidden-for-large-only, .visible-for-large-up, .hidden-for-large, .hidden-for-large-down, .visible-for-xlarge-only, .visible-for-xlarge-up, .visible-for-xlarge, .visible-for-xlarge-down, .hidden-for-xxlarge-only, .hidden-for-xxlarge-up, .hidden-for-xxlarge, .visible-for-xxlarge-down {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto; }\n\n  .visible-for-small-only, .hidden-for-small-up, .visible-for-small, .visible-for-small-down, .visible-for-medium-only, .hidden-for-medium-up, .visible-for-medium, .visible-for-medium-down, .visible-for-large-only, .hidden-for-large-up, .visible-for-large, .visible-for-large-down, .hidden-for-xlarge-only, .hidden-for-xlarge-up, .hidden-for-xlarge, .hidden-for-xlarge-down, .visible-for-xxlarge-only, .visible-for-xxlarge-up, .visible-for-xxlarge, .hidden-for-xxlarge-down {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    overflow: hidden;\n    position: absolute !important;\n    width: 1px; }\n\n  table.hide-for-small-only, table.show-for-small-up, table.hide-for-small, table.hide-for-small-down, table.hide-for-medium-only, table.show-for-medium-up, table.hide-for-medium, table.hide-for-medium-down, table.hide-for-large-only, table.show-for-large-up, table.hide-for-large, table.hide-for-large-down, table.show-for-xlarge-only, table.show-for-xlarge-up, table.show-for-xlarge, table.show-for-xlarge-down, table.hide-for-xxlarge-only, table.hide-for-xxlarge-up, table.hide-for-xxlarge, table.show-for-xxlarge-down {\n    display: table !important; }\n\n  thead.hide-for-small-only, thead.show-for-small-up, thead.hide-for-small, thead.hide-for-small-down, thead.hide-for-medium-only, thead.show-for-medium-up, thead.hide-for-medium, thead.hide-for-medium-down, thead.hide-for-large-only, thead.show-for-large-up, thead.hide-for-large, thead.hide-for-large-down, thead.show-for-xlarge-only, thead.show-for-xlarge-up, thead.show-for-xlarge, thead.show-for-xlarge-down, thead.hide-for-xxlarge-only, thead.hide-for-xxlarge-up, thead.hide-for-xxlarge, thead.show-for-xxlarge-down {\n    display: table-header-group !important; }\n\n  tbody.hide-for-small-only, tbody.show-for-small-up, tbody.hide-for-small, tbody.hide-for-small-down, tbody.hide-for-medium-only, tbody.show-for-medium-up, tbody.hide-for-medium, tbody.hide-for-medium-down, tbody.hide-for-large-only, tbody.show-for-large-up, tbody.hide-for-large, tbody.hide-for-large-down, tbody.show-for-xlarge-only, tbody.show-for-xlarge-up, tbody.show-for-xlarge, tbody.show-for-xlarge-down, tbody.hide-for-xxlarge-only, tbody.hide-for-xxlarge-up, tbody.hide-for-xxlarge, tbody.show-for-xxlarge-down {\n    display: table-row-group !important; }\n\n  tr.hide-for-small-only, tr.show-for-small-up, tr.hide-for-small, tr.hide-for-small-down, tr.hide-for-medium-only, tr.show-for-medium-up, tr.hide-for-medium, tr.hide-for-medium-down, tr.hide-for-large-only, tr.show-for-large-up, tr.hide-for-large, tr.hide-for-large-down, tr.show-for-xlarge-only, tr.show-for-xlarge-up, tr.show-for-xlarge, tr.show-for-xlarge-down, tr.hide-for-xxlarge-only, tr.hide-for-xxlarge-up, tr.hide-for-xxlarge, tr.show-for-xxlarge-down {\n    display: table-row; }\n\n  th.hide-for-small-only, td.hide-for-small-only, th.show-for-small-up, td.show-for-small-up, th.hide-for-small, td.hide-for-small, th.hide-for-small-down, td.hide-for-small-down, th.hide-for-medium-only, td.hide-for-medium-only, th.show-for-medium-up, td.show-for-medium-up, th.hide-for-medium, td.hide-for-medium, th.hide-for-medium-down, td.hide-for-medium-down, th.hide-for-large-only, td.hide-for-large-only, th.show-for-large-up, td.show-for-large-up, th.hide-for-large, td.hide-for-large, th.hide-for-large-down, td.hide-for-large-down, th.show-for-xlarge-only, td.show-for-xlarge-only, th.show-for-xlarge-up, td.show-for-xlarge-up, th.show-for-xlarge, td.show-for-xlarge, th.show-for-xlarge-down, td.show-for-xlarge-down, th.hide-for-xxlarge-only, td.hide-for-xxlarge-only, th.hide-for-xxlarge-up, td.hide-for-xxlarge-up, th.hide-for-xxlarge, td.hide-for-xxlarge, th.show-for-xxlarge-down, td.show-for-xxlarge-down {\n    display: table-cell !important; } }\n/* xxlarge displays */\n@media only screen and (min-width: 120.0625em) {\n  .hide-for-small-only, .show-for-small-up, .hide-for-small, .hide-for-small-down, .hide-for-medium-only, .show-for-medium-up, .hide-for-medium, .hide-for-medium-down, .hide-for-large-only, .show-for-large-up, .hide-for-large, .hide-for-large-down, .hide-for-xlarge-only, .show-for-xlarge-up, .hide-for-xlarge, .hide-for-xlarge-down, .show-for-xxlarge-only, .show-for-xxlarge-up, .show-for-xxlarge, .show-for-xxlarge-down {\n    display: inherit !important; }\n\n  .show-for-small-only, .hide-for-small-up, .show-for-small, .show-for-small-down, .show-for-medium-only, .hide-for-medium-up, .show-for-medium, .show-for-medium-down, .show-for-large-only, .hide-for-large-up, .show-for-large, .show-for-large-down, .show-for-xlarge-only, .hide-for-xlarge-up, .show-for-xlarge, .show-for-xlarge-down, .hide-for-xxlarge-only, .hide-for-xxlarge-up, .hide-for-xxlarge, .hide-for-xxlarge-down {\n    display: none !important; }\n\n  .hidden-for-small-only, .visible-for-small-up, .hidden-for-small, .hidden-for-small-down, .hidden-for-medium-only, .visible-for-medium-up, .hidden-for-medium, .hidden-for-medium-down, .hidden-for-large-only, .visible-for-large-up, .hidden-for-large, .hidden-for-large-down, .hidden-for-xlarge-only, .visible-for-xlarge-up, .hidden-for-xlarge, .hidden-for-xlarge-down, .visible-for-xxlarge-only, .visible-for-xxlarge-up, .visible-for-xxlarge, .visible-for-xxlarge-down {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto; }\n\n  .visible-for-small-only, .hidden-for-small-up, .visible-for-small, .visible-for-small-down, .visible-for-medium-only, .hidden-for-medium-up, .visible-for-medium, .visible-for-medium-down, .visible-for-large-only, .hidden-for-large-up, .visible-for-large, .visible-for-large-down, .visible-for-xlarge-only, .hidden-for-xlarge-up, .visible-for-xlarge, .visible-for-xlarge-down, .hidden-for-xxlarge-only, .hidden-for-xxlarge-up, .hidden-for-xxlarge, .hidden-for-xxlarge-down {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    overflow: hidden;\n    position: absolute !important;\n    width: 1px; }\n\n  table.hide-for-small-only, table.show-for-small-up, table.hide-for-small, table.hide-for-small-down, table.hide-for-medium-only, table.show-for-medium-up, table.hide-for-medium, table.hide-for-medium-down, table.hide-for-large-only, table.show-for-large-up, table.hide-for-large, table.hide-for-large-down, table.hide-for-xlarge-only, table.show-for-xlarge-up, table.hide-for-xlarge, table.hide-for-xlarge-down, table.show-for-xxlarge-only, table.show-for-xxlarge-up, table.show-for-xxlarge, table.show-for-xxlarge-down {\n    display: table !important; }\n\n  thead.hide-for-small-only, thead.show-for-small-up, thead.hide-for-small, thead.hide-for-small-down, thead.hide-for-medium-only, thead.show-for-medium-up, thead.hide-for-medium, thead.hide-for-medium-down, thead.hide-for-large-only, thead.show-for-large-up, thead.hide-for-large, thead.hide-for-large-down, thead.hide-for-xlarge-only, thead.show-for-xlarge-up, thead.hide-for-xlarge, thead.hide-for-xlarge-down, thead.show-for-xxlarge-only, thead.show-for-xxlarge-up, thead.show-for-xxlarge, thead.show-for-xxlarge-down {\n    display: table-header-group !important; }\n\n  tbody.hide-for-small-only, tbody.show-for-small-up, tbody.hide-for-small, tbody.hide-for-small-down, tbody.hide-for-medium-only, tbody.show-for-medium-up, tbody.hide-for-medium, tbody.hide-for-medium-down, tbody.hide-for-large-only, tbody.show-for-large-up, tbody.hide-for-large, tbody.hide-for-large-down, tbody.hide-for-xlarge-only, tbody.show-for-xlarge-up, tbody.hide-for-xlarge, tbody.hide-for-xlarge-down, tbody.show-for-xxlarge-only, tbody.show-for-xxlarge-up, tbody.show-for-xxlarge, tbody.show-for-xxlarge-down {\n    display: table-row-group !important; }\n\n  tr.hide-for-small-only, tr.show-for-small-up, tr.hide-for-small, tr.hide-for-small-down, tr.hide-for-medium-only, tr.show-for-medium-up, tr.hide-for-medium, tr.hide-for-medium-down, tr.hide-for-large-only, tr.show-for-large-up, tr.hide-for-large, tr.hide-for-large-down, tr.hide-for-xlarge-only, tr.show-for-xlarge-up, tr.hide-for-xlarge, tr.hide-for-xlarge-down, tr.show-for-xxlarge-only, tr.show-for-xxlarge-up, tr.show-for-xxlarge, tr.show-for-xxlarge-down {\n    display: table-row; }\n\n  th.hide-for-small-only, td.hide-for-small-only, th.show-for-small-up, td.show-for-small-up, th.hide-for-small, td.hide-for-small, th.hide-for-small-down, td.hide-for-small-down, th.hide-for-medium-only, td.hide-for-medium-only, th.show-for-medium-up, td.show-for-medium-up, th.hide-for-medium, td.hide-for-medium, th.hide-for-medium-down, td.hide-for-medium-down, th.hide-for-large-only, td.hide-for-large-only, th.show-for-large-up, td.show-for-large-up, th.hide-for-large, td.hide-for-large, th.hide-for-large-down, td.hide-for-large-down, th.hide-for-xlarge-only, td.hide-for-xlarge-only, th.show-for-xlarge-up, td.show-for-xlarge-up, th.hide-for-xlarge, td.hide-for-xlarge, th.hide-for-xlarge-down, td.hide-for-xlarge-down, th.show-for-xxlarge-only, td.show-for-xxlarge-only, th.show-for-xxlarge-up, td.show-for-xxlarge-up, th.show-for-xxlarge, td.show-for-xxlarge, th.show-for-xxlarge-down, td.show-for-xxlarge-down {\n    display: table-cell !important; } }\n/* Orientation targeting */\n.show-for-landscape,\n.hide-for-portrait {\n  display: inherit !important; }\n\n.hide-for-landscape,\n.show-for-portrait {\n  display: none !important; }\n\n/* Specific visibility for tables */\ntable.hide-for-landscape, table.show-for-portrait {\n  display: table !important; }\n\nthead.hide-for-landscape, thead.show-for-portrait {\n  display: table-header-group !important; }\n\ntbody.hide-for-landscape, tbody.show-for-portrait {\n  display: table-row-group !important; }\n\ntr.hide-for-landscape, tr.show-for-portrait {\n  display: table-row !important; }\n\ntd.hide-for-landscape, td.show-for-portrait,\nth.hide-for-landscape,\nth.show-for-portrait {\n  display: table-cell !important; }\n\n@media only screen and (orientation: landscape) {\n  .show-for-landscape,\n  .hide-for-portrait {\n    display: inherit !important; }\n\n  .hide-for-landscape,\n  .show-for-portrait {\n    display: none !important; }\n\n  /* Specific visibility for tables */\n  table.show-for-landscape, table.hide-for-portrait {\n    display: table !important; }\n\n  thead.show-for-landscape, thead.hide-for-portrait {\n    display: table-header-group !important; }\n\n  tbody.show-for-landscape, tbody.hide-for-portrait {\n    display: table-row-group !important; }\n\n  tr.show-for-landscape, tr.hide-for-portrait {\n    display: table-row !important; }\n\n  td.show-for-landscape, td.hide-for-portrait,\n  th.show-for-landscape,\n  th.hide-for-portrait {\n    display: table-cell !important; } }\n@media only screen and (orientation: portrait) {\n  .show-for-portrait,\n  .hide-for-landscape {\n    display: inherit !important; }\n\n  .hide-for-portrait,\n  .show-for-landscape {\n    display: none !important; }\n\n  /* Specific visibility for tables */\n  table.show-for-portrait, table.hide-for-landscape {\n    display: table !important; }\n\n  thead.show-for-portrait, thead.hide-for-landscape {\n    display: table-header-group !important; }\n\n  tbody.show-for-portrait, tbody.hide-for-landscape {\n    display: table-row-group !important; }\n\n  tr.show-for-portrait, tr.hide-for-landscape {\n    display: table-row !important; }\n\n  td.show-for-portrait, td.hide-for-landscape,\n  th.show-for-portrait,\n  th.hide-for-landscape {\n    display: table-cell !important; } }\n/* Touch-enabled device targeting */\n.show-for-touch {\n  display: none !important; }\n\n.hide-for-touch {\n  display: inherit !important; }\n\n.touch .show-for-touch {\n  display: inherit !important; }\n\n.touch .hide-for-touch {\n  display: none !important; }\n\n/* Specific visibility for tables */\ntable.hide-for-touch {\n  display: table !important; }\n\n.touch table.show-for-touch {\n  display: table !important; }\n\nthead.hide-for-touch {\n  display: table-header-group !important; }\n\n.touch thead.show-for-touch {\n  display: table-header-group !important; }\n\ntbody.hide-for-touch {\n  display: table-row-group !important; }\n\n.touch tbody.show-for-touch {\n  display: table-row-group !important; }\n\ntr.hide-for-touch {\n  display: table-row !important; }\n\n.touch tr.show-for-touch {\n  display: table-row !important; }\n\ntd.hide-for-touch {\n  display: table-cell !important; }\n\n.touch td.show-for-touch {\n  display: table-cell !important; }\n\nth.hide-for-touch {\n  display: table-cell !important; }\n\n.touch th.show-for-touch {\n  display: table-cell !important; }\n\n/* Screen reader-specific classes */\n.show-for-sr {\n  clip: rect(1px, 1px, 1px, 1px);\n  height: 1px;\n  overflow: hidden;\n  position: absolute !important;\n  width: 1px; }\n\n.show-on-focus {\n  clip: rect(1px, 1px, 1px, 1px);\n  height: 1px;\n  overflow: hidden;\n  position: absolute !important;\n  width: 1px; }\n  .show-on-focus:focus, .show-on-focus:active {\n    position: static !important;\n    height: auto;\n    width: auto;\n    overflow: visible;\n    clip: auto; }\n\n/*\n * Print styles.\n *\n * Inlined to avoid required HTTP connection: www.phpied.com/delay-loading-your-print-css/\n * Credit to Paul Irish and HTML5 Boilerplate (html5boilerplate.com)\n*/\n.print-only {\n  display: none !important; }\n\n@media print {\n  * {\n    background: transparent !important;\n    box-shadow: none !important;\n    color: #000000 !important;\n    /* Black prints faster: h5bp.com/s */\n    text-shadow: none !important; }\n\n  .show-for-print {\n    display: block; }\n\n  .hide-for-print {\n    display: none; }\n\n  table.show-for-print {\n    display: table !important; }\n\n  thead.show-for-print {\n    display: table-header-group !important; }\n\n  tbody.show-for-print {\n    display: table-row-group !important; }\n\n  tr.show-for-print {\n    display: table-row !important; }\n\n  td.show-for-print {\n    display: table-cell !important; }\n\n  th.show-for-print {\n    display: table-cell !important; }\n\n  a,\n  a:visited {\n    text-decoration: underline; }\n\n  a[href]:after {\n    content: \" (\" attr(href) \")\"; }\n\n  abbr[title]:after {\n    content: \" (\" attr(title) \")\"; }\n\n  .ir a:after,\n  a[href^=\"javascript:\"]:after,\n  a[href^=\"#\"]:after {\n    content: \"\"; }\n\n  pre,\n  blockquote {\n    border: 1px solid #999999;\n    page-break-inside: avoid; }\n\n  thead {\n    display: table-header-group;\n    /* h5bp.com/t */ }\n\n  tr,\n  img {\n    page-break-inside: avoid; }\n\n  img {\n    max-width: 100% !important; }\n\n  @page {\n    margin: .5cm; }\n  p,\n  h2,\n  h3 {\n    orphans: 3;\n    widows: 3; }\n\n  h2,\n  h3 {\n    page-break-after: avoid; }\n\n  .hide-on-print {\n    display: none !important; }\n\n  .print-only {\n    display: block !important; }\n\n  .hide-for-print {\n    display: none !important; }\n\n  .show-for-print {\n    display: inherit !important; } }\n/* Print visibility */\n@media print {\n  .show-for-print {\n    display: block; }\n\n  .hide-for-print {\n    display: none; }\n\n  table.show-for-print {\n    display: table !important; }\n\n  thead.show-for-print {\n    display: table-header-group !important; }\n\n  tbody.show-for-print {\n    display: table-row-group !important; }\n\n  tr.show-for-print {\n    display: table-row !important; }\n\n  td.show-for-print {\n    display: table-cell !important; }\n\n  th.show-for-print {\n    display: table-cell !important; } }\n@media not print {\n  .show-for-print {\n    display: none !important; } }\n\n/*# sourceMappingURL=foundation.css.map */\n", ""]);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}

	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:0/0}function r(n){return null===n?0/0:+n}function u(n){return!isNaN(n)}function i(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n(t[i],e)<0?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n(t[i],e)>0?u=i:r=i+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function c(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function l(){this._=Object.create(null)}function s(n){return(n+="")===pa||n[0]===va?va+n:n}function f(n){return(n+="")[0]===va?n.slice(1):n}function h(n){return s(n)in this._}function g(n){return(n=s(n))in this._&&delete this._[n]}function p(){var n=[];for(var t in this._)n.push(f(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function m(){this._=Object.create(null)}function y(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=da.length;r>e;++e){var u=da[e]+t;if(u in n)return u}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new l;return t.on=function(t,u){var i,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,i=e.indexOf(o)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function S(){ta.event.preventDefault()}function k(){for(var n,t=ta.event;n=t.sourceEvent;)t=n;return t}function E(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=ta.event;u.target=n,ta.event=u,t[u.type].apply(e,r)}finally{ta.event=i}}},t}function A(n){return ya(n,_a),n}function N(n){return"function"==typeof n?n:function(){return Ma(n,this)}}function C(n){return"function"==typeof n?n:function(){return xa(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ta.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?i:u}function q(n){return n.trim().replace(/\s+/g," ")}function L(n){return new RegExp("(?:^|\\s+)"+ta.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=T(n).map(D);var u=n.length;return"function"==typeof t?r:e}function D(n){var t=L(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",q(u+" "+n))):e.setAttribute("class",q(u.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e?t.createElementNS(e,n):t.createElement(n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ta.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return ba(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],o=0,a=i.length;a>o;o++)(u=i[o])&&t(u,o,e);return n}function Z(n){return ya(n,Sa),n}function V(n){var t,e;return function(r,u,i){var o,a=n[i].update,c=a.length;for(i!=e&&(e=i,t=0),u>=t&&(t=u+1);!(o=a[t])&&++t<c;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function u(){var u=c(t,ra(arguments));r.call(this),this.addEventListener(n,this[o]=u,u.$=e),u._=t}function i(){var t,e=new RegExp("^__on([^.]+)"+ta.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),c=$;a>0&&(n=n.slice(0,a));var l=ka.get(n);return l&&(n=l,c=B),a?t?u:r:t?b:i}function $(n,t){return function(e){var r=ta.event;ta.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ta.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Aa,u="click"+r,i=ta.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ea&&(Ea="onselectstart"in e?!1:x(e.style,"userSelect")),Ea){var o=n(e).style,a=o[Ea];o[Ea]="none"}return function(n){if(i.on(r,null),Ea&&(o[Ea]=a),n){var t=function(){i.on(u,null)};i.on(u,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var u=r.createSVGPoint();if(0>Na){var i=t(n);if(i.scrollX||i.scrollY){r=ta.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Na=!(o.f||o.e),r.remove()}}return Na?(u.x=e.pageX,u.y=e.pageY):(u.x=e.clientX,u.y=e.clientY),u=u.matrixTransform(n.getScreenCTM().inverse()),[u.x,u.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ta.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nt(n){return n>1?0:-1>n?qa:Math.acos(n)}function tt(n){return n>1?Ra:-1>n?-Ra:Math.asin(n)}function et(n){return((n=Math.exp(n))-1/n)/2}function rt(n){return((n=Math.exp(n))+1/n)/2}function ut(n){return((n=Math.exp(2*n))-1)/(n+1)}function it(n){return(n=Math.sin(n/2))*n}function ot(){}function at(n,t,e){return this instanceof at?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof at?new at(n.h,n.s,n.l):bt(""+n,_t,at):new at(n,t,e)}function ct(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(o-i)*n/60:180>n?o:240>n?i+(o-i)*(240-n)/60:i}function u(n){return Math.round(255*r(n))}var i,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,i=2*e-o,new mt(u(n+120),u(n),u(n-120))}function lt(n,t,e){return this instanceof lt?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof lt?new lt(n.h,n.c,n.l):n instanceof ft?gt(n.l,n.a,n.b):gt((n=wt((n=ta.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new lt(n,t,e)}function st(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new ft(e,Math.cos(n*=Da)*t,Math.sin(n)*t)}function ft(n,t,e){return this instanceof ft?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof ft?new ft(n.l,n.a,n.b):n instanceof lt?st(n.h,n.c,n.l):wt((n=mt(n)).r,n.g,n.b):new ft(n,t,e)}function ht(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=pt(u)*Xa,r=pt(r)*$a,i=pt(i)*Ba,new mt(dt(3.2404542*u-1.5371385*r-.4985314*i),dt(-.969266*u+1.8760108*r+.041556*i),dt(.0556434*u-.2040259*r+1.0572252*i))}function gt(n,t,e){return n>0?new lt(Math.atan2(e,t)*Pa,Math.sqrt(t*t+e*e),n):new lt(0/0,0/0,n)}function pt(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function vt(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function dt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mt(n,t,e){return this instanceof mt?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mt?new mt(n.r,n.g,n.b):bt(""+n,mt,ct):new mt(n,t,e)}function yt(n){return new mt(n>>16,n>>8&255,255&n)}function Mt(n){return yt(n)+""}function xt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function bt(n,t,e){var r,u,i,o=0,a=0,c=0;if(r=/([a-z]+)\((.*)\)/i.exec(n))switch(u=r[2].split(","),r[1]){case"hsl":return e(parseFloat(u[0]),parseFloat(u[1])/100,parseFloat(u[2])/100);case"rgb":return t(kt(u[0]),kt(u[1]),kt(u[2]))}return(i=Ga.get(n.toLowerCase()))?t(i.r,i.g,i.b):(null==n||"#"!==n.charAt(0)||isNaN(i=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&i)>>4,o=o>>4|o,a=240&i,a=a>>4|a,c=15&i,c=c<<4|c):7===n.length&&(o=(16711680&i)>>16,a=(65280&i)>>8,c=255&i)),t(o,a,c))}function _t(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-i,c=(o+i)/2;return a?(u=.5>c?a/(o+i):a/(2-o-i),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=0/0,u=c>0&&1>c?0:r),new at(r,u,c)}function wt(n,t,e){n=St(n),t=St(t),e=St(e);var r=vt((.4124564*n+.3575761*t+.1804375*e)/Xa),u=vt((.2126729*n+.7151522*t+.072175*e)/$a),i=vt((.0193339*n+.119192*t+.9503041*e)/Ba);return ft(116*u-16,500*(r-u),200*(u-i))}function St(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function kt(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function Et(n){return"function"==typeof n?n:function(){return n}}function At(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Nt(t,e,n,r)}}function Nt(n,t,e,r){function u(){var n,t=c.status;if(!t&&zt(c)||t>=200&&300>t||304===t){try{n=e.call(i,c)}catch(r){return void o.error.call(i,r)}o.load.call(i,n)}else o.error.call(i,c)}var i={},o=ta.dispatch("beforesend","progress","load","error"),a={},c=new XMLHttpRequest,l=null;return!this.XDomainRequest||"withCredentials"in c||!/^(http(s)?:)?\/\//.test(n)||(c=new XDomainRequest),"onload"in c?c.onload=c.onerror=u:c.onreadystatechange=function(){c.readyState>3&&u()},c.onprogress=function(n){var t=ta.event;ta.event=n;try{o.progress.call(i,c)}finally{ta.event=t}},i.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",i)},i.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",i):t},i.responseType=function(n){return arguments.length?(l=n,i):l},i.response=function(n){return e=n,i},["get","post"].forEach(function(n){i[n]=function(){return i.send.apply(i,[n].concat(ra(arguments)))}}),i.send=function(e,r,u){if(2===arguments.length&&"function"==typeof r&&(u=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var s in a)c.setRequestHeader(s,a[s]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=l&&(c.responseType=l),null!=u&&i.on("error",u).on("load",function(n){u(null,n)}),o.beforesend.call(i,c),c.send(null==r?null:r),i},i.abort=function(){return c.abort(),i},ta.rebind(i,o,"on"),null==r?i:i.get(Ct(r))}function Ct(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function zt(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qt(){var n=Lt(),t=Tt()-n;t>24?(isFinite(t)&&(clearTimeout(tc),tc=setTimeout(qt,t)),nc=0):(nc=1,rc(qt))}function Lt(){var n=Date.now();for(ec=Ka;ec;)n>=ec.t&&(ec.f=ec.c(n-ec.t)),ec=ec.n;return n}function Tt(){for(var n,t=Ka,e=1/0;t;)t.f?t=n?n.n=t.n:Ka=t.n:(t.t<e&&(e=t.t),t=(n=t).n);return Qa=n,e}function Rt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Dt(n,t){var e=Math.pow(10,3*ga(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function Pt(n){var t=n.decimal,e=n.thousands,r=n.grouping,u=n.currency,i=r&&e?function(n,t){for(var u=n.length,i=[],o=0,a=r[0],c=0;u>0&&a>0&&(c+a+1>t&&(a=Math.max(1,t-c)),i.push(n.substring(u-=a,u+a)),!((c+=a+1)>t));)a=r[o=(o+1)%r.length];return i.reverse().join(e)}:y;return function(n){var e=ic.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",c=e[4]||"",l=e[5],s=+e[6],f=e[7],h=e[8],g=e[9],p=1,v="",d="",m=!1,y=!0;switch(h&&(h=+h.substring(1)),(l||"0"===r&&"="===o)&&(l=r="0",o="="),g){case"n":f=!0,g="g";break;case"%":p=100,d="%",g="f";break;case"p":p=100,d="%",g="r";break;case"b":case"o":case"x":case"X":"#"===c&&(v="0"+g.toLowerCase());case"c":y=!1;case"d":m=!0,h=0;break;case"s":p=-1,g="r"}"$"===c&&(v=u[0],d=u[1]),"r"!=g||h||(g="g"),null!=h&&("g"==g?h=Math.max(1,Math.min(21,h)):("e"==g||"f"==g)&&(h=Math.max(0,Math.min(20,h)))),g=oc.get(g)||Ut;var M=l&&f;return function(n){var e=d;if(m&&n%1)return"";var u=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>p){var c=ta.formatPrefix(n,h);n=c.scale(n),e=c.symbol+d}else n*=p;n=g(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=y?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!l&&f&&(x=i(x,1/0));var S=v.length+x.length+b.length+(M?0:u.length),k=s>S?new Array(S=s-S+1).join(r):"";return M&&(x=i(k+x,k.length?s-b.length:1/0)),u+=v,n=x+b,("<"===o?u+n+k:">"===o?k+u+n:"^"===o?k.substring(0,S>>=1)+u+n+k.substring(S):u+(M?n:k+n))+e}}}function Ut(n){return n+""}function jt(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Ft(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new cc(e-1)),1),e}function i(n,e){return t(n=new cc(+n),e),n}function o(n,r,i){var o=u(n),a=[];if(i>1)for(;r>o;)e(o)%i||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{cc=jt;var r=new jt;return r._=n,o(r,t,e)}finally{cc=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=o;var c=n.utc=Ht(n);return c.floor=c,c.round=Ht(r),c.ceil=Ht(u),c.offset=Ht(i),c.range=a,n}function Ht(n){return function(t,e){try{cc=jt;var r=new jt;return r._=t,n(r,e)._}finally{cc=Date}}}function Ot(n){function t(n){function t(t){for(var e,u,i,o=[],a=-1,c=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(c,a)),null!=(u=sc[e=n.charAt(++a)])&&(e=n.charAt(++a)),(i=N[e])&&(e=i(t,null==u?"e"===e?" ":"0":u)),o.push(e),c=a+1);return o.push(n.slice(c,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},u=e(r,n,t,0);if(u!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var i=null!=r.Z&&cc!==jt,o=new(i?jt:cc);return"j"in r?o.setFullYear(r.y,0,r.j):"w"in r&&("W"in r||"U"in r)?(o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),i?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var u,i,o,a=0,c=t.length,l=e.length;c>a;){if(r>=l)return-1;if(u=t.charCodeAt(a++),37===u){if(o=t.charAt(a++),i=C[o in sc?t.charAt(a++):o],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){E.lastIndex=0;var r=E.exec(t.slice(e));return r?(n.m=A.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,N.c.toString(),t,r)}function c(n,t,r){return e(n,N.x.toString(),t,r)}function l(n,t,r){return e(n,N.X.toString(),t,r)}function s(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var f=n.dateTime,h=n.date,g=n.time,p=n.periods,v=n.days,d=n.shortDays,m=n.months,y=n.shortMonths;t.utc=function(n){function e(n){try{cc=jt;var t=new cc;return t._=n,r(t)}finally{cc=Date}}var r=t(n);return e.parse=function(n){try{cc=jt;var t=r.parse(n);return t&&t._}finally{cc=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ae;var M=ta.map(),x=Yt(v),b=Zt(v),_=Yt(d),w=Zt(d),S=Yt(m),k=Zt(m),E=Yt(y),A=Zt(y);p.forEach(function(n,t){M.set(n.toLowerCase(),t)});var N={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return y[n.getMonth()]},B:function(n){return m[n.getMonth()]},c:t(f),d:function(n,t){return It(n.getDate(),t,2)},e:function(n,t){return It(n.getDate(),t,2)},H:function(n,t){return It(n.getHours(),t,2)},I:function(n,t){return It(n.getHours()%12||12,t,2)},j:function(n,t){return It(1+ac.dayOfYear(n),t,3)},L:function(n,t){return It(n.getMilliseconds(),t,3)},m:function(n,t){return It(n.getMonth()+1,t,2)},M:function(n,t){return It(n.getMinutes(),t,2)},p:function(n){return p[+(n.getHours()>=12)]},S:function(n,t){return It(n.getSeconds(),t,2)},U:function(n,t){return It(ac.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return It(ac.mondayOfYear(n),t,2)},x:t(h),X:t(g),y:function(n,t){return It(n.getFullYear()%100,t,2)},Y:function(n,t){return It(n.getFullYear()%1e4,t,4)},Z:ie,"%":function(){return"%"}},C={a:r,A:u,b:i,B:o,c:a,d:Qt,e:Qt,H:te,I:te,j:ne,L:ue,m:Kt,M:ee,p:s,S:re,U:Xt,w:Vt,W:$t,x:c,X:l,y:Wt,Y:Bt,Z:Jt,"%":oe};return t}function It(n,t,e){var r=0>n?"-":"",u=(r?-n:n)+"",i=u.length;return r+(e>i?new Array(e-i+1).join(t)+u:u)}function Yt(n){return new RegExp("^(?:"+n.map(ta.requote).join("|")+")","i")}function Zt(n){for(var t=new l,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Vt(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Xt(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function $t(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Bt(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Wt(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+2));return r?(n.y=Gt(+r[0]),e+r[0].length):-1}function Jt(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Gt(n){return n+(n>68?1900:2e3)}function Kt(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function Qt(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function ne(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function te(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function ee(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function re(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ue(n,t,e){fc.lastIndex=0;var r=fc.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function ie(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=ga(t)/60|0,u=ga(t)%60;return e+It(r,"0",2)+It(u,"0",2)}function oe(n,t,e){hc.lastIndex=0;var r=hc.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ae(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ce(){}function le(n,t,e){var r=e.s=n+t,u=r-n,i=r-u;e.t=n-i+(t-u)}function se(n,t){n&&dc.hasOwnProperty(n.type)&&dc[n.type](n,t)}function fe(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1],r[2]);t.lineEnd()}function he(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)fe(n[e],t,1);t.polygonEnd()}function ge(){function n(n,t){n*=Da,t=t*Da/2+qa/4;var e=n-r,o=e>=0?1:-1,a=o*e,c=Math.cos(t),l=Math.sin(t),s=i*l,f=u*c+s*Math.cos(a),h=s*o*Math.sin(a);yc.add(Math.atan2(h,f)),r=n,u=c,i=l}var t,e,r,u,i;Mc.point=function(o,a){Mc.point=n,r=(t=o)*Da,u=Math.cos(a=(e=a)*Da/2+qa/4),i=Math.sin(a)},Mc.lineEnd=function(){n(t,e)}}function pe(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function ve(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function de(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function me(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function ye(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function Me(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function xe(n){return[Math.atan2(n[1],n[0]),tt(n[2])]}function be(n,t){return ga(n[0]-t[0])<Ca&&ga(n[1]-t[1])<Ca}function _e(n,t){n*=Da;var e=Math.cos(t*=Da);we(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function we(n,t,e){++xc,_c+=(n-_c)/xc,wc+=(t-wc)/xc,Sc+=(e-Sc)/xc}function Se(){function n(n,u){n*=Da;var i=Math.cos(u*=Da),o=i*Math.cos(n),a=i*Math.sin(n),c=Math.sin(u),l=Math.atan2(Math.sqrt((l=e*c-r*a)*l+(l=r*o-t*c)*l+(l=t*a-e*o)*l),t*o+e*a+r*c);bc+=l,kc+=l*(t+(t=o)),Ec+=l*(e+(e=a)),Ac+=l*(r+(r=c)),we(t,e,r)}var t,e,r;qc.point=function(u,i){u*=Da;var o=Math.cos(i*=Da);t=o*Math.cos(u),e=o*Math.sin(u),r=Math.sin(i),qc.point=n,we(t,e,r)}}function ke(){qc.point=_e}function Ee(){function n(n,t){n*=Da;var e=Math.cos(t*=Da),o=e*Math.cos(n),a=e*Math.sin(n),c=Math.sin(t),l=u*c-i*a,s=i*o-r*c,f=r*a-u*o,h=Math.sqrt(l*l+s*s+f*f),g=r*o+u*a+i*c,p=h&&-nt(g)/h,v=Math.atan2(h,g);Nc+=p*l,Cc+=p*s,zc+=p*f,bc+=v,kc+=v*(r+(r=o)),Ec+=v*(u+(u=a)),Ac+=v*(i+(i=c)),we(r,u,i)}var t,e,r,u,i;qc.point=function(o,a){t=o,e=a,qc.point=n,o*=Da;var c=Math.cos(a*=Da);r=c*Math.cos(o),u=c*Math.sin(o),i=Math.sin(a),we(r,u,i)},qc.lineEnd=function(){n(t,e),qc.lineEnd=ke,qc.point=_e}}function Ae(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function Ne(){return!0}function Ce(n,t,e,r,u){var i=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(be(e,r)){u.lineStart();for(var a=0;t>a;++a)u.point((e=n[a])[0],e[1]);return void u.lineEnd()}var c=new qe(e,n,null,!0),l=new qe(e,null,c,!1);c.o=l,i.push(c),o.push(l),c=new qe(r,n,null,!1),l=new qe(r,null,c,!0),c.o=l,i.push(c),o.push(l)}}),o.sort(t),ze(i),ze(o),i.length){for(var a=0,c=e,l=o.length;l>a;++a)o[a].e=c=!c;for(var s,f,h=i[0];;){for(var g=h,p=!0;g.v;)if((g=g.n)===h)return;s=g.z,u.lineStart();do{if(g.v=g.o.v=!0,g.e){if(p)for(var a=0,l=s.length;l>a;++a)u.point((f=s[a])[0],f[1]);else r(g.x,g.n.x,1,u);g=g.n}else{if(p){s=g.p.z;for(var a=s.length-1;a>=0;--a)u.point((f=s[a])[0],f[1])}else r(g.x,g.p.x,-1,u);g=g.p}g=g.o,s=g.z,p=!p}while(!g.v);u.lineEnd()}}}function ze(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.n=e=n[r],e.p=u,u=e;u.n=e=n[0],e.p=u}}function qe(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Le(n,t,e,r){return function(u,i){function o(t,e){var r=u(t,e);n(t=r[0],e=r[1])&&i.point(t,e)}function a(n,t){var e=u(n,t);d.point(e[0],e[1])}function c(){y.point=a,d.lineStart()}function l(){y.point=o,d.lineEnd()}function s(n,t){v.push([n,t]);var e=u(n,t);x.point(e[0],e[1])}function f(){x.lineStart(),v=[]}function h(){s(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),p.push(v),v=null,r)if(1&t){n=e[0];var u,r=n.length-1,o=-1;if(r>0){for(b||(i.polygonStart(),b=!0),i.lineStart();++o<r;)i.point((u=n[o])[0],u[1]);i.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),g.push(e.filter(Te))}var g,p,v,d=t(i),m=u.invert(r[0],r[1]),y={point:o,lineStart:c,lineEnd:l,polygonStart:function(){y.point=s,y.lineStart=f,y.lineEnd=h,g=[],p=[]},polygonEnd:function(){y.point=o,y.lineStart=c,y.lineEnd=l,g=ta.merge(g);var n=Fe(m,p);g.length?(b||(i.polygonStart(),b=!0),Ce(g,De,n,e,i)):n&&(b||(i.polygonStart(),b=!0),i.lineStart(),e(null,null,1,i),i.lineEnd()),b&&(i.polygonEnd(),b=!1),g=p=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}},M=Re(),x=t(M),b=!1;return y}}function Te(n){return n.length>1}function Re(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function De(n,t){return((n=n.x)[0]<0?n[1]-Ra-Ca:Ra-n[1])-((t=t.x)[0]<0?t[1]-Ra-Ca:Ra-t[1])}function Pe(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,o){var a=i>0?qa:-qa,c=ga(i-e);ga(c-qa)<Ca?(n.point(e,r=(r+o)/2>0?Ra:-Ra),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(i,r),t=0):u!==a&&c>=qa&&(ga(e-u)<Ca&&(e-=u*Ca),ga(i-a)<Ca&&(i-=a*Ca),r=Ue(e,r,i,o),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=i,r=o),u=a},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function Ue(n,t,e,r){var u,i,o=Math.sin(n-e);return ga(o)>Ca?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*o)):(t+r)/2}function je(n,t,e,r){var u;if(null==n)u=e*Ra,r.point(-qa,u),r.point(0,u),r.point(qa,u),r.point(qa,0),r.point(qa,-u),r.point(0,-u),r.point(-qa,-u),r.point(-qa,0),r.point(-qa,u);else if(ga(n[0]-t[0])>Ca){var i=n[0]<t[0]?qa:-qa;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Fe(n,t){var e=n[0],r=n[1],u=[Math.sin(e),-Math.cos(e),0],i=0,o=0;yc.reset();for(var a=0,c=t.length;c>a;++a){var l=t[a],s=l.length;if(s)for(var f=l[0],h=f[0],g=f[1]/2+qa/4,p=Math.sin(g),v=Math.cos(g),d=1;;){d===s&&(d=0),n=l[d];var m=n[0],y=n[1]/2+qa/4,M=Math.sin(y),x=Math.cos(y),b=m-h,_=b>=0?1:-1,w=_*b,S=w>qa,k=p*M;if(yc.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),i+=S?b+_*La:b,S^h>=e^m>=e){var E=de(pe(f),pe(n));Me(E);var A=de(u,E);Me(A);var N=(S^b>=0?-1:1)*tt(A[2]);(r>N||r===N&&(E[0]||E[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=m,p=M,v=x,f=n}}return(-Ca>i||Ca>i&&0>yc)^1&o}function He(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,l,s;return{lineStart:function(){l=c=!1,s=1},point:function(f,h){var g,p=[f,h],v=t(f,h),d=o?v?0:u(f,h):v?u(f+(0>f?qa:-qa),h):0;if(!e&&(l=c=v)&&n.lineStart(),v!==c&&(g=r(e,p),(be(e,g)||be(p,g))&&(p[0]+=Ca,p[1]+=Ca,v=t(p[0],p[1]))),v!==c)s=0,v?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(a&&e&&o^v){var m;d&i||!(m=r(p,e,!0))||(s=0,o?(n.lineStart(),n.point(m[0][0],m[0][1]),n.point(m[1][0],m[1][1]),n.lineEnd()):(n.point(m[1][0],m[1][1]),n.lineEnd(),n.lineStart(),n.point(m[0][0],m[0][1])))}!v||e&&be(e,p)||n.point(p[0],p[1]),e=p,c=v,i=d},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return s|(l&&c)<<1}}}function r(n,t,e){var r=pe(n),u=pe(t),o=[1,0,0],a=de(r,u),c=ve(a,a),l=a[0],s=c-l*l;if(!s)return!e&&n;var f=i*c/s,h=-i*l/s,g=de(o,a),p=ye(o,f),v=ye(a,h);me(p,v);var d=g,m=ve(p,d),y=ve(d,d),M=m*m-y*(ve(p,p)-1);if(!(0>M)){var x=Math.sqrt(M),b=ye(d,(-m-x)/y);if(me(b,p),b=xe(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],E=t[1];w>S&&(_=w,w=S,S=_);var A=S-w,N=ga(A-qa)<Ca,C=N||Ca>A;if(!N&&k>E&&(_=k,k=E,E=_),C?N?k+E>0^b[1]<(ga(b[0]-w)<Ca?k:E):k<=b[1]&&b[1]<=E:A>qa^(w<=b[0]&&b[0]<=S)){var z=ye(d,(-m+x)/y);return me(z,p),[b,xe(z)]}}}function u(t,e){var r=o?n:qa-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),o=i>0,a=ga(i)>Ca,c=gr(n,6*Da);return Le(t,e,c,o?[0,-n]:[-qa,n-qa])}function Oe(n,t,e,r){return function(u){var i,o=u.a,a=u.b,c=o.x,l=o.y,s=a.x,f=a.y,h=0,g=1,p=s-c,v=f-l;if(i=n-c,p||!(i>0)){if(i/=p,0>p){if(h>i)return;g>i&&(g=i)}else if(p>0){if(i>g)return;i>h&&(h=i)}if(i=e-c,p||!(0>i)){if(i/=p,0>p){if(i>g)return;i>h&&(h=i)}else if(p>0){if(h>i)return;g>i&&(g=i)}if(i=t-l,v||!(i>0)){if(i/=v,0>v){if(h>i)return;g>i&&(g=i)}else if(v>0){if(i>g)return;i>h&&(h=i)}if(i=r-l,v||!(0>i)){if(i/=v,0>v){if(i>g)return;i>h&&(h=i)}else if(v>0){if(h>i)return;g>i&&(g=i)}return h>0&&(u.a={x:c+h*p,y:l+h*v}),1>g&&(u.b={x:c+g*p,y:l+g*v}),u}}}}}}function Ie(n,t,e,r){function u(r,u){return ga(r[0]-n)<Ca?u>0?0:3:ga(r[0]-e)<Ca?u>0?2:1:ga(r[1]-t)<Ca?u>0?1:0:u>0?3:2}function i(n,t){return o(n.x,t.x)}function o(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function c(n){for(var t=0,e=d.length,r=n[1],u=0;e>u;++u)for(var i,o=1,a=d[u],c=a.length,l=a[0];c>o;++o)i=a[o],l[1]<=r?i[1]>r&&Q(l,i,n)>0&&++t:i[1]<=r&&Q(l,i,n)<0&&--t,l=i;return 0!==t}function l(i,a,c,l){var s=0,f=0;if(null==i||(s=u(i,c))!==(f=u(a,c))||o(i,a)<0^c>0){do l.point(0===s||3===s?n:e,s>1?r:t);while((s=(s+c+4)%4)!==f)}else l.point(a[0],a[1])}function s(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function f(n,t){s(n,t)&&a.point(n,t)}function h(){C.point=p,d&&d.push(m=[]),S=!0,w=!1,b=_=0/0}function g(){v&&(p(y,M),x&&w&&A.rejoin(),v.push(A.buffer())),C.point=f,w&&a.lineEnd()}function p(n,t){n=Math.max(-Tc,Math.min(Tc,n)),t=Math.max(-Tc,Math.min(Tc,t));var e=s(n,t);if(d&&m.push([n,t]),S)y=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};N(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,m,y,M,x,b,_,w,S,k,E=a,A=Re(),N=Oe(n,t,e,r),C={point:f,lineStart:h,lineEnd:g,polygonStart:function(){a=A,v=[],d=[],k=!0},polygonEnd:function(){a=E,v=ta.merge(v);var t=c([n,r]),e=k&&t,u=v.length;(e||u)&&(a.polygonStart(),e&&(a.lineStart(),l(null,null,1,a),a.lineEnd()),u&&Ce(v,i,t,l,a),a.polygonEnd()),v=d=m=null}};return C}}function Ye(n){var t=0,e=qa/3,r=ir(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*qa/180,e=n[1]*qa/180):[t/qa*180,e/qa*180]},u}function Ze(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),o-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),o=Math.sqrt(i)/u;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/u,tt((i-(n*n+e*e)*u*u)/(2*u))]},e}function Ve(){function n(n,t){Dc+=u*n-r*t,r=n,u=t}var t,e,r,u;Hc.point=function(i,o){Hc.point=n,t=r=i,e=u=o},Hc.lineEnd=function(){n(t,e)}}function Xe(n,t){Pc>n&&(Pc=n),n>jc&&(jc=n),Uc>t&&(Uc=t),t>Fc&&(Fc=t)}function $e(){function n(n,t){o.push("M",n,",",t,i)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function u(){o.push("Z")}var i=Be(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return i=Be(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Be(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function We(n,t){_c+=n,wc+=t,++Sc}function Je(){function n(n,r){var u=n-t,i=r-e,o=Math.sqrt(u*u+i*i);kc+=o*(t+n)/2,Ec+=o*(e+r)/2,Ac+=o,We(t=n,e=r)}var t,e;Ic.point=function(r,u){Ic.point=n,We(t=r,e=u)}}function Ge(){Ic.point=We}function Ke(){function n(n,t){var e=n-r,i=t-u,o=Math.sqrt(e*e+i*i);kc+=o*(r+n)/2,Ec+=o*(u+t)/2,Ac+=o,o=u*n-r*t,Nc+=o*(r+n),Cc+=o*(u+t),zc+=3*o,We(r=n,u=t)}var t,e,r,u;Ic.point=function(i,o){Ic.point=n,We(t=r=i,e=u=o)},Ic.lineEnd=function(){n(t,e)}}function Qe(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,La)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function u(){a.point=t}function i(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:u,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=u,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function nr(n){function t(n){return(a?r:e)(n)}function e(t){return rr(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=0/0,S.point=i,t.lineStart()}function i(e,r){var i=pe([e,r]),o=n(e,r);u(M,x,y,b,_,w,M=o[0],x=o[1],y=e,b=i[0],_=i[1],w=i[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function c(){r(),S.point=l,S.lineEnd=s}function l(n,t){i(f=n,h=t),g=M,p=x,v=b,d=_,m=w,S.point=i}function s(){u(M,x,y,b,_,w,g,p,f,v,d,m,a,t),S.lineEnd=o,o()}var f,h,g,p,v,d,m,y,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=c
	},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function u(t,e,r,a,c,l,s,f,h,g,p,v,d,m){var y=s-t,M=f-e,x=y*y+M*M;if(x>4*i&&d--){var b=a+g,_=c+p,w=l+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),E=ga(ga(w)-1)<Ca||ga(r-h)<Ca?(r+h)/2:Math.atan2(_,b),A=n(E,k),N=A[0],C=A[1],z=N-t,q=C-e,L=M*z-y*q;(L*L/x>i||ga((y*z+M*q)/x-.5)>.3||o>a*g+c*p+l*v)&&(u(t,e,r,a,c,l,N,C,E,b/=S,_/=S,w,d,m),m.point(N,C),u(N,C,E,b,_,w,s,f,h,g,p,v,d,m))}}var i=.5,o=Math.cos(30*Da),a=16;return t.precision=function(n){return arguments.length?(a=(i=n*n)>0&&16,t):Math.sqrt(i)},t}function tr(n){var t=nr(function(t,e){return n([t*Pa,e*Pa])});return function(n){return or(t(n))}}function er(n){this.stream=n}function rr(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function ur(n){return ir(function(){return n})()}function ir(n){function t(n){return n=a(n[0]*Da,n[1]*Da),[n[0]*h+c,l-n[1]*h]}function e(n){return n=a.invert((n[0]-c)/h,(l-n[1])/h),n&&[n[0]*Pa,n[1]*Pa]}function r(){a=Ae(o=lr(m,M,x),i);var n=i(v,d);return c=g-n[0]*h,l=p+n[1]*h,u()}function u(){return s&&(s.valid=!1,s=null),t}var i,o,a,c,l,s,f=nr(function(n,t){return n=i(n,t),[n[0]*h+c,l-n[1]*h]}),h=150,g=480,p=250,v=0,d=0,m=0,M=0,x=0,b=Lc,_=y,w=null,S=null;return t.stream=function(n){return s&&(s.valid=!1),s=or(b(o,f(_(n)))),s.valid=!0,s},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Lc):He((w=+n)*Da),u()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Ie(n[0][0],n[0][1],n[1][0],n[1][1]):y,u()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(g=+n[0],p=+n[1],r()):[g,p]},t.center=function(n){return arguments.length?(v=n[0]%360*Da,d=n[1]%360*Da,r()):[v*Pa,d*Pa]},t.rotate=function(n){return arguments.length?(m=n[0]%360*Da,M=n[1]%360*Da,x=n.length>2?n[2]%360*Da:0,r()):[m*Pa,M*Pa,x*Pa]},ta.rebind(t,f,"precision"),function(){return i=n.apply(this,arguments),t.invert=i.invert&&e,r()}}function or(n){return rr(n,function(t,e){n.point(t*Da,e*Da)})}function ar(n,t){return[n,t]}function cr(n,t){return[n>qa?n-La:-qa>n?n+La:n,t]}function lr(n,t,e){return n?t||e?Ae(fr(n),hr(t,e)):fr(n):t||e?hr(t,e):cr}function sr(n){return function(t,e){return t+=n,[t>qa?t-La:-qa>t?t+La:t,e]}}function fr(n){var t=sr(n);return t.invert=sr(-n),t}function hr(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),s=l*r+a*u;return[Math.atan2(c*i-s*o,a*r-l*u),tt(s*i+c*o)]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,l=Math.sin(t),s=l*i-c*o;return[Math.atan2(c*i+l*o,a*r+s*u),tt(s*r-a*u)]},e}function gr(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,o,a){var c=o*t;null!=u?(u=pr(e,u),i=pr(e,i),(o>0?i>u:u>i)&&(u+=o*La)):(u=n+o*La,i=n-.5*c);for(var l,s=u;o>0?s>i:i>s;s-=c)a.point((l=xe([e,-r*Math.cos(s),-r*Math.sin(s)]))[0],l[1])}}function pr(n,t){var e=pe(t);e[0]-=n,Me(e);var r=nt(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Ca)%(2*Math.PI)}function vr(n,t,e){var r=ta.range(n,t-Ca,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function dr(n,t,e){var r=ta.range(n,t-Ca,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function mr(n){return n.source}function yr(n){return n.target}function Mr(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),o=Math.cos(r),a=Math.sin(r),c=u*Math.cos(n),l=u*Math.sin(n),s=o*Math.cos(e),f=o*Math.sin(e),h=2*Math.asin(Math.sqrt(it(r-t)+u*o*it(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*s,u=e*l+t*f,o=e*i+t*a;return[Math.atan2(u,r)*Pa,Math.atan2(o,Math.sqrt(r*r+u*u))*Pa]}:function(){return[n*Pa,t*Pa]};return p.distance=h,p}function xr(){function n(n,u){var i=Math.sin(u*=Da),o=Math.cos(u),a=ga((n*=Da)-t),c=Math.cos(a);Yc+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*i-e*o*c)*a),e*i+r*o*c),t=n,e=i,r=o}var t,e,r;Zc.point=function(u,i){t=u*Da,e=Math.sin(i*=Da),r=Math.cos(i),Zc.point=n},Zc.lineEnd=function(){Zc.point=Zc.lineEnd=b}}function br(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),o=Math.cos(u);return[Math.atan2(n*i,r*o),Math.asin(r&&e*i/r)]},e}function _r(n,t){function e(n,t){o>0?-Ra+Ca>t&&(t=-Ra+Ca):t>Ra-Ca&&(t=Ra-Ca);var e=o/Math.pow(u(t),i);return[e*Math.sin(i*n),o-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(qa/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),o=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=o-t,r=K(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(o/r,1/i))-Ra]},e):Sr}function wr(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return ga(u)<Ca?ar:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-K(u)*Math.sqrt(n*n+e*e)]},e)}function Sr(n,t){return[n,Math.log(Math.tan(qa/4+t/2))]}function kr(n){var t,e=ur(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=i.apply(e,arguments);if(o===e){if(t=null==n){var a=qa*r(),c=u();i([[c[0]-a,c[1]-a],[c[0]+a,c[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Er(n,t){return[Math.log(Math.tan(qa/4+t/2)),-n]}function Ar(n){return n[0]}function Nr(n){return n[1]}function Cr(n){for(var t=n.length,e=[0,1],r=2,u=2;t>u;u++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[u])<=0;)--r;e[r++]=u}return e.slice(0,r)}function zr(n,t){return n[0]-t[0]||n[1]-t[1]}function qr(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Lr(n,t,e,r){var u=n[0],i=e[0],o=t[0]-u,a=r[0]-i,c=n[1],l=e[1],s=t[1]-c,f=r[1]-l,h=(a*(c-l)-f*(u-i))/(f*o-a*s);return[u+h*o,c+h*s]}function Tr(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Rr(){tu(this),this.edge=this.site=this.circle=null}function Dr(n){var t=el.pop()||new Rr;return t.site=n,t}function Pr(n){Xr(n),Qc.remove(n),el.push(n),tu(n)}function Ur(n){var t=n.circle,e=t.x,r=t.cy,u={x:e,y:r},i=n.P,o=n.N,a=[n];Pr(n);for(var c=i;c.circle&&ga(e-c.circle.x)<Ca&&ga(r-c.circle.cy)<Ca;)i=c.P,a.unshift(c),Pr(c),c=i;a.unshift(c),Xr(c);for(var l=o;l.circle&&ga(e-l.circle.x)<Ca&&ga(r-l.circle.cy)<Ca;)o=l.N,a.push(l),Pr(l),l=o;a.push(l),Xr(l);var s,f=a.length;for(s=1;f>s;++s)l=a[s],c=a[s-1],Kr(l.edge,c.site,l.site,u);c=a[0],l=a[f-1],l.edge=Jr(c.site,l.site,null,u),Vr(c),Vr(l)}function jr(n){for(var t,e,r,u,i=n.x,o=n.y,a=Qc._;a;)if(r=Fr(a,o)-i,r>Ca)a=a.L;else{if(u=i-Hr(a,o),!(u>Ca)){r>-Ca?(t=a.P,e=a):u>-Ca?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var c=Dr(n);if(Qc.insert(t,c),t||e){if(t===e)return Xr(t),e=Dr(t.site),Qc.insert(c,e),c.edge=e.edge=Jr(t.site,c.site),Vr(t),void Vr(e);if(!e)return void(c.edge=Jr(t.site,c.site));Xr(t),Xr(e);var l=t.site,s=l.x,f=l.y,h=n.x-s,g=n.y-f,p=e.site,v=p.x-s,d=p.y-f,m=2*(h*d-g*v),y=h*h+g*g,M=v*v+d*d,x={x:(d*y-g*M)/m+s,y:(h*M-v*y)/m+f};Kr(e.edge,l,p,x),c.edge=Jr(l,n,null,x),e.edge=Jr(n,p,null,x),Vr(t),Vr(e)}}function Fr(n,t){var e=n.site,r=e.x,u=e.y,i=u-t;if(!i)return r;var o=n.P;if(!o)return-1/0;e=o.site;var a=e.x,c=e.y,l=c-t;if(!l)return a;var s=a-r,f=1/i-1/l,h=s/l;return f?(-h+Math.sqrt(h*h-2*f*(s*s/(-2*l)-c+l/2+u-i/2)))/f+r:(r+a)/2}function Hr(n,t){var e=n.N;if(e)return Fr(e,t);var r=n.site;return r.y===t?r.x:1/0}function Or(n){this.site=n,this.edges=[]}function Ir(n){for(var t,e,r,u,i,o,a,c,l,s,f=n[0][0],h=n[1][0],g=n[0][1],p=n[1][1],v=Kc,d=v.length;d--;)if(i=v[d],i&&i.prepare())for(a=i.edges,c=a.length,o=0;c>o;)s=a[o].end(),r=s.x,u=s.y,l=a[++o%c].start(),t=l.x,e=l.y,(ga(r-t)>Ca||ga(u-e)>Ca)&&(a.splice(o,0,new Qr(Gr(i.site,s,ga(r-f)<Ca&&p-u>Ca?{x:f,y:ga(t-f)<Ca?e:p}:ga(u-p)<Ca&&h-r>Ca?{x:ga(e-p)<Ca?t:h,y:p}:ga(r-h)<Ca&&u-g>Ca?{x:h,y:ga(t-h)<Ca?e:g}:ga(u-g)<Ca&&r-f>Ca?{x:ga(e-g)<Ca?t:f,y:g}:null),i.site,null)),++c)}function Yr(n,t){return t.angle-n.angle}function Zr(){tu(this),this.x=this.y=this.arc=this.site=this.cy=null}function Vr(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,u=n.site,i=e.site;if(r!==i){var o=u.x,a=u.y,c=r.x-o,l=r.y-a,s=i.x-o,f=i.y-a,h=2*(c*f-l*s);if(!(h>=-za)){var g=c*c+l*l,p=s*s+f*f,v=(f*g-l*p)/h,d=(c*p-s*g)/h,f=d+a,m=rl.pop()||new Zr;m.arc=n,m.site=u,m.x=v+o,m.y=f+Math.sqrt(v*v+d*d),m.cy=f,n.circle=m;for(var y=null,M=tl._;M;)if(m.y<M.y||m.y===M.y&&m.x<=M.x){if(!M.L){y=M.P;break}M=M.L}else{if(!M.R){y=M;break}M=M.R}tl.insert(y,m),y||(nl=m)}}}}function Xr(n){var t=n.circle;t&&(t.P||(nl=t.N),tl.remove(t),rl.push(t),tu(t),n.circle=null)}function $r(n){for(var t,e=Gc,r=Oe(n[0][0],n[0][1],n[1][0],n[1][1]),u=e.length;u--;)t=e[u],(!Br(t,n)||!r(t)||ga(t.a.x-t.b.x)<Ca&&ga(t.a.y-t.b.y)<Ca)&&(t.a=t.b=null,e.splice(u,1))}function Br(n,t){var e=n.b;if(e)return!0;var r,u,i=n.a,o=t[0][0],a=t[1][0],c=t[0][1],l=t[1][1],s=n.l,f=n.r,h=s.x,g=s.y,p=f.x,v=f.y,d=(h+p)/2,m=(g+v)/2;if(v===g){if(o>d||d>=a)return;if(h>p){if(i){if(i.y>=l)return}else i={x:d,y:c};e={x:d,y:l}}else{if(i){if(i.y<c)return}else i={x:d,y:l};e={x:d,y:c}}}else if(r=(h-p)/(v-g),u=m-r*d,-1>r||r>1)if(h>p){if(i){if(i.y>=l)return}else i={x:(c-u)/r,y:c};e={x:(l-u)/r,y:l}}else{if(i){if(i.y<c)return}else i={x:(l-u)/r,y:l};e={x:(c-u)/r,y:c}}else if(v>g){if(i){if(i.x>=a)return}else i={x:o,y:r*o+u};e={x:a,y:r*a+u}}else{if(i){if(i.x<o)return}else i={x:a,y:r*a+u};e={x:o,y:r*o+u}}return n.a=i,n.b=e,!0}function Wr(n,t){this.l=n,this.r=t,this.a=this.b=null}function Jr(n,t,e,r){var u=new Wr(n,t);return Gc.push(u),e&&Kr(u,n,t,e),r&&Kr(u,t,n,r),Kc[n.i].edges.push(new Qr(u,n,t)),Kc[t.i].edges.push(new Qr(u,t,n)),u}function Gr(n,t,e){var r=new Wr(n,null);return r.a=t,r.b=e,Gc.push(r),r}function Kr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function Qr(n,t,e){var r=n.a,u=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(u.x-r.x,r.y-u.y):Math.atan2(r.x-u.x,u.y-r.y)}function nu(){this._=null}function tu(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function eu(n,t){var e=t,r=t.R,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ru(n,t){var e=t,r=t.L,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function uu(n){for(;n.L;)n=n.L;return n}function iu(n,t){var e,r,u,i=n.sort(ou).pop();for(Gc=[],Kc=new Array(n.length),Qc=new nu,tl=new nu;;)if(u=nl,i&&(!u||i.y<u.y||i.y===u.y&&i.x<u.x))(i.x!==e||i.y!==r)&&(Kc[i.i]=new Or(i),jr(i),e=i.x,r=i.y),i=n.pop();else{if(!u)break;Ur(u.arc)}t&&($r(t),Ir(t));var o={cells:Kc,edges:Gc};return Qc=tl=Gc=Kc=null,o}function ou(n,t){return t.y-n.y||t.x-n.x}function au(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function cu(n){return n.x}function lu(n){return n.y}function su(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function fu(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var o=.5*(e+u),a=.5*(r+i),c=t.nodes;c[0]&&fu(n,c[0],e,r,o,a),c[1]&&fu(n,c[1],o,r,u,a),c[2]&&fu(n,c[2],e,a,o,i),c[3]&&fu(n,c[3],o,a,u,i)}}function hu(n,t,e,r,u,i,o){var a,c=1/0;return function l(n,s,f,h,g){if(!(s>i||f>o||r>h||u>g)){if(p=n.point){var p,v=t-n.x,d=e-n.y,m=v*v+d*d;if(c>m){var y=Math.sqrt(c=m);r=t-y,u=e-y,i=t+y,o=e+y,a=p}}for(var M=n.nodes,x=.5*(s+h),b=.5*(f+g),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:l(n,s,f,x,b);break;case 1:l(n,x,f,h,b);break;case 2:l(n,s,b,x,g);break;case 3:l(n,x,b,h,g)}}}(n,r,u,i,o),a}function gu(n,t){n=ta.rgb(n),t=ta.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,o=t.g-r,a=t.b-u;return function(n){return"#"+xt(Math.round(e+i*n))+xt(Math.round(r+o*n))+xt(Math.round(u+a*n))}}function pu(n,t){var e,r={},u={};for(e in n)e in t?r[e]=mu(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function vu(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function du(n,t){var e,r,u,i=il.lastIndex=ol.lastIndex=0,o=-1,a=[],c=[];for(n+="",t+="";(e=il.exec(n))&&(r=ol.exec(t));)(u=r.index)>i&&(u=t.slice(i,u),a[o]?a[o]+=u:a[++o]=u),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,c.push({i:o,x:vu(e,r)})),i=ol.lastIndex;return i<t.length&&(u=t.slice(i),a[o]?a[o]+=u:a[++o]=u),a.length<2?c[0]?(t=c[0].x,function(n){return t(n)+""}):function(){return t}:(t=c.length,function(n){for(var e,r=0;t>r;++r)a[(e=c[r]).i]=e.x(n);return a.join("")})}function mu(n,t){for(var e,r=ta.interpolators.length;--r>=0&&!(e=ta.interpolators[r](n,t)););return e}function yu(n,t){var e,r=[],u=[],i=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(mu(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;o>e;++e)u[e]=t[e];return function(n){for(e=0;a>e;++e)u[e]=r[e](n);return u}}function Mu(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function xu(n){return function(t){return 1-n(1-t)}}function bu(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function _u(n){return n*n}function wu(n){return n*n*n}function Su(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function ku(n){return function(t){return Math.pow(t,n)}}function Eu(n){return 1-Math.cos(n*Ra)}function Au(n){return Math.pow(2,10*(n-1))}function Nu(n){return 1-Math.sqrt(1-n*n)}function Cu(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/La*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*La/t)}}function zu(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function qu(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Lu(n,t){n=ta.hcl(n),t=ta.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,o=t.c-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return st(e+i*n,r+o*n,u+a*n)+""}}function Tu(n,t){n=ta.hsl(n),t=ta.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,o=t.s-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return ct(e+i*n,r+o*n,u+a*n)+""}}function Ru(n,t){n=ta.lab(n),t=ta.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,o=t.a-r,a=t.b-u;return function(n){return ht(e+i*n,r+o*n,u+a*n)+""}}function Du(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Pu(n){var t=[n.a,n.b],e=[n.c,n.d],r=ju(t),u=Uu(t,e),i=ju(Fu(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Pa,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*Pa:0}function Uu(n,t){return n[0]*t[0]+n[1]*t[1]}function ju(n){var t=Math.sqrt(Uu(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Fu(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Hu(n,t){var e,r=[],u=[],i=ta.transform(n),o=ta.transform(t),a=i.translate,c=o.translate,l=i.rotate,s=o.rotate,f=i.skew,h=o.skew,g=i.scale,p=o.scale;return a[0]!=c[0]||a[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:vu(a[0],c[0])},{i:3,x:vu(a[1],c[1])})):r.push(c[0]||c[1]?"translate("+c+")":""),l!=s?(l-s>180?s+=360:s-l>180&&(l+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:vu(l,s)})):s&&r.push(r.pop()+"rotate("+s+")"),f!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:vu(f,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:vu(g[0],p[0])},{i:e-2,x:vu(g[1],p[1])})):(1!=p[0]||1!=p[1])&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function Ou(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Iu(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Yu(n){for(var t=n.source,e=n.target,r=Vu(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function Zu(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Vu(n,t){if(n===t)return n;for(var e=Zu(n),r=Zu(t),u=e.pop(),i=r.pop(),o=null;u===i;)o=u,u=e.pop(),i=r.pop();return o}function Xu(n){n.fixed|=2}function $u(n){n.fixed&=-7}function Bu(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Wu(n){n.fixed&=-5}function Ju(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,o=n.nodes,a=o.length,c=-1;++c<a;)i=o[c],null!=i&&(Ju(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var l=t*e[n.point.index];n.charge+=n.pointCharge=l,r+=l*n.point.x,u+=l*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Gu(n,t){return ta.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=ri,n}function Ku(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(u=n.children)&&(r=u.length))for(var r,u;--r>=0;)e.push(u[r])}function Qu(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(i=n.children)&&(u=i.length))for(var u,i,o=-1;++o<u;)e.push(i[o]);for(;null!=(n=r.pop());)t(n)}function ni(n){return n.children}function ti(n){return n.value}function ei(n,t){return t.value-n.value}function ri(n){return ta.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function ui(n){return n.x}function ii(n){return n.y}function oi(n,t,e){n.y0=t,n.y=e}function ai(n){return ta.range(n.length)}function ci(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function li(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function si(n){return n.reduce(fi,0)}function fi(n,t){return n+t[1]}function hi(n,t){return gi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function gi(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function pi(n){return[ta.min(n),ta.max(n)]}function vi(n,t){return n.value-t.value}function di(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function mi(n,t){n._pack_next=t,t._pack_prev=n}function yi(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return.999*u*u>e*e+r*r}function Mi(n){function t(n){s=Math.min(n.x-n.r,s),f=Math.max(n.x+n.r,f),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(l=e.length)){var e,r,u,i,o,a,c,l,s=1/0,f=-1/0,h=1/0,g=-1/0;if(e.forEach(xi),r=e[0],r.x=-r.r,r.y=0,t(r),l>1&&(u=e[1],u.x=u.r,u.y=0,t(u),l>2))for(i=e[2],wi(r,u,i),t(i),di(r,i),r._pack_prev=i,di(i,u),u=r._pack_next,o=3;l>o;o++){wi(r,u,i=e[o]);var p=0,v=1,d=1;for(a=u._pack_next;a!==u;a=a._pack_next,v++)if(yi(a,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==a._pack_prev&&!yi(c,i);c=c._pack_prev,d++);p?(d>v||v==d&&u.r<r.r?mi(r,u=a):mi(r=c,u),o--):(di(r,i),u=i,t(i))}var m=(s+f)/2,y=(h+g)/2,M=0;for(o=0;l>o;o++)i=e[o],i.x-=m,i.y-=y,M=Math.max(M,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=M,e.forEach(bi)}}function xi(n){n._pack_next=n._pack_prev=n}function bi(n){delete n._pack_next,delete n._pack_prev}function _i(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,o=u.length;++i<o;)_i(u[i],t,e,r)}function wi(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var o=t.r+e.r,a=u*u+i*i;o*=o,r*=r;var c=.5+(r-o)/(2*a),l=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+c*u+l*i,e.y=n.y+c*i-l*u}else e.x=n.x+r,e.y=n.y}function Si(n,t){return n.parent==t.parent?1:2}function ki(n){var t=n.children;return t.length?t[0]:n.t}function Ei(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ai(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Ni(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Ci(n,t,e){return n.a.parent===t.parent?n.a:e}function zi(n){return 1+ta.max(n,function(n){return n.y})}function qi(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Li(n){var t=n.children;return t&&t.length?Li(t[0]):n}function Ti(n){var t,e=n.children;return e&&(t=e.length)?Ti(e[t-1]):n}function Ri(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Di(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function Pi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ui(n){return n.rangeExtent?n.rangeExtent():Pi(n.range())}function ji(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Fi(n,t){var e,r=0,u=n.length-1,i=n[r],o=n[u];return i>o&&(e=r,r=u,u=e,e=i,i=o,o=e),n[r]=t.floor(i),n[u]=t.ceil(o),n}function Hi(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:ml}function Oi(n,t,e,r){var u=[],i=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)u.push(e(n[o-1],n[o])),i.push(r(t[o-1],t[o]));return function(t){var e=ta.bisect(n,t,1,a)-1;return i[e](u[e](t))}}function Ii(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?Oi:ji,c=r?Iu:Ou;return o=u(n,t,c,e),a=u(t,n,c,mu),i}function i(n){return o(n)}var o,a;return i.invert=function(n){return a(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Du)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Xi(n,t)},i.tickFormat=function(t,e){return $i(n,t,e)},i.nice=function(t){return Zi(n,t),u()},i.copy=function(){return Ii(n,t,e,r)},u()}function Yi(n,t){return ta.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Zi(n,t){return Fi(n,Hi(Vi(n,t)[2]))}function Vi(n,t){null==t&&(t=10);var e=Pi(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Xi(n,t){return ta.range.apply(ta,Vi(n,t))}function $i(n,t,e){var r=Vi(n,t);if(e){var u=ic.exec(e);if(u.shift(),"s"===u[8]){var i=ta.formatPrefix(Math.max(ga(r[0]),ga(r[1])));return u[7]||(u[7]="."+Bi(i.scale(r[2]))),u[8]="f",e=ta.format(u.join("")),function(n){return e(i.scale(n))+i.symbol}}u[7]||(u[7]="."+Wi(u[8],r)),e=u.join("")}else e=",."+Bi(r[2])+"f";return ta.format(e)}function Bi(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function Wi(n,t){var e=Bi(t[2]);return n in yl?Math.abs(e-Bi(Math.max(ga(t[0]),ga(t[1]))))+ +("e"!==n):e-2*("%"===n)}function Ji(n,t,e,r){function u(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function i(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(u(t))}return o.invert=function(t){return i(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(u)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(u)),o):t},o.nice=function(){var t=Fi(r.map(u),e?Math:xl);return n.domain(t),r=t.map(i),o},o.ticks=function(){var n=Pi(r),o=[],a=n[0],c=n[1],l=Math.floor(u(a)),s=Math.ceil(u(c)),f=t%1?2:t;if(isFinite(s-l)){if(e){for(;s>l;l++)for(var h=1;f>h;h++)o.push(i(l)*h);o.push(i(l))}else for(o.push(i(l));l++<s;)for(var h=f-1;h>0;h--)o.push(i(l)*h);for(l=0;o[l]<a;l++);for(s=o.length;o[s-1]>c;s--);o=o.slice(l,s)}return o},o.tickFormat=function(n,t){if(!arguments.length)return Ml;arguments.length<2?t=Ml:"function"!=typeof t&&(t=ta.format(t));var r,a=Math.max(.1,n/o.ticks().length),c=e?(r=1e-12,Math.ceil):(r=-1e-12,Math.floor);return function(n){return n/i(c(u(n)+r))<=a?t(n):""}},o.copy=function(){return Ji(n.copy(),t,e,r)},Yi(o,n)}function Gi(n,t,e){function r(t){return n(u(t))}var u=Ki(t),i=Ki(1/t);return r.invert=function(t){return i(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(u)),r):e},r.ticks=function(n){return Xi(e,n)},r.tickFormat=function(n,t){return $i(e,n,t)},r.nice=function(n){return r.domain(Zi(e,n))},r.exponent=function(o){return arguments.length?(u=Ki(t=o),i=Ki(1/t),n.domain(e.map(u)),r):t},r.copy=function(){return Gi(n.copy(),t,e)},Yi(r,n)}function Ki(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Qi(n,t){function e(e){return i[((u.get(e)||("range"===t.t?u.set(e,n.push(e)):0/0))-1)%i.length]}function r(t,e){return ta.range(n.length).map(function(n){return t+e*n})}var u,i,o;return e.domain=function(r){if(!arguments.length)return n;n=[],u=new l;for(var i,o=-1,a=r.length;++o<a;)u.has(i=r[o])||u.set(i,n.push(i));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(i=n,o=0,t={t:"range",a:arguments},e):i},e.rangePoints=function(u,a){arguments.length<2&&(a=0);var c=u[0],l=u[1],s=n.length<2?(c=(c+l)/2,0):(l-c)/(n.length-1+a);return i=r(c+s*a/2,s),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(u,a){arguments.length<2&&(a=0);var c=u[0],l=u[1],s=n.length<2?(c=l=Math.round((c+l)/2),0):(l-c)/(n.length-1+a)|0;return i=r(c+Math.round(s*a/2+(l-c-(n.length-1+a)*s)/2),s),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(u,a,c){arguments.length<2&&(a=0),arguments.length<3&&(c=a);var l=u[1]<u[0],s=u[l-0],f=u[1-l],h=(f-s)/(n.length-a+2*c);return i=r(s+h*c,h),l&&i.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,a,c){arguments.length<2&&(a=0),arguments.length<3&&(c=a);var l=u[1]<u[0],s=u[l-0],f=u[1-l],h=Math.floor((f-s)/(n.length-a+2*c));return i=r(s+Math.round((f-s-(n.length-a)*h)/2),h),l&&i.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Pi(t.a[0])},e.copy=function(){return Qi(n,t)},e.domain(n)}function no(n,t){function i(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ta.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ta.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(u).sort(e),i()):n},o.range=function(n){return arguments.length?(t=n,i()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[0/0,0/0]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return no(n,t)},i()}function to(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),o=e.length-1,r}var i,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?0/0:t/i+n,[t,t+1/i]},r.copy=function(){return to(n,t,e)},u()}function eo(n,t){function e(e){return e>=e?t[ta.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return eo(n,t)},e}function ro(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Xi(n,t)},t.tickFormat=function(t,e){return $i(n,t,e)},t.copy=function(){return ro(n)},t}function uo(){return 0}function io(n){return n.innerRadius}function oo(n){return n.outerRadius}function ao(n){return n.startAngle}function co(n){return n.endAngle}function lo(n){return n&&n.padAngle}function so(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function fo(n,t,e,r,u){var i=n[0]-t[0],o=n[1]-t[1],a=(u?r:-r)/Math.sqrt(i*i+o*o),c=a*o,l=-a*i,s=n[0]+c,f=n[1]+l,h=t[0]+c,g=t[1]+l,p=(s+h)/2,v=(f+g)/2,d=h-s,m=g-f,y=d*d+m*m,M=e-r,x=s*g-h*f,b=(0>m?-1:1)*Math.sqrt(M*M*y-x*x),_=(x*m-d*b)/y,w=(-x*d-m*b)/y,S=(x*m+d*b)/y,k=(-x*d+m*b)/y,E=_-p,A=w-v,N=S-p,C=k-v;return E*E+A*A>N*N+C*C&&(_=S,w=k),[[_-c,w-l],[_*e/M,w*e/M]]}function ho(n){function t(t){function o(){l.push("M",i(n(s),a))}for(var c,l=[],s=[],f=-1,h=t.length,g=Et(e),p=Et(r);++f<h;)u.call(this,c=t[f],f)?s.push([+g.call(this,c,f),+p.call(this,c,f)]):s.length&&(o(),s=[]);return s.length&&o(),l.length?l.join(""):null}var e=Ar,r=Nr,u=Ne,i=go,o=i.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?i=n:(i=El.get(n)||go).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function go(n){return n.join("L")}function po(n){return go(n)+"Z"}function vo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&u.push("H",r[0]),u.join("")}function mo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function yo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function Mo(n,t){return n.length<4?go(n):n[1]+_o(n.slice(1,-1),wo(n,t))}function xo(n,t){return n.length<3?go(n):n[0]+_o((n.push(n[0]),n),wo([n[n.length-2]].concat(n,[n[1]]),t))}function bo(n,t){return n.length<3?go(n):n[0]+_o(n,wo(n,t))}function _o(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return go(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],o=t[0],a=o,c=1;if(e&&(r+="Q"+(i[0]-2*o[0]/3)+","+(i[1]-2*o[1]/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){a=t[1],i=n[c],c++,r+="C"+(u[0]+o[0])+","+(u[1]+o[1])+","+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1];for(var l=2;l<t.length;l++,c++)i=n[c],a=t[l],r+="S"+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1]}if(e){var s=n[c];r+="Q"+(i[0]+2*a[0]/3)+","+(i[1]+2*a[1]/3)+","+s[0]+","+s[1]}return r}function wo(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],o=n[1],a=1,c=n.length;++a<c;)e=i,i=o,o=n[a],r.push([u*(o[0]-e[0]),u*(o[1]-e[1])]);return r}function So(n){if(n.length<3)return go(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],o=[u,u,u,(r=n[1])[0]],a=[i,i,i,r[1]],c=[u,",",i,"L",No(Cl,o),",",No(Cl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Co(c,o,a);return n.pop(),c.push("L",r),c.join("")}function ko(n){if(n.length<4)return go(n);for(var t,e=[],r=-1,u=n.length,i=[0],o=[0];++r<3;)t=n[r],i.push(t[0]),o.push(t[1]);for(e.push(No(Cl,i)+","+No(Cl,o)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),o.shift(),o.push(t[1]),Co(e,i,o);return e.join("")}function Eo(n){for(var t,e,r=-1,u=n.length,i=u+4,o=[],a=[];++r<4;)e=n[r%u],o.push(e[0]),a.push(e[1]);for(t=[No(Cl,o),",",No(Cl,a)],--r;++r<i;)e=n[r%u],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Co(t,o,a);return t.join("")}function Ao(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],o=n[0][1],a=n[e][0]-i,c=n[e][1]-o,l=-1;++l<=e;)r=n[l],u=l/e,r[0]=t*r[0]+(1-t)*(i+u*a),r[1]=t*r[1]+(1-t)*(o+u*c);return So(n)}function No(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Co(n,t,e){n.push("C",No(Al,t),",",No(Al,e),",",No(Nl,t),",",No(Nl,e),",",No(Cl,t),",",No(Cl,e))}function zo(n,t){return(t[1]-n[1])/(t[0]-n[0])}function qo(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],o=r[0]=zo(u,i);++t<e;)r[t]=(o+(o=zo(u=i,i=n[t+1])))/2;return r[t]=o,r}function Lo(n){for(var t,e,r,u,i=[],o=qo(n),a=-1,c=n.length-1;++a<c;)t=zo(n[a],n[a+1]),ga(t)<Ca?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),o[a]=u*e,o[a+1]=u*r));for(a=-1;++a<=c;)u=(n[Math.min(c,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),i.push([u||0,o[a]*u||0]);return i}function To(n){return n.length<3?go(n):n[0]+_o(n,Lo(n))}function Ro(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]-Ra,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Do(n){function t(t){function c(){v.push("M",a(n(m),f),s,l(n(d.reverse()),f),"Z")}for(var h,g,p,v=[],d=[],m=[],y=-1,M=t.length,x=Et(e),b=Et(u),_=e===r?function(){return g}:Et(r),w=u===i?function(){return p}:Et(i);++y<M;)o.call(this,h=t[y],y)?(d.push([g=+x.call(this,h,y),p=+b.call(this,h,y)]),m.push([+_.call(this,h,y),+w.call(this,h,y)])):d.length&&(c(),d=[],m=[]);return d.length&&c(),v.length?v.join(""):null}var e=Ar,r=Ar,u=0,i=Nr,o=Ne,a=go,c=a.key,l=a,s="L",f=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r
	},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?a=n:(a=El.get(n)||go).key,l=a.reverse||a,s=a.closed?"M":"L",t):c},t.tension=function(n){return arguments.length?(f=n,t):f},t}function Po(n){return n.radius}function Uo(n){return[n.x,n.y]}function jo(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Ra;return[e*Math.cos(r),e*Math.sin(r)]}}function Fo(){return 64}function Ho(){return"circle"}function Oo(n){var t=Math.sqrt(n/qa);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Io(n){return function(){var t,e;(t=this[n])&&(e=t[t.active])&&(--t.count?delete t[t.active]:delete this[n],t.active+=.5,e.event&&e.event.interrupt.call(this,this.__data__,e.index))}}function Yo(n,t,e){return ya(n,Pl),n.namespace=t,n.id=e,n}function Zo(n,t,e,r){var u=n.id,i=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[i][u].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[i][u].tween.set(t,e)}))}function Vo(n){return null==n&&(n=""),function(){this.textContent=n}}function Xo(n){return null==n?"__transition__":"__transition_"+n+"__"}function $o(n,t,e,r,u){var i=n[e]||(n[e]={active:0,count:0}),o=i[r];if(!o){var a=u.time;o=i[r]={tween:new l,time:a,delay:u.delay,duration:u.duration,ease:u.ease,index:t},u=null,++i.count,ta.timer(function(u){function c(e){if(i.active>r)return s();var u=i[i.active];u&&(--i.count,delete i[i.active],u.event&&u.event.interrupt.call(n,n.__data__,u.index)),i.active=r,o.event&&o.event.start.call(n,n.__data__,t),o.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&v.push(r)}),h=o.ease,f=o.duration,ta.timer(function(){return p.c=l(e||1)?Ne:l,1},0,a)}function l(e){if(i.active!==r)return 1;for(var u=e/f,a=h(u),c=v.length;c>0;)v[--c].call(n,a);return u>=1?(o.event&&o.event.end.call(n,n.__data__,t),s()):void 0}function s(){return--i.count?delete i[r]:delete n[e],1}var f,h,g=o.delay,p=ec,v=[];return p.t=g+a,u>=g?c(u-g):void(p.c=c)},0,a)}}function Bo(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function Wo(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function Jo(n){return n.toISOString()}function Go(n,t,e){function r(t){return n(t)}function u(n,e){var r=n[1]-n[0],u=r/e,i=ta.bisect(Vl,u);return i==Vl.length?[t.year,Vi(n.map(function(n){return n/31536e6}),e)[2]]:i?t[u/Vl[i-1]<Vl[i]/u?i-1:i]:[Bl,Vi(n,e)[2]]}return r.invert=function(t){return Ko(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Ko)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,Ko(+e+1),t).length}var i=r.domain(),o=Pi(i),a=null==n?u(o,10):"number"==typeof n&&u(o,n);return a&&(n=a[0],t=a[1]),r.domain(Fi(i,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=Ko(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=Ko(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Pi(r.domain()),i=null==n?u(e,10):"number"==typeof n?u(e,n):!n.range&&[{range:n},t];return i&&(n=i[0],t=i[1]),n.range(e[0],Ko(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return Go(n.copy(),t,e)},Yi(r,n)}function Ko(n){return new Date(n)}function Qo(n){return JSON.parse(n.responseText)}function na(n){var t=ua.createRange();return t.selectNode(ua.body),t.createContextualFragment(n.responseText)}var ta={version:"3.5.5"},ea=[].slice,ra=function(n){return ea.call(n)},ua=this.document;if(ua)try{ra(ua.documentElement.childNodes)[0].nodeType}catch(ia){ra=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),ua)try{ua.createElement("DIV").style.setProperty("opacity",0,"")}catch(oa){var aa=this.Element.prototype,ca=aa.setAttribute,la=aa.setAttributeNS,sa=this.CSSStyleDeclaration.prototype,fa=sa.setProperty;aa.setAttribute=function(n,t){ca.call(this,n,t+"")},aa.setAttributeNS=function(n,t,e){la.call(this,n,t,e+"")},sa.setProperty=function(n,t,e){fa.call(this,n,t+"",e)}}ta.ascending=e,ta.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},ta.min=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i;)if(null!=(r=n[u])&&r>=r){e=r;break}for(;++u<i;)null!=(r=n[u])&&e>r&&(e=r)}else{for(;++u<i;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=r;break}for(;++u<i;)null!=(r=t.call(n,n[u],u))&&e>r&&(e=r)}return e},ta.max=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i;)if(null!=(r=n[u])&&r>=r){e=r;break}for(;++u<i;)null!=(r=n[u])&&r>e&&(e=r)}else{for(;++u<i;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=r;break}for(;++u<i;)null!=(r=t.call(n,n[u],u))&&r>e&&(e=r)}return e},ta.extent=function(n,t){var e,r,u,i=-1,o=n.length;if(1===arguments.length){for(;++i<o;)if(null!=(r=n[i])&&r>=r){e=u=r;break}for(;++i<o;)null!=(r=n[i])&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<o;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=u=r;break}for(;++i<o;)null!=(r=t.call(n,n[i],i))&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},ta.sum=function(n,t){var e,r=0,i=n.length,o=-1;if(1===arguments.length)for(;++o<i;)u(e=+n[o])&&(r+=e);else for(;++o<i;)u(e=+t.call(n,n[o],o))&&(r+=e);return r},ta.mean=function(n,t){var e,i=0,o=n.length,a=-1,c=o;if(1===arguments.length)for(;++a<o;)u(e=r(n[a]))?i+=e:--c;else for(;++a<o;)u(e=r(t.call(n,n[a],a)))?i+=e:--c;return c?i/c:void 0},ta.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},ta.median=function(n,t){var i,o=[],a=n.length,c=-1;if(1===arguments.length)for(;++c<a;)u(i=r(n[c]))&&o.push(i);else for(;++c<a;)u(i=r(t.call(n,n[c],c)))&&o.push(i);return o.length?ta.quantile(o.sort(e),.5):void 0},ta.variance=function(n,t){var e,i,o=n.length,a=0,c=0,l=-1,s=0;if(1===arguments.length)for(;++l<o;)u(e=r(n[l]))&&(i=e-a,a+=i/++s,c+=i*(e-a));else for(;++l<o;)u(e=r(t.call(n,n[l],l)))&&(i=e-a,a+=i/++s,c+=i*(e-a));return s>1?c/(s-1):void 0},ta.deviation=function(){var n=ta.variance.apply(this,arguments);return n?Math.sqrt(n):n};var ha=i(e);ta.bisectLeft=ha.left,ta.bisect=ta.bisectRight=ha.right,ta.bisector=function(n){return i(1===n.length?function(t,r){return e(n(t),r)}:n)},ta.shuffle=function(n,t,e){(i=arguments.length)<3&&(e=n.length,2>i&&(t=0));for(var r,u,i=e-t;i;)u=Math.random()*i--|0,r=n[i+t],n[i+t]=n[u+t],n[u+t]=r;return n},ta.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ta.pairs=function(n){for(var t,e=0,r=n.length-1,u=n[0],i=new Array(0>r?0:r);r>e;)i[e]=[t=u,u=n[++e]];return i},ta.zip=function(){if(!(r=arguments.length))return[];for(var n=-1,t=ta.min(arguments,o),e=new Array(t);++n<t;)for(var r,u=-1,i=e[n]=new Array(r);++u<r;)i[u]=arguments[u][n];return e},ta.transpose=function(n){return ta.zip.apply(ta,n)},ta.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ta.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ta.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ta.merge=function(n){for(var t,e,r,u=n.length,i=-1,o=0;++i<u;)o+=n[i].length;for(e=new Array(o);--u>=0;)for(r=n[u],t=r.length;--t>=0;)e[--o]=r[t];return e};var ga=Math.abs;ta.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,u=[],i=a(ga(e)),o=-1;if(n*=i,t*=i,e*=i,0>e)for(;(r=n+e*++o)>t;)u.push(r/i);else for(;(r=n+e*++o)<t;)u.push(r/i);return u},ta.map=function(n,t){var e=new l;if(n instanceof l)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,u=-1,i=n.length;if(1===arguments.length)for(;++u<i;)e.set(u,n[u]);else for(;++u<i;)e.set(t.call(n,r=n[u],u),r)}else for(var o in n)e.set(o,n[o]);return e};var pa="__proto__",va="\x00";c(l,{has:h,get:function(n){return this._[s(n)]},set:function(n,t){return this._[s(n)]=t},remove:g,keys:p,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:f(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,f(t),this._[t])}}),ta.nest=function(){function n(t,o,a){if(a>=i.length)return r?r.call(u,o):e?o.sort(e):o;for(var c,s,f,h,g=-1,p=o.length,v=i[a++],d=new l;++g<p;)(h=d.get(c=v(s=o[g])))?h.push(s):d.set(c,[s]);return t?(s=t(),f=function(e,r){s.set(e,n(t,r,a))}):(s={},f=function(e,r){s[e]=n(t,r,a)}),d.forEach(f),s}function t(n,e){if(e>=i.length)return n;var r=[],u=o[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,u={},i=[],o=[];return u.map=function(t,e){return n(e,t,0)},u.entries=function(e){return t(n(ta.map,e,0),0)},u.key=function(n){return i.push(n),u},u.sortKeys=function(n){return o[i.length-1]=n,u},u.sortValues=function(n){return e=n,u},u.rollup=function(n){return r=n,u},u},ta.set=function(n){var t=new m;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},c(m,{has:h,add:function(n){return this._[s(n+="")]=!0,n},remove:g,values:p,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,f(t))}}),ta.behavior={},ta.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=M(n,t,t[e]);return n};var da=["webkit","ms","moz","Moz","o","O"];ta.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ta.event=null,ta.requote=function(n){return n.replace(ma,"\\$&")};var ma=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ya={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},Ma=function(n,t){return t.querySelector(n)},xa=function(n,t){return t.querySelectorAll(n)},ba=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(ba=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(Ma=function(n,t){return Sizzle(n,t)[0]||null},xa=Sizzle,ba=Sizzle.matchesSelector),ta.selection=function(){return ta.select(ua.documentElement)};var _a=ta.selection.prototype=[];_a.select=function(n){var t,e,r,u,i=[];n=N(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var c=-1,l=r.length;++c<l;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c,o)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return A(i)},_a.selectAll=function(n){var t,e,r=[];n=C(n);for(var u=-1,i=this.length;++u<i;)for(var o=this[u],a=-1,c=o.length;++a<c;)(e=o[a])&&(r.push(t=ra(n.call(e,e.__data__,a,u))),t.parentNode=e);return A(r)};var wa={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ta.ns={prefix:wa,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.slice(0,t),n=n.slice(t+1)),wa.hasOwnProperty(e)?{space:wa[e],local:n}:n}},_a.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ta.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},_a.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!L(n[u]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},_a.style=function(n,e,r){var u=arguments.length;if(3>u){if("string"!=typeof n){2>u&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>u){var i=this.node();return t(i).getComputedStyle(i,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},_a.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},_a.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},_a.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},_a.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},_a.insert=function(n,t){return n=j(n),t=N(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},_a.remove=function(){return this.each(F)},_a.data=function(n,t){function e(n,e){var r,u,i,o=n.length,f=e.length,h=Math.min(o,f),g=new Array(f),p=new Array(f),v=new Array(o);if(t){var d,m=new l,y=new Array(o);for(r=-1;++r<o;)m.has(d=t.call(u=n[r],u.__data__,r))?v[r]=u:m.set(d,u),y[r]=d;for(r=-1;++r<f;)(u=m.get(d=t.call(e,i=e[r],r)))?u!==!0&&(g[r]=u,u.__data__=i):p[r]=H(i),m.set(d,!0);for(r=-1;++r<o;)m.get(y[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)u=n[r],i=e[r],u?(u.__data__=i,g[r]=u):p[r]=H(i);for(;f>r;++r)p[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}p.update=g,p.parentNode=g.parentNode=v.parentNode=n.parentNode,a.push(p),c.push(g),s.push(v)}var r,u,i=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++i<o;)(u=r[i])&&(n[i]=u.__data__);return n}var a=Z([]),c=A([]),s=A([]);if("function"==typeof n)for(;++i<o;)e(r=this[i],n.call(r,r.parentNode.__data__,i));else for(;++i<o;)e(r=this[i],n);return c.enter=function(){return a},c.exit=function(){return s},c},_a.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},_a.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=O(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return A(u)},_a.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},_a.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},_a.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},_a.call=function(n){var t=ra(arguments);return n.apply(t[0]=this,t),this},_a.empty=function(){return!this.node()},_a.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null},_a.size=function(){var n=0;return Y(this,function(){++n}),n};var Sa=[];ta.selection.enter=Z,ta.selection.enter.prototype=Sa,Sa.append=_a.append,Sa.empty=_a.empty,Sa.node=_a.node,Sa.call=_a.call,Sa.size=_a.size,Sa.select=function(n){for(var t,e,r,u,i,o=[],a=-1,c=this.length;++a<c;){r=(u=this[a]).update,o.push(t=[]),t.parentNode=u.parentNode;for(var l=-1,s=u.length;++l<s;)(i=u[l])?(t.push(r[l]=e=n.call(u.parentNode,i.__data__,l,a)),e.__data__=i.__data__):t.push(null)}return A(o)},Sa.insert=function(n,t){return arguments.length<2&&(t=V(this)),_a.insert.call(this,n,t)},ta.select=function(t){var e;return"string"==typeof t?(e=[Ma(t,ua)],e.parentNode=ua.documentElement):(e=[t],e.parentNode=n(t)),A([e])},ta.selectAll=function(n){var t;return"string"==typeof n?(t=ra(xa(n,ua)),t.parentNode=ua.documentElement):(t=n,t.parentNode=null),A([t])},_a.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var ka=ta.map({mouseenter:"mouseover",mouseleave:"mouseout"});ua&&ka.forEach(function(n){"on"+n in ua&&ka.remove(n)});var Ea,Aa=0;ta.mouse=function(n){return J(n,k())};var Na=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ta.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,u=0,i=t.length;i>u;++u)if((r=t[u]).identifier===e)return J(n,r)},ta.behavior.drag=function(){function n(){this.on("mousedown.drag",i).on("touchstart.drag",o)}function e(n,t,e,i,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],p|=n|e,M=r,g({type:"drag",x:r[0]+l[0],y:r[1]+l[1],dx:n,dy:e}))}function c(){t(h,v)&&(m.on(i+d,null).on(o+d,null),y(p&&ta.event.target===f),g({type:"dragend"}))}var l,s=this,f=ta.event.target,h=s.parentNode,g=r.of(s,arguments),p=0,v=n(),d=".drag"+(null==v?"":"-"+v),m=ta.select(e(f)).on(i+d,a).on(o+d,c),y=W(f),M=t(h,v);u?(l=u.apply(s,arguments),l=[l.x-M[0],l.y-M[1]]):l=[0,0],g({type:"dragstart"})}}var r=E(n,"drag","dragstart","dragend"),u=null,i=e(b,ta.mouse,t,"mousemove","mouseup"),o=e(G,ta.touch,y,"touchmove","touchend");return n.origin=function(t){return arguments.length?(u=t,n):u},ta.rebind(n,r,"on")},ta.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?ra(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Ca=1e-6,za=Ca*Ca,qa=Math.PI,La=2*qa,Ta=La-Ca,Ra=qa/2,Da=qa/180,Pa=180/qa,Ua=Math.SQRT2,ja=2,Fa=4;ta.interpolateZoom=function(n,t){function e(n){var t=n*y;if(m){var e=rt(v),o=i/(ja*h)*(e*ut(Ua*t+v)-et(v));return[r+o*l,u+o*s,i*e/rt(Ua*t+v)]}return[r+n*l,u+n*s,i*Math.exp(Ua*t)]}var r=n[0],u=n[1],i=n[2],o=t[0],a=t[1],c=t[2],l=o-r,s=a-u,f=l*l+s*s,h=Math.sqrt(f),g=(c*c-i*i+Fa*f)/(2*i*ja*h),p=(c*c-i*i-Fa*f)/(2*c*ja*h),v=Math.log(Math.sqrt(g*g+1)-g),d=Math.log(Math.sqrt(p*p+1)-p),m=d-v,y=(m||Math.log(c/i))/Ua;return e.duration=1e3*y,e},ta.behavior.zoom=function(){function n(n){n.on(q,f).on(Oa+".zoom",g).on("dblclick.zoom",p).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function u(n){k.k=Math.max(N[0],Math.min(N[1],n))}function i(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},u(Math.pow(2,o)),i(d=e,r),t=ta.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function c(n){z++||n({type:"zoomstart"})}function l(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function s(n){--z||n({type:"zoomend"}),d=null}function f(){function n(){f=1,i(ta.mouse(u),g),l(a)}function r(){h.on(L,null).on(T,null),p(f&&ta.event.target===o),s(a)}var u=this,o=ta.event.target,a=D.of(u,arguments),f=0,h=ta.select(t(u)).on(L,n).on(T,r),g=e(ta.mouse(u)),p=W(u);Dl.call(u),c(a)}function h(){function n(){var n=ta.touches(p);return g=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ta.event.target;ta.select(t).on(x,r).on(b,a),_.push(t);for(var e=ta.event.changedTouches,u=0,i=e.length;i>u;++u)d[e[u].identifier]=null;var c=n(),l=Date.now();if(1===c.length){if(500>l-M){var s=c[0];o(p,s,d[s.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=l}else if(c.length>1){var s=c[0],f=c[1],h=s[0]-f[0],g=s[1]-f[1];m=h*h+g*g}}function r(){var n,t,e,r,o=ta.touches(p);Dl.call(p);for(var a=0,c=o.length;c>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var s=(s=e[0]-n[0])*s+(s=e[1]-n[1])*s,f=m&&Math.sqrt(s/m);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],u(f*g)}M=null,i(n,t),l(v)}function a(){if(ta.event.touches.length){for(var t=ta.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var u in d)return void n()}ta.selectAll(_).on(y,null),w.on(q,f).on(R,h),E(),s(v)}var g,p=this,v=D.of(p,arguments),d={},m=0,y=".zoom-"+ta.event.changedTouches[0].identifier,x="touchmove"+y,b="touchend"+y,_=[],w=ta.select(p),E=W(p);t(),c(v),w.on(q,null).on(R,t)}function g(){var n=D.of(this,arguments);y?clearTimeout(y):(v=e(d=m||ta.mouse(this)),Dl.call(this),c(n)),y=setTimeout(function(){y=null,s(n)},50),S(),u(Math.pow(2,.002*Ha())*k.k),i(d,v),l(n)}function p(){var n=ta.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ta.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,m,y,M,x,b,_,w,k={x:0,y:0,k:1},A=[960,500],N=Ia,C=250,z=0,q="mousedown.zoom",L="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=E(n,"zoomstart","zoom","zoomend");return Oa||(Oa="onwheel"in ua?(Ha=function(){return-ta.event.deltaY*(ta.event.deltaMode?120:1)},"wheel"):"onmousewheel"in ua?(Ha=function(){return ta.event.wheelDelta},"mousewheel"):(Ha=function(){return-ta.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Tl?ta.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},c(n)}).tween("zoom:zoom",function(){var e=A[0],r=A[1],u=d?d[0]:e/2,i=d?d[1]:r/2,o=ta.interpolateZoom([(u-k.x)/k.k,(i-k.y)/k.k,e/k.k],[(u-t.x)/t.k,(i-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:u-r[0]*a,y:i-r[1]*a,k:a},l(n)}}).each("interrupt.zoom",function(){s(n)}).each("end.zoom",function(){s(n)}):(this.__chart__=k,c(n),l(n),s(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:+t},a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(N=null==t?Ia:[+t[0],+t[1]],n):N},n.center=function(t){return arguments.length?(m=t&&[+t[0],+t[1]],n):m},n.size=function(t){return arguments.length?(A=t&&[+t[0],+t[1]],n):A},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ta.rebind(n,D,"on")};var Ha,Oa,Ia=[0,1/0];ta.color=ot,ot.prototype.toString=function(){return this.rgb()+""},ta.hsl=at;var Ya=at.prototype=new ot;Ya.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new at(this.h,this.s,this.l/n)},Ya.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new at(this.h,this.s,n*this.l)},Ya.rgb=function(){return ct(this.h,this.s,this.l)},ta.hcl=lt;var Za=lt.prototype=new ot;Za.brighter=function(n){return new lt(this.h,this.c,Math.min(100,this.l+Va*(arguments.length?n:1)))},Za.darker=function(n){return new lt(this.h,this.c,Math.max(0,this.l-Va*(arguments.length?n:1)))},Za.rgb=function(){return st(this.h,this.c,this.l).rgb()},ta.lab=ft;var Va=18,Xa=.95047,$a=1,Ba=1.08883,Wa=ft.prototype=new ot;Wa.brighter=function(n){return new ft(Math.min(100,this.l+Va*(arguments.length?n:1)),this.a,this.b)},Wa.darker=function(n){return new ft(Math.max(0,this.l-Va*(arguments.length?n:1)),this.a,this.b)},Wa.rgb=function(){return ht(this.l,this.a,this.b)},ta.rgb=mt;var Ja=mt.prototype=new ot;Ja.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),new mt(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mt(u,u,u)},Ja.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mt(n*this.r,n*this.g,n*this.b)},Ja.hsl=function(){return _t(this.r,this.g,this.b)},Ja.toString=function(){return"#"+xt(this.r)+xt(this.g)+xt(this.b)};var Ga=ta.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});Ga.forEach(function(n,t){Ga.set(n,yt(t))}),ta.functor=Et,ta.xhr=At(y),ta.dsv=function(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var o=Nt(n,t,null==e?r:u(e),i);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:u(n)):e},o}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function i(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),c=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(s>=l)return o;if(u)return u=!1,i;var t=s;if(34===n.charCodeAt(t)){for(var e=t;e++<l;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}s=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,10===n.charCodeAt(e+2)&&++s):10===r&&(u=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;l>s;){var r=n.charCodeAt(s++),a=1;if(10===r)u=!0;else if(13===r)u=!0,10===n.charCodeAt(s)&&(++s,++a);else if(r!==c)continue;return n.slice(t,s-a)}return n.slice(t)}for(var r,u,i={},o={},a=[],l=n.length,s=0,f=0;(r=e())!==o;){for(var h=[];r!==i&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,f++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new m,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(i).join("\n")},e},ta.csv=ta.dsv(",","text/csv"),ta.tsv=ta.dsv("	","text/tab-separated-values");var Ka,Qa,nc,tc,ec,rc=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ta.timer=function(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var u=e+t,i={c:n,t:u,f:!1,n:null};Qa?Qa.n=i:Ka=i,Qa=i,nc||(tc=clearTimeout(tc),nc=1,rc(qt))},ta.timer.flush=function(){Lt(),Tt()},ta.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var uc=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Dt);ta.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=ta.round(n,Rt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),uc[8+e/3]};var ic=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,oc=ta.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ta.round(n,Rt(n,t))).toFixed(Math.max(0,Math.min(20,Rt(n*(1+1e-15),t))))}}),ac=ta.time={},cc=Date;jt.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){lc.setUTCDate.apply(this._,arguments)},setDay:function(){lc.setUTCDay.apply(this._,arguments)},setFullYear:function(){lc.setUTCFullYear.apply(this._,arguments)},setHours:function(){lc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){lc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){lc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){lc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){lc.setUTCSeconds.apply(this._,arguments)},setTime:function(){lc.setTime.apply(this._,arguments)}};var lc=Date.prototype;ac.year=Ft(function(n){return n=ac.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ac.years=ac.year.range,ac.years.utc=ac.year.utc.range,ac.day=Ft(function(n){var t=new cc(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ac.days=ac.day.range,ac.days.utc=ac.day.utc.range,ac.dayOfYear=function(n){var t=ac.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ac[n]=Ft(function(n){return(n=ac.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ac.year(n).getDay();return Math.floor((ac.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ac[n+"s"]=e.range,ac[n+"s"].utc=e.utc.range,ac[n+"OfYear"]=function(n){var e=ac.year(n).getDay();return Math.floor((ac.dayOfYear(n)+(e+t)%7)/7)}}),ac.week=ac.sunday,ac.weeks=ac.sunday.range,ac.weeks.utc=ac.sunday.utc.range,ac.weekOfYear=ac.sundayOfYear;var sc={"-":"",_:" ",0:"0"},fc=/^\s*\d+/,hc=/^%/;ta.locale=function(n){return{numberFormat:Pt(n),timeFormat:Ot(n)}};var gc=ta.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ta.format=gc.numberFormat,ta.geo={},ce.prototype={s:0,t:0,add:function(n){le(n,this.t,pc),le(pc.s,this.s,this),this.s?this.t+=pc.t:this.s=pc.t
	},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var pc=new ce;ta.geo.stream=function(n,t){n&&vc.hasOwnProperty(n.type)?vc[n.type](n,t):se(n,t)};var vc={Feature:function(n,t){se(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)se(e[r].geometry,t)}},dc={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){fe(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)fe(e[r],t,0)},Polygon:function(n,t){he(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)he(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)se(e[r],t)}};ta.geo.area=function(n){return mc=0,ta.geo.stream(n,Mc),mc};var mc,yc=new ce,Mc={sphere:function(){mc+=4*qa},point:b,lineStart:b,lineEnd:b,polygonStart:function(){yc.reset(),Mc.lineStart=ge},polygonEnd:function(){var n=2*yc;mc+=0>n?4*qa+n:n,Mc.lineStart=Mc.lineEnd=Mc.point=b}};ta.geo.bounds=function(){function n(n,t){M.push(x=[s=n,h=n]),f>t&&(f=t),t>g&&(g=t)}function t(t,e){var r=pe([t*Da,e*Da]);if(m){var u=de(m,r),i=[u[1],-u[0],0],o=de(i,u);Me(o),o=xe(o);var c=t-p,l=c>0?1:-1,v=o[0]*Pa*l,d=ga(c)>180;if(d^(v>l*p&&l*t>v)){var y=o[1]*Pa;y>g&&(g=y)}else if(v=(v+360)%360-180,d^(v>l*p&&l*t>v)){var y=-o[1]*Pa;f>y&&(f=y)}else f>e&&(f=e),e>g&&(g=e);d?p>t?a(s,t)>a(s,h)&&(h=t):a(t,h)>a(s,h)&&(s=t):h>=s?(s>t&&(s=t),t>h&&(h=t)):t>p?a(s,t)>a(s,h)&&(h=t):a(t,h)>a(s,h)&&(s=t)}else n(t,e);m=r,p=t}function e(){b.point=t}function r(){x[0]=s,x[1]=h,b.point=n,m=null}function u(n,e){if(m){var r=n-p;y+=ga(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Mc.point(n,e),t(n,e)}function i(){Mc.lineStart()}function o(){u(v,d),Mc.lineEnd(),ga(y)>Ca&&(s=-(h=180)),x[0]=s,x[1]=h,m=null}function a(n,t){return(t-=n)<0?t+360:t}function c(n,t){return n[0]-t[0]}function l(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var s,f,h,g,p,v,d,m,y,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=u,b.lineStart=i,b.lineEnd=o,y=0,Mc.polygonStart()},polygonEnd:function(){Mc.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>yc?(s=-(h=180),f=-(g=90)):y>Ca?g=90:-Ca>y&&(f=-90),x[0]=s,x[1]=h}};return function(n){g=h=-(s=f=1/0),M=[],ta.geo.stream(n,b);var t=M.length;if(t){M.sort(c);for(var e,r=1,u=M[0],i=[u];t>r;++r)e=M[r],l(e[0],u)||l(e[1],u)?(a(u[0],e[1])>a(u[0],u[1])&&(u[1]=e[1]),a(e[0],u[1])>a(u[0],u[1])&&(u[0]=e[0])):i.push(u=e);for(var o,e,p=-1/0,t=i.length-1,r=0,u=i[t];t>=r;u=e,++r)e=i[r],(o=a(u[1],e[0]))>p&&(p=o,s=e[0],h=u[1])}return M=x=null,1/0===s||1/0===f?[[0/0,0/0],[0/0,0/0]]:[[s,f],[h,g]]}}(),ta.geo.centroid=function(n){xc=bc=_c=wc=Sc=kc=Ec=Ac=Nc=Cc=zc=0,ta.geo.stream(n,qc);var t=Nc,e=Cc,r=zc,u=t*t+e*e+r*r;return za>u&&(t=kc,e=Ec,r=Ac,Ca>bc&&(t=_c,e=wc,r=Sc),u=t*t+e*e+r*r,za>u)?[0/0,0/0]:[Math.atan2(e,t)*Pa,tt(r/Math.sqrt(u))*Pa]};var xc,bc,_c,wc,Sc,kc,Ec,Ac,Nc,Cc,zc,qc={sphere:b,point:_e,lineStart:Se,lineEnd:ke,polygonStart:function(){qc.lineStart=Ee},polygonEnd:function(){qc.lineStart=Se}},Lc=Le(Ne,Pe,je,[-qa,-qa/2]),Tc=1e9;ta.geo.clipExtent=function(){var n,t,e,r,u,i,o={stream:function(n){return u&&(u.valid=!1),u=i(n),u.valid=!0,u},extent:function(a){return arguments.length?(i=Ie(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),u&&(u.valid=!1,u=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ta.geo.conicEqualArea=function(){return Ye(Ze)}).raw=Ze,ta.geo.albers=function(){return ta.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ta.geo.albersUsa=function(){function n(n){var i=n[0],o=n[1];return t=null,e(i,o),t||(r(i,o),t)||u(i,o),t}var t,e,r,u,i=ta.geo.albers(),o=ta.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ta.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),c={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=i.scale(),e=i.translate(),r=(n[0]-e[0])/t,u=(n[1]-e[1])/t;return(u>=.12&&.234>u&&r>=-.425&&-.214>r?o:u>=.166&&.234>u&&r>=-.214&&-.115>r?a:i).invert(n)},n.stream=function(n){var t=i.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,u){t.point(n,u),e.point(n,u),r.point(n,u)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(i.precision(t),o.precision(t),a.precision(t),n):i.precision()},n.scale=function(t){return arguments.length?(i.scale(t),o.scale(.35*t),a.scale(t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var l=i.scale(),s=+t[0],f=+t[1];return e=i.translate(t).clipExtent([[s-.455*l,f-.238*l],[s+.455*l,f+.238*l]]).stream(c).point,r=o.translate([s-.307*l,f+.201*l]).clipExtent([[s-.425*l+Ca,f+.12*l+Ca],[s-.214*l-Ca,f+.234*l-Ca]]).stream(c).point,u=a.translate([s-.205*l,f+.212*l]).clipExtent([[s-.214*l+Ca,f+.166*l+Ca],[s-.115*l-Ca,f+.234*l-Ca]]).stream(c).point,n},n.scale(1070)};var Rc,Dc,Pc,Uc,jc,Fc,Hc={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Dc=0,Hc.lineStart=Ve},polygonEnd:function(){Hc.lineStart=Hc.lineEnd=Hc.point=b,Rc+=ga(Dc/2)}},Oc={point:Xe,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Ic={point:We,lineStart:Je,lineEnd:Ge,polygonStart:function(){Ic.lineStart=Ke},polygonEnd:function(){Ic.point=We,Ic.lineStart=Je,Ic.lineEnd=Ge}};ta.geo.path=function(){function n(n){return n&&("function"==typeof a&&i.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=u(i)),ta.geo.stream(n,o)),i.result()}function t(){return o=null,n}var e,r,u,i,o,a=4.5;return n.area=function(n){return Rc=0,ta.geo.stream(n,u(Hc)),Rc},n.centroid=function(n){return _c=wc=Sc=kc=Ec=Ac=Nc=Cc=zc=0,ta.geo.stream(n,u(Ic)),zc?[Nc/zc,Cc/zc]:Ac?[kc/Ac,Ec/Ac]:Sc?[_c/Sc,wc/Sc]:[0/0,0/0]},n.bounds=function(n){return jc=Fc=-(Pc=Uc=1/0),ta.geo.stream(n,u(Oc)),[[Pc,Uc],[jc,Fc]]},n.projection=function(n){return arguments.length?(u=(e=n)?n.stream||tr(n):y,t()):e},n.context=function(n){return arguments.length?(i=null==(r=n)?new $e:new Qe(n),"function"!=typeof a&&i.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(i.pointRadius(+t),+t),n):a},n.projection(ta.geo.albersUsa()).context(null)},ta.geo.transform=function(n){return{stream:function(t){var e=new er(t);for(var r in n)e[r]=n[r];return e}}},er.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ta.geo.projection=ur,ta.geo.projectionMutator=ir,(ta.geo.equirectangular=function(){return ur(ar)}).raw=ar.invert=ar,ta.geo.rotation=function(n){function t(t){return t=n(t[0]*Da,t[1]*Da),t[0]*=Pa,t[1]*=Pa,t}return n=lr(n[0]%360*Da,n[1]*Da,n.length>2?n[2]*Da:0),t.invert=function(t){return t=n.invert(t[0]*Da,t[1]*Da),t[0]*=Pa,t[1]*=Pa,t},t},cr.invert=ar,ta.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=lr(-n[0]*Da,-n[1]*Da,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=Pa,n[1]*=Pa}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=gr((t=+r)*Da,u*Da),n):t},n.precision=function(r){return arguments.length?(e=gr(t*Da,(u=+r)*Da),n):u},n.angle(90)},ta.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Da,u=n[1]*Da,i=t[1]*Da,o=Math.sin(r),a=Math.cos(r),c=Math.sin(u),l=Math.cos(u),s=Math.sin(i),f=Math.cos(i);return Math.atan2(Math.sqrt((e=f*o)*e+(e=l*s-c*f*a)*e),c*s+l*f*a)},ta.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ta.range(Math.ceil(i/d)*d,u,d).map(h).concat(ta.range(Math.ceil(l/m)*m,c,m).map(g)).concat(ta.range(Math.ceil(r/p)*p,e,p).filter(function(n){return ga(n%d)>Ca}).map(s)).concat(ta.range(Math.ceil(a/v)*v,o,v).filter(function(n){return ga(n%m)>Ca}).map(f))}var e,r,u,i,o,a,c,l,s,f,h,g,p=10,v=p,d=90,m=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(l).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],l=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),l>c&&(t=l,l=c,c=t),n.precision(y)):[[i,l],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(y)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],m=+t[1],n):[d,m]},n.minorStep=function(t){return arguments.length?(p=+t[0],v=+t[1],n):[p,v]},n.precision=function(t){return arguments.length?(y=+t,s=vr(a,o,90),f=dr(r,e,y),h=vr(l,c,90),g=dr(i,u,y),n):y},n.majorExtent([[-180,-90+Ca],[180,90-Ca]]).minorExtent([[-180,-80-Ca],[180,80+Ca]])},ta.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=mr,u=yr;return n.distance=function(){return ta.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},ta.geo.interpolate=function(n,t){return Mr(n[0]*Da,n[1]*Da,t[0]*Da,t[1]*Da)},ta.geo.length=function(n){return Yc=0,ta.geo.stream(n,Zc),Yc};var Yc,Zc={sphere:b,point:b,lineStart:xr,lineEnd:b,polygonStart:b,polygonEnd:b},Vc=br(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ta.geo.azimuthalEqualArea=function(){return ur(Vc)}).raw=Vc;var Xc=br(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},y);(ta.geo.azimuthalEquidistant=function(){return ur(Xc)}).raw=Xc,(ta.geo.conicConformal=function(){return Ye(_r)}).raw=_r,(ta.geo.conicEquidistant=function(){return Ye(wr)}).raw=wr;var $c=br(function(n){return 1/n},Math.atan);(ta.geo.gnomonic=function(){return ur($c)}).raw=$c,Sr.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Ra]},(ta.geo.mercator=function(){return kr(Sr)}).raw=Sr;var Bc=br(function(){return 1},Math.asin);(ta.geo.orthographic=function(){return ur(Bc)}).raw=Bc;var Wc=br(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ta.geo.stereographic=function(){return ur(Wc)}).raw=Wc,Er.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Ra]},(ta.geo.transverseMercator=function(){var n=kr(Er),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Er,ta.geom={},ta.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u=Et(e),i=Et(r),o=n.length,a=[],c=[];for(t=0;o>t;t++)a.push([+u.call(this,n[t],t),+i.call(this,n[t],t),t]);for(a.sort(zr),t=0;o>t;t++)c.push([a[t][0],-a[t][1]]);var l=Cr(a),s=Cr(c),f=s[0]===l[0],h=s[s.length-1]===l[l.length-1],g=[];for(t=l.length-1;t>=0;--t)g.push(n[a[l[t]][2]]);for(t=+f;t<s.length-h;++t)g.push(n[a[s[t]][2]]);return g}var e=Ar,r=Nr;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ta.geom.polygon=function(n){return ya(n,Jc),n};var Jc=ta.geom.polygon.prototype=[];Jc.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],u=0;++t<e;)n=r,r=this[t],u+=n[1]*r[0]-n[0]*r[1];return.5*u},Jc.centroid=function(n){var t,e,r=-1,u=this.length,i=0,o=0,a=this[u-1];for(arguments.length||(n=-1/(6*this.area()));++r<u;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],i+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[i*n,o*n]},Jc.clip=function(n){for(var t,e,r,u,i,o,a=Tr(n),c=-1,l=this.length-Tr(this),s=this[l-1];++c<l;){for(t=n.slice(),n.length=0,u=this[c],i=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],qr(o,s,u)?(qr(i,s,u)||n.push(Lr(i,o,s,u)),n.push(o)):qr(i,s,u)&&n.push(Lr(i,o,s,u)),i=o;a&&n.push(n[0]),s=u}return n};var Gc,Kc,Qc,nl,tl,el=[],rl=[];Or.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Yr),t.length},Qr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},nu.prototype={insert:function(n,t){var e,r,u;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=uu(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(u=r.R,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.R&&(eu(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ru(this,r))):(u=r.L,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.L&&(ru(this,e),n=e,e=n.U),e.C=!1,r.C=!0,eu(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,u=n.U,i=n.L,o=n.R;if(e=i?o?uu(o):i:o,u?u.L===n?u.L=e:u.R=e:this._=e,i&&o?(r=e.C,e.C=n.C,e.L=i,i.U=e,e!==o?(u=e.U,e.U=n.U,n=e.R,u.L=n,e.R=o,o.U=e):(e.U=u,u=e,n=e.R)):(r=n.C,n=e),n&&(n.U=u),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===u.L){if(t=u.R,t.C&&(t.C=!1,u.C=!0,eu(this,u),t=u.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ru(this,t),t=u.R),t.C=u.C,u.C=t.R.C=!1,eu(this,u),n=this._;break}}else if(t=u.L,t.C&&(t.C=!1,u.C=!0,ru(this,u),t=u.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,eu(this,t),t=u.L),t.C=u.C,u.C=t.L.C=!1,ru(this,u),n=this._;break}t.C=!0,n=u,u=u.U}while(!n.C);n&&(n.C=!1)}}},ta.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],u=a[0][1],i=a[1][0],o=a[1][1];return iu(e(n),a).cells.forEach(function(e,a){var c=e.edges,l=e.site,s=t[a]=c.length?c.map(function(n){var t=n.start();return[t.x,t.y]}):l.x>=r&&l.x<=i&&l.y>=u&&l.y<=o?[[r,o],[i,o],[i,u],[r,u]]:[];s.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(i(n,t)/Ca)*Ca,y:Math.round(o(n,t)/Ca)*Ca,i:t}})}var r=Ar,u=Nr,i=r,o=u,a=ul;return n?t(n):(t.links=function(n){return iu(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return iu(e(n)).cells.forEach(function(e,r){for(var u,i,o=e.site,a=e.edges.sort(Yr),c=-1,l=a.length,s=a[l-1].edge,f=s.l===o?s.r:s.l;++c<l;)u=s,i=f,s=a[c].edge,f=s.l===o?s.r:s.l,r<i.i&&r<f.i&&au(o,i,f)<0&&t.push([n[r],n[i.i],n[f.i]])}),t},t.x=function(n){return arguments.length?(i=Et(r=n),t):r},t.y=function(n){return arguments.length?(o=Et(u=n),t):u},t.clipExtent=function(n){return arguments.length?(a=null==n?ul:n,t):a===ul?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===ul?null:a&&a[1]},t)};var ul=[[-1e6,-1e6],[1e6,1e6]];ta.geom.delaunay=function(n){return ta.geom.voronoi().triangles(n)},ta.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,s=n.y;if(null!=c)if(ga(c-e)+ga(s-r)<.01)l(n,t,e,r,u,i,o,a);else{var f=n.point;n.x=n.y=n.point=null,l(n,f,c,s,u,i,o,a),l(n,t,e,r,u,i,o,a)}else n.x=e,n.y=r,n.point=t}else l(n,t,e,r,u,i,o,a)}function l(n,t,e,r,u,o,a,c){var l=.5*(u+a),s=.5*(o+c),f=e>=l,h=r>=s,g=h<<1|f;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=su()),f?u=l:a=l,h?o=s:c=s,i(n,t,e,r,u,o,a,c)}var s,f,h,g,p,v,d,m,y,M=Et(a),x=Et(c);if(null!=t)v=t,d=e,m=r,y=u;else if(m=y=-(v=d=1/0),f=[],h=[],p=n.length,o)for(g=0;p>g;++g)s=n[g],s.x<v&&(v=s.x),s.y<d&&(d=s.y),s.x>m&&(m=s.x),s.y>y&&(y=s.y),f.push(s.x),h.push(s.y);else for(g=0;p>g;++g){var b=+M(s=n[g],g),_=+x(s,g);v>b&&(v=b),d>_&&(d=_),b>m&&(m=b),_>y&&(y=_),f.push(b),h.push(_)}var w=m-v,S=y-d;w>S?y=d+w:m=v+S;var k=su();if(k.add=function(n){i(k,n,+M(n,++g),+x(n,g),v,d,m,y)},k.visit=function(n){fu(n,k,v,d,m,y)},k.find=function(n){return hu(k,n[0],n[1],v,d,m,y)},g=-1,null==t){for(;++g<p;)i(k,n[g],f[g],h[g],v,d,m,y);--g}else n.forEach(k.add);return f=h=n=s=null,k}var o,a=Ar,c=Nr;return(o=arguments.length)?(a=cu,c=lu,3===o&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(a=n,i):a},i.y=function(n){return arguments.length?(c=n,i):c},i.extent=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],u=+n[1][1]),i):null==t?null:[[t,e],[r,u]]},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r-t,u-e]},i)},ta.interpolateRgb=gu,ta.interpolateObject=pu,ta.interpolateNumber=vu,ta.interpolateString=du;var il=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,ol=new RegExp(il.source,"g");ta.interpolate=mu,ta.interpolators=[function(n,t){var e=typeof t;return("string"===e?Ga.has(t)||/^(#|rgb\(|hsl\()/.test(t)?gu:du:t instanceof ot?gu:Array.isArray(t)?yu:"object"===e&&isNaN(t)?pu:vu)(n,t)}],ta.interpolateArray=yu;var al=function(){return y},cl=ta.map({linear:al,poly:ku,quad:function(){return _u},cubic:function(){return wu},sin:function(){return Eu},exp:function(){return Au},circle:function(){return Nu},elastic:Cu,back:zu,bounce:function(){return qu}}),ll=ta.map({"in":y,out:xu,"in-out":bu,"out-in":function(n){return bu(xu(n))}});ta.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=cl.get(e)||al,r=ll.get(r)||y,Mu(r(e.apply(null,ea.call(arguments,1))))},ta.interpolateHcl=Lu,ta.interpolateHsl=Tu,ta.interpolateLab=Ru,ta.interpolateRound=Du,ta.transform=function(n){var t=ua.createElementNS(ta.ns.prefix.svg,"g");return(ta.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new Pu(e?e.matrix:sl)})(n)},Pu.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var sl={a:1,b:0,c:0,d:1,e:0,f:0};ta.interpolateTransform=Hu,ta.layout={},ta.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Yu(n[e]));return t}},ta.layout.chord=function(){function n(){var n,l,f,h,g,p={},v=[],d=ta.range(i),m=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(l=0,g=-1;++g<i;)l+=u[h][g];v.push(l),m.push(ta.range(i)),n+=l}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&m.forEach(function(n,t){n.sort(function(n,e){return a(u[t][n],u[t][e])})}),n=(La-s*i)/n,l=0,h=-1;++h<i;){for(f=l,g=-1;++g<i;){var y=d[h],M=m[y][g],x=u[y][M],b=l,_=l+=x*n;p[y+"-"+M]={index:y,subindex:M,startAngle:b,endAngle:_,value:x}}r[y]={index:y,startAngle:f,endAngle:l,value:(l-f)/n},l+=s}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,o,a,c,l={},s=0;return l.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,l):u},l.padding=function(n){return arguments.length?(s=n,e=r=null,l):s},l.sortGroups=function(n){return arguments.length?(o=n,e=r=null,l):o},l.sortSubgroups=function(n){return arguments.length?(a=n,e=null,l):a},l.sortChords=function(n){return arguments.length?(c=n,e&&t(),l):c},l.chords=function(){return e||n(),e},l.groups=function(){return r||n(),r},l},ta.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,o=t.cy-n.y,a=u-e,c=i*i+o*o;if(c>a*a/d){if(p>c){var l=t.charge/c;n.px-=i*l,n.py-=o*l}return!0}if(t.point&&c&&p>c){var l=t.pointCharge/c;n.px-=i*l,n.py-=o*l}}return!t.charge}}function t(n){n.px=ta.event.x,n.py=ta.event.y,a.resume()}var e,r,u,i,o,a={},c=ta.dispatch("start","tick","end"),l=[1,1],s=.9,f=fl,h=hl,g=-30,p=gl,v=.1,d=.64,m=[],M=[];return a.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,a,f,h,p,d,y,x,b=m.length,_=M.length;for(e=0;_>e;++e)a=M[e],f=a.source,h=a.target,y=h.x-f.x,x=h.y-f.y,(p=y*y+x*x)&&(p=r*i[e]*((p=Math.sqrt(p))-u[e])/p,y*=p,x*=p,h.x-=y*(d=f.weight/(h.weight+f.weight)),h.y-=x*d,f.x+=y*(d=1-d),f.y+=x*d);if((d=r*v)&&(y=l[0]/2,x=l[1]/2,e=-1,d))for(;++e<b;)a=m[e],a.x+=(y-a.x)*d,a.y+=(x-a.y)*d;if(g)for(Ju(t=ta.geom.quadtree(m),r,o),e=-1;++e<b;)(a=m[e]).fixed||t.visit(n(a));for(e=-1;++e<b;)a=m[e],a.fixed?(a.x=a.px,a.y=a.py):(a.x-=(a.px-(a.px=a.x))*s,a.y-=(a.py-(a.py=a.y))*s);c.tick({type:"tick",alpha:r})},a.nodes=function(n){return arguments.length?(m=n,a):m},a.links=function(n){return arguments.length?(M=n,a):M},a.size=function(n){return arguments.length?(l=n,a):l},a.linkDistance=function(n){return arguments.length?(f="function"==typeof n?n:+n,a):f},a.distance=a.linkDistance,a.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,a):h},a.friction=function(n){return arguments.length?(s=+n,a):s},a.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,a):g},a.chargeDistance=function(n){return arguments.length?(p=n*n,a):Math.sqrt(p)},a.gravity=function(n){return arguments.length?(v=+n,a):v},a.theta=function(n){return arguments.length?(d=n*n,a):Math.sqrt(d)},a.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),ta.timer(a.tick)),a):r},a.start=function(){function n(n,r){if(!e){for(e=new Array(c),a=0;c>a;++a)e[a]=[];for(a=0;s>a;++a){var u=M[a];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var i,o=e[t],a=-1,l=o.length;++a<l;)if(!isNaN(i=o[a][n]))return i;return Math.random()*r}var t,e,r,c=m.length,s=M.length,p=l[0],v=l[1];for(t=0;c>t;++t)(r=m[t]).index=t,r.weight=0;for(t=0;s>t;++t)r=M[t],"number"==typeof r.source&&(r.source=m[r.source]),"number"==typeof r.target&&(r.target=m[r.target]),++r.source.weight,++r.target.weight;for(t=0;c>t;++t)r=m[t],isNaN(r.x)&&(r.x=n("x",p)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof f)for(t=0;s>t;++t)u[t]=+f.call(this,M[t],t);else for(t=0;s>t;++t)u[t]=f;if(i=[],"function"==typeof h)for(t=0;s>t;++t)i[t]=+h.call(this,M[t],t);else for(t=0;s>t;++t)i[t]=h;if(o=[],"function"==typeof g)for(t=0;c>t;++t)o[t]=+g.call(this,m[t],t);else for(t=0;c>t;++t)o[t]=g;return a.resume()},a.resume=function(){return a.alpha(.1)},a.stop=function(){return a.alpha(0)},a.drag=function(){return e||(e=ta.behavior.drag().origin(y).on("dragstart.force",Xu).on("drag.force",t).on("dragend.force",$u)),arguments.length?void this.on("mouseover.force",Bu).on("mouseout.force",Wu).call(e):e},ta.rebind(a,c,"on")};var fl=20,hl=1,gl=1/0;ta.layout.hierarchy=function(){function n(u){var i,o=[u],a=[];for(u.depth=0;null!=(i=o.pop());)if(a.push(i),(l=e.call(n,i,i.depth))&&(c=l.length)){for(var c,l,s;--c>=0;)o.push(s=l[c]),s.parent=i,s.depth=i.depth+1;r&&(i.value=0),i.children=l}else r&&(i.value=+r.call(n,i,i.depth)||0),delete i.children;return Qu(u,function(n){var e,u;t&&(e=n.children)&&e.sort(t),r&&(u=n.parent)&&(u.value+=n.value)}),a}var t=ei,e=ni,r=ti;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(Ku(t,function(n){n.children&&(n.value=0)}),Qu(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ta.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(o=i.length)){var o,a,c,l=-1;for(r=t.value?r/t.value:0;++l<o;)n(a=i[l],e,c=a.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var o=r.call(this,e,i);return n(o[0],0,u[0],u[1]/t(o[0])),o}var r=ta.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Gu(e,r)},ta.layout.pie=function(){function n(o){var a,c=o.length,l=o.map(function(e,r){return+t.call(n,e,r)}),s=+("function"==typeof r?r.apply(this,arguments):r),f=("function"==typeof u?u.apply(this,arguments):u)-s,h=Math.min(Math.abs(f)/c,+("function"==typeof i?i.apply(this,arguments):i)),g=h*(0>f?-1:1),p=(f-c*g)/ta.sum(l),v=ta.range(c),d=[];return null!=e&&v.sort(e===pl?function(n,t){return l[t]-l[n]}:function(n,t){return e(o[n],o[t])}),v.forEach(function(n){d[n]={data:o[n],value:a=l[n],startAngle:s,endAngle:s+=a*p+g,padAngle:h}}),d}var t=Number,e=pl,r=0,u=La,i=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n.padAngle=function(t){return arguments.length?(i=t,n):i},n};var pl={};ta.layout.stack=function(){function n(a,c){if(!(h=a.length))return a;var l=a.map(function(e,r){return t.call(n,e,r)}),s=l.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),o.call(n,t,e)]})}),f=e.call(n,s,c);l=ta.permute(l,f),s=ta.permute(s,f);var h,g,p,v,d=r.call(n,s,c),m=l[0].length;for(p=0;m>p;++p)for(u.call(n,l[0][p],v=d[p],s[0][p][1]),g=1;h>g;++g)u.call(n,l[g][p],v+=s[g-1][p][1],s[g][p][1]);return a}var t=y,e=ai,r=ci,u=oi,i=ui,o=ii;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:vl.get(t)||ai,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:dl.get(t)||ci,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(u=t,n):u},n};var vl=ta.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(li),i=n.map(si),o=ta.range(r).sort(function(n,t){return u[n]-u[t]}),a=0,c=0,l=[],s=[];for(t=0;r>t;++t)e=o[t],c>a?(a+=i[e],l.push(e)):(c+=i[e],s.push(e));return s.reverse().concat(l)},reverse:function(n){return ta.range(n.length).reverse()},"default":ai}),dl=ta.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,o=[],a=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;i>e;++e)c[e]=(a-o[e])/2;return c},wiggle:function(n){var t,e,r,u,i,o,a,c,l,s=n.length,f=n[0],h=f.length,g=[];for(g[0]=c=l=0,e=1;h>e;++e){for(t=0,u=0;s>t;++t)u+=n[t][e][1];for(t=0,i=0,a=f[e][0]-f[e-1][0];s>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;i+=o*n[t][e][1]}g[e]=c-=u?i/u*a:0,l>c&&(l=c)}for(e=0;h>e;++e)g[e]-=l;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,o=1/u,a=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=o}for(e=0;i>e;++e)a[e]=0;return a},zero:ci});ta.layout.histogram=function(){function n(n,i){for(var o,a,c=[],l=n.map(e,this),s=r.call(this,l,i),f=u.call(this,s,l,i),i=-1,h=l.length,g=f.length-1,p=t?1:1/h;++i<g;)o=c[i]=[],o.dx=f[i+1]-(o.x=f[i]),o.y=0;if(g>0)for(i=-1;++i<h;)a=l[i],a>=s[0]&&a<=s[1]&&(o=c[ta.bisect(f,a,1,g)-1],o.y+=p,o.push(n[i]));return c}var t=!0,e=Number,r=pi,u=hi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=Et(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return gi(n,t)}:Et(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ta.layout.pack=function(){function n(n,i){var o=e.call(this,n,i),a=o[0],c=u[0],l=u[1],s=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,Qu(a,function(n){n.r=+s(n.value)}),Qu(a,Mi),r){var f=r*(t?1:Math.max(2*a.r/c,2*a.r/l))/2;Qu(a,function(n){n.r+=f}),Qu(a,Mi),Qu(a,function(n){n.r-=f})}return _i(a,c/2,l/2,t?1:1/Math.max(2*a.r/c,2*a.r/l)),o}var t,e=ta.layout.hierarchy().sort(vi),r=0,u=[1,1];return n.size=function(t){return arguments.length?(u=t,n):u},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},Gu(n,e)},ta.layout.tree=function(){function n(n,u){var s=o.call(this,n,u),f=s[0],h=t(f);if(Qu(h,e),h.parent.m=-h.z,Ku(h,r),l)Ku(f,i);else{var g=f,p=f,v=f;Ku(f,function(n){n.x<g.x&&(g=n),n.x>p.x&&(p=n),n.depth>v.depth&&(v=n)});var d=a(g,p)/2-g.x,m=c[0]/(p.x+a(p,g)/2+d),y=c[1]/(v.depth||1);Ku(f,function(n){n.x=(n.x+d)*m,n.y=n.depth*y})}return s}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var u,i=t.children,o=0,a=i.length;a>o;++o)r.push((i[o]=u={_:i[o],parent:t,children:(u=i[o].children)&&u.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=u);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Ni(n);var i=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-i):n.z=i}else r&&(n.z=r.z+a(n._,r._));n.parent.A=u(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function u(n,t,e){if(t){for(var r,u=n,i=n,o=t,c=u.parent.children[0],l=u.m,s=i.m,f=o.m,h=c.m;o=Ei(o),u=ki(u),o&&u;)c=ki(c),i=Ei(i),i.a=n,r=o.z+f-u.z-l+a(o._,u._),r>0&&(Ai(Ci(o,n,e),n,r),l+=r,s+=r),f+=o.m,l+=u.m,h+=c.m,s+=i.m;o&&!Ei(i)&&(i.t=o,i.m+=f-s),u&&!ki(c)&&(c.t=u,c.m+=l-h,e=n)}return e}function i(n){n.x*=c[0],n.y=n.depth*c[1]}var o=ta.layout.hierarchy().sort(null).value(null),a=Si,c=[1,1],l=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(l=null==(c=t)?i:null,n):l?null:c},n.nodeSize=function(t){return arguments.length?(l=null==(c=t)?null:i,n):l?c:null},Gu(n,o)},ta.layout.cluster=function(){function n(n,i){var o,a=t.call(this,n,i),c=a[0],l=0;Qu(c,function(n){var t=n.children;t&&t.length?(n.x=qi(t),n.y=zi(t)):(n.x=o?l+=e(n,o):0,n.y=0,o=n)});var s=Li(c),f=Ti(c),h=s.x-e(s,f)/2,g=f.x+e(f,s)/2;return Qu(c,u?function(n){n.x=(n.x-c.x)*r[0],n.y=(c.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(g-h)*r[0],n.y=(1-(c.y?n.y/c.y:1))*r[1]}),a}var t=ta.layout.hierarchy().sort(null).value(null),e=Si,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Gu(n,t)},ta.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var o,a,c,l=f(e),s=[],h=i.slice(),p=1/0,v="slice"===g?l.dx:"dice"===g?l.dy:"slice-dice"===g?1&e.depth?l.dy:l.dx:Math.min(l.dx,l.dy);for(n(h,l.dx*l.dy/e.value),s.area=0;(c=h.length)>0;)s.push(o=h[c-1]),s.area+=o.area,"squarify"!==g||(a=r(s,v))<=p?(h.pop(),p=a):(s.area-=s.pop().area,u(s,v,l,!1),v=Math.min(l.dx,l.dy),s.length=s.area=0,p=1/0);s.length&&(u(s,v,l,!0),s.length=s.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,o=f(t),a=r.slice(),c=[];for(n(a,o.dx*o.dy/t.value),c.area=0;i=a.pop();)c.push(i),c.area+=i.area,null!=i.z&&(u(c,i.z?o.dx:o.dy,o,!a.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,o=n.length,a=e.x,l=e.y,s=t?c(n.area/t):0;if(t==e.dx){for((r||s>e.dy)&&(s=e.dy);++i<o;)u=n[i],u.x=a,u.y=l,u.dy=s,a+=u.dx=Math.min(e.x+e.dx-a,s?c(u.area/s):0);u.z=!0,u.dx+=e.x+e.dx-a,e.y+=s,e.dy-=s}else{for((r||s>e.dx)&&(s=e.dx);++i<o;)u=n[i],u.x=a,u.y=l,u.dx=s,l+=u.dy=Math.min(e.y+e.dy-l,s?c(u.area/s):0);u.z=!1,u.dy+=e.y+e.dy-l,e.x+=s,e.dx-=s}}function i(r){var u=o||a(r),i=u[0];return i.x=0,i.y=0,i.dx=l[0],i.dy=l[1],o&&a.revalue(i),n([i],i.dx*i.dy/i.value),(o?e:t)(i),h&&(o=u),u}var o,a=ta.layout.hierarchy(),c=Math.round,l=[1,1],s=null,f=Ri,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));
	return i.size=function(n){return arguments.length?(l=n,i):l},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?Ri(t):Di(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Di(t,n)}if(!arguments.length)return s;var r;return f=null==(s=n)?Ri:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,o=null,i):h},i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Gu(i,a)},ta.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=2*Math.random()-1,r=2*Math.random()-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=ta.random.normal.apply(ta,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ta.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ta.scale={};var ml={floor:y,ceil:y};ta.scale.linear=function(){return Ii([0,1],[0,1],mu,!1)};var yl={s:1,g:1,p:1,r:1,e:1};ta.scale.log=function(){return Ji(ta.scale.linear().domain([0,1]),10,!0,[1,10])};var Ml=ta.format(".0e"),xl={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ta.scale.pow=function(){return Gi(ta.scale.linear(),1,[0,1])},ta.scale.sqrt=function(){return ta.scale.pow().exponent(.5)},ta.scale.ordinal=function(){return Qi([],{t:"range",a:[[]]})},ta.scale.category10=function(){return ta.scale.ordinal().range(bl)},ta.scale.category20=function(){return ta.scale.ordinal().range(_l)},ta.scale.category20b=function(){return ta.scale.ordinal().range(wl)},ta.scale.category20c=function(){return ta.scale.ordinal().range(Sl)};var bl=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(Mt),_l=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(Mt),wl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(Mt),Sl=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(Mt);ta.scale.quantile=function(){return no([],[])},ta.scale.quantize=function(){return to(0,1,[0,1])},ta.scale.threshold=function(){return eo([.5],[0,1])},ta.scale.identity=function(){return ro([0,1])},ta.svg={},ta.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),l=Math.max(0,+r.apply(this,arguments)),s=o.apply(this,arguments)-Ra,f=a.apply(this,arguments)-Ra,h=Math.abs(f-s),g=s>f?0:1;if(n>l&&(p=l,l=n,n=p),h>=Ta)return t(l,g)+(n?t(n,1-g):"")+"Z";var p,v,d,m,y,M,x,b,_,w,S,k,E=0,A=0,N=[];if((m=(+c.apply(this,arguments)||0)/2)&&(d=i===kl?Math.sqrt(n*n+l*l):+i.apply(this,arguments),g||(A*=-1),l&&(A=tt(d/l*Math.sin(m))),n&&(E=tt(d/n*Math.sin(m)))),l){y=l*Math.cos(s+A),M=l*Math.sin(s+A),x=l*Math.cos(f-A),b=l*Math.sin(f-A);var C=Math.abs(f-s-2*A)<=qa?0:1;if(A&&so(y,M,x,b)===g^C){var z=(s+f)/2;y=l*Math.cos(z),M=l*Math.sin(z),x=b=null}}else y=M=0;if(n){_=n*Math.cos(f-E),w=n*Math.sin(f-E),S=n*Math.cos(s+E),k=n*Math.sin(s+E);var q=Math.abs(s-f+2*E)<=qa?0:1;if(E&&so(_,w,S,k)===1-g^q){var L=(s+f)/2;_=n*Math.cos(L),w=n*Math.sin(L),S=k=null}}else _=w=0;if((p=Math.min(Math.abs(l-n)/2,+u.apply(this,arguments)))>.001){v=l>n^g?0:1;var T=null==S?[_,w]:null==x?[y,M]:Lr([y,M],[S,k],[x,b],[_,w]),R=y-T[0],D=M-T[1],P=x-T[0],U=b-T[1],j=1/Math.sin(Math.acos((R*P+D*U)/(Math.sqrt(R*R+D*D)*Math.sqrt(P*P+U*U)))/2),F=Math.sqrt(T[0]*T[0]+T[1]*T[1]);if(null!=x){var H=Math.min(p,(l-F)/(j+1)),O=fo(null==S?[_,w]:[S,k],[y,M],l,H,g),I=fo([x,b],[_,w],l,H,g);p===H?N.push("M",O[0],"A",H,",",H," 0 0,",v," ",O[1],"A",l,",",l," 0 ",1-g^so(O[1][0],O[1][1],I[1][0],I[1][1]),",",g," ",I[1],"A",H,",",H," 0 0,",v," ",I[0]):N.push("M",O[0],"A",H,",",H," 0 1,",v," ",I[0])}else N.push("M",y,",",M);if(null!=S){var Y=Math.min(p,(n-F)/(j-1)),Z=fo([y,M],[S,k],n,-Y,g),V=fo([_,w],null==x?[y,M]:[x,b],n,-Y,g);p===Y?N.push("L",V[0],"A",Y,",",Y," 0 0,",v," ",V[1],"A",n,",",n," 0 ",g^so(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-g," ",Z[1],"A",Y,",",Y," 0 0,",v," ",Z[0]):N.push("L",V[0],"A",Y,",",Y," 0 0,",v," ",Z[0])}else N.push("L",_,",",w)}else N.push("M",y,",",M),null!=x&&N.push("A",l,",",l," 0 ",C,",",g," ",x,",",b),N.push("L",_,",",w),null!=S&&N.push("A",n,",",n," 0 ",q,",",1-g," ",S,",",k);return N.push("Z"),N.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=io,r=oo,u=uo,i=kl,o=ao,a=co,c=lo;return n.innerRadius=function(t){return arguments.length?(e=Et(t),n):e},n.outerRadius=function(t){return arguments.length?(r=Et(t),n):r},n.cornerRadius=function(t){return arguments.length?(u=Et(t),n):u},n.padRadius=function(t){return arguments.length?(i=t==kl?kl:Et(t),n):i},n.startAngle=function(t){return arguments.length?(o=Et(t),n):o},n.endAngle=function(t){return arguments.length?(a=Et(t),n):a},n.padAngle=function(t){return arguments.length?(c=Et(t),n):c},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Ra;return[Math.cos(t)*n,Math.sin(t)*n]},n};var kl="auto";ta.svg.line=function(){return ho(y)};var El=ta.map({linear:go,"linear-closed":po,step:vo,"step-before":mo,"step-after":yo,basis:So,"basis-open":ko,"basis-closed":Eo,bundle:Ao,cardinal:bo,"cardinal-open":Mo,"cardinal-closed":xo,monotone:To});El.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Al=[0,2/3,1/3,0],Nl=[0,1/3,2/3,0],Cl=[0,1/6,2/3,1/6];ta.svg.line.radial=function(){var n=ho(Ro);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},mo.reverse=yo,yo.reverse=mo,ta.svg.area=function(){return Do(y)},ta.svg.area.radial=function(){var n=Do(Ro);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ta.svg.chord=function(){function n(n,a){var c=t(this,i,n,a),l=t(this,o,n,a);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,l)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,l.r,l.p0)+r(l.r,l.p1,l.a1-l.a0)+u(l.r,l.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=a.call(n,u,r),o=c.call(n,u,r)-Ra,s=l.call(n,u,r)-Ra;return{r:i,a0:o,a1:s,p0:[i*Math.cos(o),i*Math.sin(o)],p1:[i*Math.cos(s),i*Math.sin(s)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>qa)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=mr,o=yr,a=Po,c=ao,l=co;return n.radius=function(t){return arguments.length?(a=Et(t),n):a},n.source=function(t){return arguments.length?(i=Et(t),n):i},n.target=function(t){return arguments.length?(o=Et(t),n):o},n.startAngle=function(t){return arguments.length?(c=Et(t),n):c},n.endAngle=function(t){return arguments.length?(l=Et(t),n):l},n},ta.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),o=e.call(this,n,u),a=(i.y+o.y)/2,c=[i,{x:i.x,y:a},{x:o.x,y:a},o];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=mr,e=yr,r=Uo;return n.source=function(e){return arguments.length?(t=Et(e),n):t},n.target=function(t){return arguments.length?(e=Et(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ta.svg.diagonal.radial=function(){var n=ta.svg.diagonal(),t=Uo,e=n.projection;return n.projection=function(n){return arguments.length?e(jo(t=n)):t},n},ta.svg.symbol=function(){function n(n,r){return(zl.get(t.call(this,n,r))||Oo)(e.call(this,n,r))}var t=Ho,e=Fo;return n.type=function(e){return arguments.length?(t=Et(e),n):t},n.size=function(t){return arguments.length?(e=Et(t),n):e},n};var zl=ta.map({circle:Oo,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Ll)),e=t*Ll;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/ql),e=t*ql/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/ql),e=t*ql/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ta.svg.symbolTypes=zl.keys();var ql=Math.sqrt(3),Ll=Math.tan(30*Da);_a.transition=function(n){for(var t,e,r=Tl||++Ul,u=Xo(n),i=[],o=Rl||{time:Date.now(),ease:Su,delay:0,duration:250},a=-1,c=this.length;++a<c;){i.push(t=[]);for(var l=this[a],s=-1,f=l.length;++s<f;)(e=l[s])&&$o(e,s,u,r,o),t.push(e)}return Yo(i,u,r)},_a.interrupt=function(n){return this.each(null==n?Dl:Io(Xo(n)))};var Tl,Rl,Dl=Io(Xo()),Pl=[],Ul=0;Pl.call=_a.call,Pl.empty=_a.empty,Pl.node=_a.node,Pl.size=_a.size,ta.transition=function(n,t){return n&&n.transition?Tl?n.transition(t):n:ta.selection().transition(n)},ta.transition.prototype=Pl,Pl.select=function(n){var t,e,r,u=this.id,i=this.namespace,o=[];n=N(n);for(var a=-1,c=this.length;++a<c;){o.push(t=[]);for(var l=this[a],s=-1,f=l.length;++s<f;)(r=l[s])&&(e=n.call(r,r.__data__,s,a))?("__data__"in r&&(e.__data__=r.__data__),$o(e,s,i,u,r[i][u]),t.push(e)):t.push(null)}return Yo(o,i,u)},Pl.selectAll=function(n){var t,e,r,u,i,o=this.id,a=this.namespace,c=[];n=C(n);for(var l=-1,s=this.length;++l<s;)for(var f=this[l],h=-1,g=f.length;++h<g;)if(r=f[h]){i=r[a][o],e=n.call(r,r.__data__,h,l),c.push(t=[]);for(var p=-1,v=e.length;++p<v;)(u=e[p])&&$o(u,p,a,o,i),t.push(u)}return Yo(c,a,o)},Pl.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=O(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]);for(var e=this[i],a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return Yo(u,this.namespace,this.id)},Pl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(u){u[r][e].tween.set(n,t)})},Pl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function u(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function i(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?Hu:mu,a=ta.ns.qualify(n);return Zo(this,"attr."+n,t,a.local?i:u)},Pl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=ta.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},Pl.style=function(n,e,r){function u(){this.style.removeProperty(n)}function i(e){return null==e?u:(e+="",function(){var u,i=t(this).getComputedStyle(this,null).getPropertyValue(n);return i!==e&&(u=mu(i,e),function(t){this.style.setProperty(n,u(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Zo(this,"style."+n,e,i)},Pl.styleTween=function(n,e,r){function u(u,i){var o=e.call(this,u,i,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,u)},Pl.text=function(n){return Zo(this,"text",n,Vo)},Pl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Pl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ta.ease.apply(ta,arguments)),Y(this,function(r){r[e][t].ease=n}))},Pl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,u,i){r[e][t].delay=+n.call(r,r.__data__,u,i)}:(n=+n,function(r){r[e][t].delay=n}))},Pl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,u,i){r[e][t].duration=Math.max(1,n.call(r,r.__data__,u,i))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Pl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var u=Rl,i=Tl;try{Tl=e,Y(this,function(t,u,i){Rl=t[r][e],n.call(t,t.__data__,u,i)})}finally{Rl=u,Tl=i}}else Y(this,function(u){var i=u[r][e];(i.event||(i.event=ta.dispatch("start","end","interrupt"))).on(n,t)});return this},Pl.transition=function(){for(var n,t,e,r,u=this.id,i=++Ul,o=this.namespace,a=[],c=0,l=this.length;l>c;c++){a.push(n=[]);for(var t=this[c],s=0,f=t.length;f>s;s++)(e=t[s])&&(r=e[o][u],$o(e,s,o,i,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Yo(a,o,i)},ta.svg.axis=function(){function n(n){n.each(function(){var n,l=ta.select(this),s=this.__chart__||e,f=this.__chart__=e.copy(),h=null==c?f.ticks?f.ticks.apply(f,a):f.domain():c,g=null==t?f.tickFormat?f.tickFormat.apply(f,a):y:t,p=l.selectAll(".tick").data(h,f),v=p.enter().insert("g",".domain").attr("class","tick").style("opacity",Ca),d=ta.transition(p.exit()).style("opacity",Ca).remove(),m=ta.transition(p.order()).style("opacity",1),M=Math.max(u,0)+o,x=Ui(f),b=l.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ta.transition(b));v.append("line"),v.append("text");var w,S,k,E,A=v.select("line"),N=m.select("line"),C=p.select("text").text(g),z=v.select("text"),q=m.select("text"),L="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=Bo,w="x",k="y",S="x2",E="y2",C.attr("dy",0>L?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+L*i+"V0H"+x[1]+"V"+L*i)):(n=Wo,w="y",k="x",S="y2",E="x2",C.attr("dy",".32em").style("text-anchor",0>L?"end":"start"),_.attr("d","M"+L*i+","+x[0]+"H0V"+x[1]+"H"+L*i)),A.attr(E,L*u),z.attr(k,L*M),N.attr(S,0).attr(E,L*u),q.attr(w,0).attr(k,L*M),f.rangeBand){var T=f,R=T.rangeBand()/2;s=f=function(n){return T(n)+R}}else s.rangeBand?s=f:d.call(n,f,s);v.call(n,s,f),m.call(n,f,f)})}var t,e=ta.scale.linear(),r=jl,u=6,i=6,o=3,a=[10],c=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Fl?t+"":jl,n):r},n.ticks=function(){return arguments.length?(a=arguments,n):a},n.tickValues=function(t){return arguments.length?(c=t,n):c},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(u=+t,i=+arguments[e-1],n):u},n.innerTickSize=function(t){return arguments.length?(u=+t,n):u},n.outerTickSize=function(t){return arguments.length?(i=+t,n):i},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var jl="bottom",Fl={top:1,right:1,bottom:1,left:1};ta.svg.brush=function(){function n(t){t.each(function(){var t=ta.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",i).on("touchstart.brush",i),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,y);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return Hl[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var c,f=ta.transition(t),h=ta.transition(o);l&&(c=Ui(l),h.attr("x",c[0]).attr("width",c[1]-c[0]),r(f)),s&&(c=Ui(s),h.attr("y",c[0]).attr("height",c[1]-c[0]),u(f)),e(f)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+f[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",f[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",f[1]-f[0])}function u(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function i(){function i(){32==ta.event.keyCode&&(C||(M=null,q[0]-=f[1],q[1]-=h[1],C=2),S())}function v(){32==ta.event.keyCode&&2==C&&(q[0]+=f[1],q[1]+=h[1],C=0,S())}function d(){var n=ta.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ta.event.altKey?(M||(M=[(f[0]+f[1])/2,(h[0]+h[1])/2]),q[0]=f[+(n[0]<M[0])],q[1]=h[+(n[1]<M[1])]):M=null),A&&m(n,l,0)&&(r(k),t=!0),N&&m(n,s,1)&&(u(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function m(n,t,e){var r,u,i=Ui(t),c=i[0],l=i[1],s=q[e],v=e?h:f,d=v[1]-v[0];return C&&(c-=s,l-=d+s),r=(e?p:g)?Math.max(c,Math.min(l,n[e])):n[e],C?u=(r+=s)+d:(M&&(s=Math.max(c,Math.min(l,2*M[e]-r))),r>s?(u=r,r=s):u=s),v[0]!=r||v[1]!=u?(e?a=null:o=null,v[0]=r,v[1]=u,!0):void 0}function y(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ta.select("body").style("cursor",null),L.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ta.select(ta.event.target),w=c.of(b,arguments),k=ta.select(b),E=_.datum(),A=!/^(n|s)$/.test(E)&&l,N=!/^(e|w)$/.test(E)&&s,C=_.classed("extent"),z=W(b),q=ta.mouse(b),L=ta.select(t(b)).on("keydown.brush",i).on("keyup.brush",v);if(ta.event.changedTouches?L.on("touchmove.brush",d).on("touchend.brush",y):L.on("mousemove.brush",d).on("mouseup.brush",y),k.interrupt().selectAll("*").interrupt(),C)q[0]=f[0]-q[0],q[1]=h[0]-q[1];else if(E){var T=+/w$/.test(E),R=+/^n/.test(E);x=[f[1-T]-q[0],h[1-R]-q[1]],q[0]=f[T],q[1]=h[R]}else ta.event.altKey&&(M=q.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ta.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,c=E(n,"brushstart","brush","brushend"),l=null,s=null,f=[0,0],h=[0,0],g=!0,p=!0,v=Ol[0];return n.event=function(n){n.each(function(){var n=c.of(this,arguments),t={x:f,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Tl?ta.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,f=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=yu(f,t.x),r=yu(h,t.y);return o=a=null,function(u){f=t.x=e(u),h=t.y=r(u),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(l=t,v=Ol[!l<<1|!s],n):l},n.y=function(t){return arguments.length?(s=t,v=Ol[!l<<1|!s],n):s},n.clamp=function(t){return arguments.length?(l&&s?(g=!!t[0],p=!!t[1]):l?g=!!t:s&&(p=!!t),n):l&&s?[g,p]:l?g:s?p:null},n.extent=function(t){var e,r,u,i,c;return arguments.length?(l&&(e=t[0],r=t[1],s&&(e=e[0],r=r[0]),o=[e,r],l.invert&&(e=l(e),r=l(r)),e>r&&(c=e,e=r,r=c),(e!=f[0]||r!=f[1])&&(f=[e,r])),s&&(u=t[0],i=t[1],l&&(u=u[1],i=i[1]),a=[u,i],s.invert&&(u=s(u),i=s(i)),u>i&&(c=u,u=i,i=c),(u!=h[0]||i!=h[1])&&(h=[u,i])),n):(l&&(o?(e=o[0],r=o[1]):(e=f[0],r=f[1],l.invert&&(e=l.invert(e),r=l.invert(r)),e>r&&(c=e,e=r,r=c))),s&&(a?(u=a[0],i=a[1]):(u=h[0],i=h[1],s.invert&&(u=s.invert(u),i=s.invert(i)),u>i&&(c=u,u=i,i=c))),l&&s?[[e,u],[r,i]]:l?[e,r]:s&&[u,i])},n.clear=function(){return n.empty()||(f=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!l&&f[0]==f[1]||!!s&&h[0]==h[1]},ta.rebind(n,c,"on")};var Hl={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Ol=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Il=ac.format=gc.timeFormat,Yl=Il.utc,Zl=Yl("%Y-%m-%dT%H:%M:%S.%LZ");Il.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?Jo:Zl,Jo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},Jo.toString=Zl.toString,ac.second=Ft(function(n){return new cc(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ac.seconds=ac.second.range,ac.seconds.utc=ac.second.utc.range,ac.minute=Ft(function(n){return new cc(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ac.minutes=ac.minute.range,ac.minutes.utc=ac.minute.utc.range,ac.hour=Ft(function(n){var t=n.getTimezoneOffset()/60;return new cc(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ac.hours=ac.hour.range,ac.hours.utc=ac.hour.utc.range,ac.month=Ft(function(n){return n=ac.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ac.months=ac.month.range,ac.months.utc=ac.month.utc.range;var Vl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Xl=[[ac.second,1],[ac.second,5],[ac.second,15],[ac.second,30],[ac.minute,1],[ac.minute,5],[ac.minute,15],[ac.minute,30],[ac.hour,1],[ac.hour,3],[ac.hour,6],[ac.hour,12],[ac.day,1],[ac.day,2],[ac.week,1],[ac.month,1],[ac.month,3],[ac.year,1]],$l=Il.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",Ne]]),Bl={range:function(n,t,e){return ta.range(Math.ceil(n/e)*e,+t,e).map(Ko)},floor:y,ceil:y};Xl.year=ac.year,ac.scale=function(){return Go(ta.scale.linear(),Xl,$l)};var Wl=Xl.map(function(n){return[n[0].utc,n[1]]}),Jl=Yl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",Ne]]);Wl.year=ac.year.utc,ac.scale.utc=function(){return Go(ta.scale.linear(),Wl,Jl)},ta.text=At(function(n){return n.responseText}),ta.json=function(n,t){return Nt(n,"application/json",Qo,t)},ta.html=function(n,t){return Nt(n,"text/html",na,t)},ta.xml=At(function(n){return n.responseXML}),true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (ta), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof module&&module.exports&&(module.exports=ta),this.d3=ta}();

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// File:src/Three.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var THREE = { REVISION: '71' };

	// browserify support

	if ( true ) {

		module.exports = THREE;

	}

	// polyfills

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;

		};

	}


	// set the default log handlers
	THREE.log = function() { console.log.apply( console, arguments ); }
	THREE.warn = function() { console.warn.apply( console, arguments ); }
	THREE.error = function() { console.error.apply( console, arguments ); }


	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	// GL STATE CONSTANTS

	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;

	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;

	// SHADOWING TYPES

	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;

	// MATERIAL CONSTANTS

	// side

	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;

	// shading

	THREE.NoShading = 0;
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;

	// colors

	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;

	// blending modes

	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;

	// custom blending equations
	// (numbers start from 100 not to clash with other
	//  mappings to OpenGL constants defined in Texture.js)

	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;

	// custom blending destination factors

	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;

	// custom blending source factors

	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;


	// TEXTURE CONSTANTS

	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;

	// Mapping modes

	THREE.UVMapping = 300;

	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;

	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;

	THREE.SphericalReflectionMapping = 305;

	// Wrapping modes

	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;

	// Filters

	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;

	// Data types

	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;

	// Pixel types

	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;

	// Pixel formats

	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;

	// DDS / ST3C Compressed texture formats

	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;


	// PVRTC compressed texture formats

	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


	// DEPRECATED

	THREE.Projector = function () {

		THREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			THREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			THREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function ( vector, camera ) {

			THREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	};

	THREE.CanvasRenderer = function () {

		THREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	};

	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function ( color ) {

		if ( arguments.length === 3 ) {

			return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

		}

		return this.set( color )

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value instanceof THREE.Color ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var hue2rgb = function ( p, q, t ) {

					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;

				};

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		},

		setStyle: function ( style ) {

			// rgb(255,0,0)

			if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

				var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

				this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
				this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
				this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

				return this;

			}

			// rgb(100%,0%,0%)

			if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

				var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

				this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
				this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
				this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

				return this;

			}

			// #ff0000

			if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

				var color = /^\#([0-9a-f]{6})$/i.exec( style );

				this.setHex( parseInt( color[ 1 ], 16 ) );

				return this;

			}

			// #f00

			if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

				var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

				this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

				return this;

			}

			// red

			if ( /^(\w+)$/i.test( style ) ) {

				this.setHex( THREE.ColorKeywords[ style ] );

				return this;

			}


		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array ) {

			this.r = array[ 0 ];
			this.g = array[ 1 ];
			this.b = array[ 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;
		},

		clone: function () {

			return new THREE.Color().setRGB( this.r, this.g, this.b );

		}

	};

	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Quaternion = function ( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		_x: 0,_y: 0, _z: 0, _w: 0,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get w () {

			return this._w;

		},

		set w ( value ) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( euler instanceof THREE.Euler === false ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );

			if ( euler.order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( euler.order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( euler.order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( euler.order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function ( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				this.normalize();

				return this;

			}

		}(),

		inverse: function () {

			this.conjugate().normalize();

			return this;

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				THREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		multiplyVector3: function ( vector ) {

			THREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {},

		clone: function () {

			return new THREE.Quaternion( this._x, this._y, this._z, this._w );

		}

	};

	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	}

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function ( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.x *= s;
			this.y *= s;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			return this;
		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );
			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];

			return this;

		},

		clone: function () {

			return new THREE.Vector2( this.x, this.y );

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function ( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},
		
		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function ( euler ) {

				if ( euler instanceof THREE.Euler === false ) {

					THREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromEuler( euler ) );

				return this;

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function ( axis, angle ) {

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				return this;

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

			return this;

		},

		applyProjection: function ( m ) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function ( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );

			};

		}(),

		unproject: function () {

			var matrix;

			return function ( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			this.normalize();

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;

			}

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			return this;

		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength  ) {

				this.multiplyScalar( l / oldLength );
			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function () {

			var v1, dot;

			return function ( vector ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( vector ).normalize();

				dot = this.dot( v1 );

				return this.copy( v1 ).multiplyScalar( dot );

			};

		}(),

		projectOnPlane: function () {

			var v1;

			return function ( planeNormal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			}

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function ( normal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			}

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( this.length() * v.length() );

			// clamp, to handle numerical problems

			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setEulerFromRotationMatrix: function ( m, order ) {

			THREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},

		setEulerFromQuaternion: function ( q, order ) {

			THREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},

		getPositionFromMatrix: function ( m ) {

			THREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

			return this.setFromMatrixPosition( m );

		},

		getScaleFromMatrix: function ( m ) {

			THREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

			return this.setFromMatrixScale( m );
		},

		getColumnFromMatrix: function ( index, matrix ) {

			THREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

			return this.setFromMatrixColumn( index, matrix );

		},

		setFromMatrixPosition: function ( m ) {

			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;
		},

		setFromMatrixColumn: function ( index, matrix ) {
			
			var offset = index * 4;

			var me = matrix.elements;

			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];

			return this;

		},

		clone: function () {

			return new THREE.Vector3( this.x, this.y, this.z );

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				THREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			if ( scalar !== 0 ) {

				var invScalar = 1 / scalar;

				this.x *= invScalar;
				this.y *= invScalar;
				this.z *= invScalar;
				this.w *= invScalar;

			} else {

				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;

			}

			return this;

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				 this.x = 1;
				 this.y = 0;
				 this.z = 0;

			} else {

				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) { // m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else { // m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			if ( this.x > v.x ) {

				this.x = v.x;

			}

			if ( this.y > v.y ) {

				this.y = v.y;

			}

			if ( this.z > v.z ) {

				this.z = v.z;

			}

			if ( this.w > v.w ) {

				this.w = v.w;

			}

			return this;

		},

		max: function ( v ) {

			if ( this.x < v.x ) {

				this.x = v.x;

			}

			if ( this.y < v.y ) {

				this.y = v.y;

			}

			if ( this.z < v.z ) {

				this.z = v.z;

			}

			if ( this.w < v.w ) {

				this.w = v.w;

			}

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			if ( this.x < min.x ) {

				this.x = min.x;

			} else if ( this.x > max.x ) {

				this.x = max.x;

			}

			if ( this.y < min.y ) {

				this.y = min.y;

			} else if ( this.y > max.y ) {

				this.y = max.y;

			}

			if ( this.z < min.z ) {

				this.z = min.z;

			} else if ( this.z > max.z ) {

				this.z = max.z;

			}

			if ( this.w < min.w ) {

				this.w = min.w;

			} else if ( this.w > max.w ) {

				this.w = max.w;

			}

			return this;

		},

		clampScalar: ( function () {

			var min, max;

			return function ( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		} )(),

	  floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

	  },

	  ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

	  },

	  round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

	  },

	  roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

	  },

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( l ) {

			var oldLength = this.length();

			if ( oldLength !== 0 && l !== oldLength ) {

				this.multiplyScalar( l / oldLength );

			}

			return this;

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];

			return this;

		},

		clone: function () {

			return new THREE.Vector4( this.x, this.y, this.z, this.w );

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Euler = function ( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get order () {

			return this._order;

		},

		set order ( value ) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				THREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix;

			return function ( q, order, update ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );

				return this;

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function ( newOrder ) {

				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;
		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new THREE.Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {},

		clone: function () {

			return new THREE.Euler( this._x, this._y, this._z, this._order );

		}

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Line3 = function ( start, end ) {

		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function ( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = THREE.Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		},

		clone: function () {

			return new THREE.Line3().copy( this );

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Box2 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;
		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;
		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;
		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		},

		clone: function () {

			return new THREE.Box2().copy( this );

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and childrens', world transforms

			var v1 = new THREE.Vector3();

			return function ( object ) {

				var scope = this;

				object.updateMatrixWorld( true );

				this.makeEmpty();

				object.traverse( function ( node ) {

					var geometry = node.geometry;

					if ( geometry !== undefined ) {

						if ( geometry instanceof THREE.Geometry ) {

							var vertices = geometry.vertices;

							for ( var i = 0, il = vertices.length; i < il; i ++ ) {

								v1.copy( vertices[ i ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

							var positions = geometry.attributes[ 'position' ].array;

							for ( var i = 0, il = positions.length; i < il; i += 3 ) {

								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				} );

				return this;

			};

		}(),

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function ( matrix ) {

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

				this.makeEmpty();
				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		},

		clone: function () {

			return new THREE.Box3().copy( this );

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array( [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			THREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		copy: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]

			);

			return this;

		},

		multiplyVector3: function ( vector ) {

			THREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},

		multiplyVector3Array: function ( a ) {

			THREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1 = new THREE.Vector3();

			return function ( array, offset, length ) {

				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];

					v1.applyMatrix3( this );

					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;

				}

				return array;

			};

		}(),

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnInvertible ) {

			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )

			var me = matrix.elements;
			var te = this.elements;

			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

			// no inverse

			if ( det === 0 ) {

				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					THREE.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1.0 / det );

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];

			return array;

		},

		getNormalMatrix: function ( m ) {

			// input: THREE.Matrix4

			this.getInverse( m ).transpose();

			return this;

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];

		},

		clone: function () {

			return new THREE.Matrix3().fromArray( this.elements );

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			THREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		copy: function ( m ) {

			this.elements.set( m.elements );

			return this;

		},

		extractPosition: function ( m ) {

			THREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},

		copyPosition: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {
	 
			var te = this.elements;
	 
			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
	 
			return this;
	 		
		},
	 
		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new THREE.Vector3();

			return function ( m ) {

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				THREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		setRotationFromQuaternion: function ( q ) {

			THREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

			return this.makeRotationFromQuaternion( q );

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x = new THREE.Vector3();
			var y = new THREE.Vector3();
			var z = new THREE.Vector3();

			return function ( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target ).normalize();

				if ( z.length() === 0 ) {

					z.z = 1;

				}

				x.crossVectors( up, z ).normalize();

				if ( x.length() === 0 ) {

					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();

				}

				y.crossVectors( z, x );


				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				THREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function ( a, b, r ) {

			var te = this.elements;

			this.multiplyMatrices( a, b );

			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		multiplyVector3: function ( vector ) {

			THREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );

		},

		multiplyVector4: function ( vector ) {

			THREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		multiplyVector3Array: function ( a ) {

			THREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1 = new THREE.Vector3();

			return function ( array, offset, length ) {

				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.x = array[ j ];
					v1.y = array[ j + 1 ];
					v1.z = array[ j + 2 ];

					v1.applyMatrix4( this );

					array[ j ]     = v1.x;
					array[ j + 1 ] = v1.y;
					array[ j + 2 ] = v1.z;

				}

				return array;

			};

		}(),

		rotateAxis: function ( v ) {

			THREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

			v.transformDirection( this );

		},

		crossVector: function ( vector ) {

			THREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset     ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		getPosition: function () {

			var v1 = new THREE.Vector3();

			return function () {

				THREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

			};

		}(),

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnInvertible ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;

			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

			if ( det == 0 ) {

				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					THREE.warn( msg );

				}

				this.identity();

				return this;
			}

			this.multiplyScalar( 1 / det );

			return this;

		},

		translate: function ( v ) {

			THREE.error( 'THREE.Matrix4: .translate() has been removed.' );

		},

		rotateX: function ( angle ) {

			THREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},

		rotateY: function ( angle ) {

			THREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},

		rotateZ: function ( angle ) {

			THREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},

		rotateByAxis: function ( axis, angle ) {

			THREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector = new THREE.Vector3();
			var matrix = new THREE.Matrix4();

			return function ( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {
					sx = - sx;
				}

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part

				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function ( left, right, bottom, top, near, far ) {

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makePerspective: function ( fov, aspect, near, far ) {

			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;

			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;

			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];

		},

		clone: function () {

			return new THREE.Matrix4().fromArray( this.elements );

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Ray = function ( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function ( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceTo( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceTo( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();

			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),


		isIntersectionSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		intersectSphere: function () {

			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

			var v1 = new THREE.Vector3();

			return function ( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );

				var tca = v1.dot( this.direction );

				var d2 = v1.dot( v1 ) - tca * tca;

				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0 
				return this.at( t0, optionalTarget );

			}

		}(),

		isIntersectionPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );
			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) == 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t :  null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;
			}

			return this.at( t, optionalTarget );

		},

		isIntersectionBox: function () {

			var v = new THREE.Vector3();

			return function ( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		}(),

		intersectBox: function ( box, optionalTarget ) {

			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

			var tmin,tmax,tymin,tymax,tzmin,tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function ( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();

			return this;
		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		},

		clone: function () {

			return new THREE.Ray().copy( this );

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function ( center, radius ) {

		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;
		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function ( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).center( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new THREE.Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		},

		clone: function () {

			return new THREE.Sphere().copy( this );

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6 ; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}
				}

				return true;
			};

		}(),


		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		},

		clone: function () {

			return new THREE.Frustum().copy( this );

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Plane = function ( normal, constant ) {

		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function ( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),


		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

		},

		orthoPoint: function ( point, optionalTarget ) {

			var perpendicularMagnitude = this.distanceToPoint( point );

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

		},

		isIntersectionLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function ( line, optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator == 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) == 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),


		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function ( matrix, optionalNormalMatrix ) {

				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );

				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant = this.constant - offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

		},

		clone: function () {

			return new THREE.Plane().copy( this );

		}

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function () {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

						uuid[ i ] = '-';

					} else if ( i == 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}
				}

				return uuid.join( '' );

			};

		}(),

		// Clamp value to range <a, b>

		clamp: function ( x, a, b ) {

			return ( x < a ) ? a : ( ( x > b ) ? b : x );

		},

		// Clamp value to range <a, inf)

		clampBottom: function ( x, a ) {

			return x < a ? a : x;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)

		random16: function () {

			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return Math.floor( this.randFloat( low, high ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function () {

			var degreeToRadiansFactor = Math.PI / 180;

			return function ( degrees ) {

				return degrees * degreeToRadiansFactor;

			};

		}(),

		radToDeg: function () {

			var radianToDegreesFactor = 180 / Math.PI;

			return function ( radians ) {

				return radians * radianToDegreesFactor;

			};

		}(),

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		nextPowerOfTwo: function ( value ) {

			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;

			return value;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function ( points ) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		this.initFromArray = function ( a ) {

			this.points = [];

			for ( var i = 0; i < a.length; i ++ ) {

				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

			}

		};

		this.getPoint = function ( k ) {

			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for ( i = 0; i < l; i ++ ) {

				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function ( nSubDivisions ) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[ 0 ] = 0;

			if ( ! nSubDivisions ) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy( this.points[ 0 ] );

			for ( i = 1; i < nSamples; i ++ ) {

				index = i / nSamples;

				position = this.getPoint( index );
				tmpVec.copy( position );

				totalLength += tmpVec.distanceTo( oldPosition );

				oldPosition.copy( position );

				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );

				if ( intPoint != oldIntPoint ) {

					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[ chunkLengths.length ] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function ( samplingCoef ) {

			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

			for ( i = 1; i < this.points.length; i ++ ) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

				sampling = Math.ceil( samplingCoef * realDistance / sl.total );

				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );

				for ( j = 1; j < sampling - 1; j ++ ) {

					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );

				}

				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		};

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function ( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function ( a, b, c, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}();

	// static/instance method to calculate barycoordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new THREE.Vector3();

			// colinear or singular triangle
			if ( denom == 0 ) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );
			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycoordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function ( point, a, b, c ) {

			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function () {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		},

		clone: function () {

			return new THREE.Triangle().copy( this );

		}

	};

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function ( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

			this.oldTime = this.startTime;
			this.running = true;
		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();

			}

			if ( this.running ) {

				var newTime = self.performance !== undefined && self.performance.now !== undefined
						 ? self.performance.now()
						 : Date.now();

				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () {}

	THREE.EventDispatcher.prototype = {

		constructor: THREE.EventDispatcher,

		apply: function ( object ) {

			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

		},

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

				return true;

			}

			return false;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = [];
				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 * @author stephomi / http://stephaneginier.com/
	 */

	( function ( THREE ) {

		THREE.Raycaster = function ( origin, direction, near, far ) {

			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Sprite: {},
				Mesh: {},
				PointCloud: { threshold: 1 },
				LOD: {},
				Line: {}
			};

		};

		var descSort = function ( a, b ) {

			return a.distance - b.distance;

		};

		var intersectObject = function ( object, raycaster, intersects, recursive ) {

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		};

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			precision: 0.0001,
			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				// camera is assumed _not_ to be a child of a transformed object

				if ( camera instanceof THREE.PerspectiveCamera ) {

					this.ray.origin.copy( camera.position );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();

				} else if ( camera instanceof THREE.OrthographicCamera ) {

					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					THREE.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( descSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( objects instanceof Array === false ) {

					THREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( descSort );

				return intersects;

			}

		};

	}( THREE ) );

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Object3D = function () {

		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = undefined;
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );

		var onRotationChange = function () {
			quaternion.setFromEuler( rotation, false );
		};

		var onQuaternionChange = function () {
			rotation.setFromQuaternion( quaternion, undefined, false );
		};

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			}
		} );

		this.rotationAutoUpdate = true;

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = true;
		this.matrixWorldNeedsUpdate = false;

		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

	THREE.Object3D.prototype = {

		constructor: THREE.Object3D,

		get eulerOrder () {

			THREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			return this.rotation.order;

		},

		set eulerOrder ( value ) {

			THREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

			this.rotation.order = value;

		},

		get useQuaternion () {

			THREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set useQuaternion ( value ) {

			THREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function ( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			}

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function ( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			}

		}(),

		translate: function ( distance, axis ) {

			THREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},

		translateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				m1.lookAt( vector, this.position, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			};

			if ( object === this ) {

				THREE.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( object instanceof THREE.Object3D ) {

				if ( object.parent !== undefined ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				THREE.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

			};

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = undefined;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

		},

		getChildByName: function ( name ) {

			THREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			}

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			}

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			}

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			}

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			if ( this.parent ) {

				callback( this.parent );

				this.parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate === true ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate === true || force === true ) {

				if ( this.parent === undefined ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.3,
					type: 'Object',
					generator: 'ObjectExporter'
				}
			};

			//

			var geometries = {};

			var parseGeometry = function ( geometry ) {

				if ( output.geometries === undefined ) {

					output.geometries = [];

				}

				if ( geometries[ geometry.uuid ] === undefined ) {

					var json = geometry.toJSON();

					delete json.metadata;

					geometries[ geometry.uuid ] = json;

					output.geometries.push( json );

				}

				return geometry.uuid;

			};

			//

			var materials = {};

			var parseMaterial = function ( material ) {

				if ( output.materials === undefined ) {

					output.materials = [];

				}

				if ( materials[ material.uuid ] === undefined ) {

					var json = material.toJSON();

					delete json.metadata;

					materials[ material.uuid ] = json;

					output.materials.push( json );

				}

				return material.uuid;

			};

			//

			var parseObject = function ( object ) {

				var data = {};

				data.uuid = object.uuid;
				data.type = object.type;

				if ( object.name !== '' ) data.name = object.name;
				if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
				if ( object.visible !== true ) data.visible = object.visible;

				if ( object instanceof THREE.PerspectiveCamera ) {

					data.fov = object.fov;
					data.aspect = object.aspect;
					data.near = object.near;
					data.far = object.far;

				} else if ( object instanceof THREE.OrthographicCamera ) {

					data.left = object.left;
					data.right = object.right;
					data.top = object.top;
					data.bottom = object.bottom;
					data.near = object.near;
					data.far = object.far;

				} else if ( object instanceof THREE.AmbientLight ) {

					data.color = object.color.getHex();

				} else if ( object instanceof THREE.DirectionalLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;

				} else if ( object instanceof THREE.PointLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.decay = object.decay;

				} else if ( object instanceof THREE.SpotLight ) {

					data.color = object.color.getHex();
					data.intensity = object.intensity;
					data.distance = object.distance;
					data.angle = object.angle;
					data.exponent = object.exponent;
					data.decay = object.decay;

				} else if ( object instanceof THREE.HemisphereLight ) {

					data.color = object.color.getHex();
					data.groundColor = object.groundColor.getHex();

				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

					data.geometry = parseGeometry( object.geometry );
					data.material = parseMaterial( object.material );

					if ( object instanceof THREE.Line ) data.mode = object.mode;

				} else if ( object instanceof THREE.Sprite ) {

					data.material = parseMaterial( object.material );

				}

				data.matrix = object.matrix.toArray();

				if ( object.children.length > 0 ) {

					data.children = [];

					for ( var i = 0; i < object.children.length; i ++ ) {

						data.children.push( parseObject( object.children[ i ] ) );

					}

				}

				return data;

			}

			output.object = parseObject( this );

			return output;

		},

		clone: function ( object, recursive ) {

			if ( object === undefined ) object = new THREE.Object3D();
			if ( recursive === undefined ) recursive = true;

			object.name = this.name;

			object.up.copy( this.up );

			object.position.copy( this.position );
			object.quaternion.copy( this.quaternion );
			object.scale.copy( this.scale );

			object.rotationAutoUpdate = this.rotationAutoUpdate;

			object.matrix.copy( this.matrix );
			object.matrixWorld.copy( this.matrixWorld );

			object.matrixAutoUpdate = this.matrixAutoUpdate;
			object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

			object.visible = this.visible;

			object.castShadow = this.castShadow;
			object.receiveShadow = this.receiveShadow;

			object.frustumCulled = this.frustumCulled;

			object.userData = JSON.parse( JSON.stringify( this.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < this.children.length; i ++ ) {

					var child = this.children[ i ];
					object.add( child.clone() );

				}

			}

			return object;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

	THREE.Object3DIdCount = 0;

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];

		this.vertexTangents = [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			var face = new THREE.Face3( this.a, this.b, this.c );

			face.normal.copy( this.normal );
			face.color.copy( this.color );

			face.materialIndex = this.materialIndex;

			for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

				face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

				face.vertexColors[ i ] = this.vertexColors[ i ].clone();

			}

			for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

				face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

			}

			return face;

		}

	};

	// File:src/core/Face4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

		THREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
		return new THREE.Face3( a, b, c, normal, color, materialIndex );

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function ( array, itemSize ) {

		this.array = array;
		this.itemSize = itemSize;

		this.needsUpdate = false;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get length () {

			return this.array.length;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index     ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		clone: function () {

			return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

		}

	};

	//

	THREE.Int8Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint8Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );


	};

	THREE.Int16Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint16Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Int32Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Uint32Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Float32Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	THREE.Float64Attribute = function ( data, itemSize ) {

		THREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
		return new THREE.BufferAttribute( data, itemSize );

	};

	// File:src/core/DynamicBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DynamicBufferAttribute = function ( array, itemSize ) {

		THREE.BufferAttribute.call( this, array, itemSize );

		this.updateRange = { offset: 0, count: -1 };

	};

	THREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;

	THREE.DynamicBufferAttribute.prototype.clone = function () {

		return new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );

	};

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.attributes = {};
		this.attributesKeys = [];

		this.drawcalls = [];
		this.offsets = this.drawcalls; // backwards compatibility

		this.boundingBox = null;
		this.boundingSphere = null;

	};

	THREE.BufferGeometry.prototype = {

		constructor: THREE.BufferGeometry,

		addAttribute: function ( name, attribute ) {

			if ( attribute instanceof THREE.BufferAttribute === false ) {

				THREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

				return;

			}

			this.attributes[ name ] = attribute;
			this.attributesKeys = Object.keys( this.attributes );

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		addDrawCall: function ( start, count, indexOffset ) {

			this.drawcalls.push( {

				start: start,
				count: count,
				index: indexOffset !== undefined ? indexOffset : 0

			} );

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

			return offset;

		},

		fromGeometry: function ( geometry, settings ) {

			settings = settings || { 'vertexColors': THREE.NoColors };

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs;
			var vertexColors = settings.vertexColors;
			var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

			var positions = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

			var normals = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

			if ( vertexColors !== THREE.NoColors ) {

				var colors = new Float32Array( faces.length * 3 * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

			}

			if ( hasFaceVertexUv === true ) {

				var uvs = new Float32Array( faces.length * 3 * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

			}

			for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

				var face = faces[ i ];

				var a = vertices[ face.a ];
				var b = vertices[ face.b ];
				var c = vertices[ face.c ];

				positions[ i3     ] = a.x;
				positions[ i3 + 1 ] = a.y;
				positions[ i3 + 2 ] = a.z;

				positions[ i3 + 3 ] = b.x;
				positions[ i3 + 4 ] = b.y;
				positions[ i3 + 5 ] = b.z;

				positions[ i3 + 6 ] = c.x;
				positions[ i3 + 7 ] = c.y;
				positions[ i3 + 8 ] = c.z;

				if ( hasFaceVertexNormals === true ) {

					var na = face.vertexNormals[ 0 ];
					var nb = face.vertexNormals[ 1 ];
					var nc = face.vertexNormals[ 2 ];

					normals[ i3     ] = na.x;
					normals[ i3 + 1 ] = na.y;
					normals[ i3 + 2 ] = na.z;

					normals[ i3 + 3 ] = nb.x;
					normals[ i3 + 4 ] = nb.y;
					normals[ i3 + 5 ] = nb.z;

					normals[ i3 + 6 ] = nc.x;
					normals[ i3 + 7 ] = nc.y;
					normals[ i3 + 8 ] = nc.z;

				} else {

					var n = face.normal;

					normals[ i3     ] = n.x;
					normals[ i3 + 1 ] = n.y;
					normals[ i3 + 2 ] = n.z;

					normals[ i3 + 3 ] = n.x;
					normals[ i3 + 4 ] = n.y;
					normals[ i3 + 5 ] = n.z;

					normals[ i3 + 6 ] = n.x;
					normals[ i3 + 7 ] = n.y;
					normals[ i3 + 8 ] = n.z;

				}

				if ( vertexColors === THREE.FaceColors ) {

					var fc = face.color;

					colors[ i3     ] = fc.r;
					colors[ i3 + 1 ] = fc.g;
					colors[ i3 + 2 ] = fc.b;

					colors[ i3 + 3 ] = fc.r;
					colors[ i3 + 4 ] = fc.g;
					colors[ i3 + 5 ] = fc.b;

					colors[ i3 + 6 ] = fc.r;
					colors[ i3 + 7 ] = fc.g;
					colors[ i3 + 8 ] = fc.b;

				} else if ( vertexColors === THREE.VertexColors ) {

					var vca = face.vertexColors[ 0 ];
					var vcb = face.vertexColors[ 1 ];
					var vcc = face.vertexColors[ 2 ];

					colors[ i3     ] = vca.r;
					colors[ i3 + 1 ] = vca.g;
					colors[ i3 + 2 ] = vca.b;

					colors[ i3 + 3 ] = vcb.r;
					colors[ i3 + 4 ] = vcb.g;
					colors[ i3 + 5 ] = vcb.b;

					colors[ i3 + 6 ] = vcc.r;
					colors[ i3 + 7 ] = vcc.g;
					colors[ i3 + 8 ] = vcc.b;

				}

				if ( hasFaceVertexUv === true ) {

					var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
					var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
					var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

					uvs[ i2     ] = uva.x;
					uvs[ i2 + 1 ] = uva.y;

					uvs[ i2 + 2 ] = uvb.x;
					uvs[ i2 + 3 ] = uvb.y;

					uvs[ i2 + 4 ] = uvc.x;
					uvs[ i2 + 5 ] = uvc.y;

				}

			}

			this.computeBoundingSphere()

			return this;

		},

		computeBoundingBox: function () {

			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new THREE.Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					var bb = this.boundingBox;
					bb.makeEmpty();

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						bb.expandByPoint( vector );

					}

				}

				if ( positions === undefined || positions.length === 0 ) {

					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					THREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

				}

			}

		}(),

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					box.makeEmpty();

					var center = this.boundingSphere.center;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						box.expandByPoint( vector );

					}

					box.center( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						THREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

					}

				}

			}

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var attributes = this.attributes;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var normals = attributes.normal.array;

					for ( var i = 0, il = normals.length; i < il; i ++ ) {

						normals[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),

				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();

				// indexed elements

				if ( attributes.index ) {

					var indices = attributes.index.array;

					var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

					for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

						var start = offsets[ j ].start;
						var count = offsets[ j ].count;
						var index = offsets[ j ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = ( index + indices[ i     ] ) * 3;
							vB = ( index + indices[ i + 1 ] ) * 3;
							vC = ( index + indices[ i + 2 ] ) * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA     ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB     ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC     ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i     ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		computeTangents: function () {

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( this.attributes.index === undefined ||
				 this.attributes.position === undefined ||
				 this.attributes.normal === undefined ||
				 this.attributes.uv === undefined ) {

				THREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
				return;

			}

			var indices = this.attributes.index.array;
			var positions = this.attributes.position.array;
			var normals = this.attributes.normal.array;
			var uvs = this.attributes.uv.array;

			var nVertices = positions.length / 3;

			if ( this.attributes.tangent === undefined ) {

				this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			var tangents = this.attributes.tangent.array;

			var tan1 = [], tan2 = [];

			for ( var k = 0; k < nVertices; k ++ ) {

				tan1[ k ] = new THREE.Vector3();
				tan2[ k ] = new THREE.Vector3();

			}

			var vA = new THREE.Vector3(),
				vB = new THREE.Vector3(),
				vC = new THREE.Vector3(),

				uvA = new THREE.Vector2(),
				uvB = new THREE.Vector2(),
				uvC = new THREE.Vector2(),

				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r;

			var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;

				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;

				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;

				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;

				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;

				r = 1.0 / ( s1 * t2 - s2 * t1 );

				sdir.set(
					( t2 * x1 - t1 * x2 ) * r,
					( t2 * y1 - t1 * y2 ) * r,
					( t2 * z1 - t1 * z2 ) * r
				);

				tdir.set(
					( s1 * x2 - s2 * x1 ) * r,
					( s1 * y2 - s2 * y1 ) * r,
					( s1 * z2 - s2 * z1 ) * r
				);

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			var i, il;
			var j, jl;
			var iA, iB, iC;

			if ( this.drawcalls.length === 0 ) {

				this.addDrawCall( 0, indices.length, 0 );

			}

			var drawcalls = this.drawcalls;

			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;

				for ( i = start, il = start + count; i < il; i += 3 ) {

					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];

					handleTriangle( iA, iB, iC );

				}

			}

			var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
			var n = new THREE.Vector3(), n2 = new THREE.Vector3();
			var w, t, test;

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				test = tmp2.dot( tan2[ v ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4     ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

				var start = drawcalls[ j ].start;
				var count = drawcalls[ j ].count;
				var index = drawcalls[ j ].index;

				for ( i = start, il = start + count; i < il; i += 3 ) {

					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];

					handleVertex( iA );
					handleVertex( iB );
					handleVertex( iC );

				}

			}

		},

		/*
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		size - Defaults to 65535, but allows for larger or smaller chunks.
		*/
		computeOffsets: function ( size ) {

			if ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.

			var indices = this.attributes.index.array;
			var vertices = this.attributes.position.array;

			var facesCount = ( indices.length / 3 );

			/*
			console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
			console.log("Faces to process: "+(indices.length/3));
			console.log("Reordering "+verticesCount+" vertices.");
			*/

			var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
			var indexPtr = 0;
			var vertexPtr = 0;

			var offsets = [ { start:0, count:0, index:0 } ];
			var offset = offsets[ 0 ];

			var duplicatedVertices = 0;
			var newVerticeMaps = 0;
			var faceVertices = new Int32Array( 6 );
			var vertexMap = new Int32Array( vertices.length );
			var revVertexMap = new Int32Array( vertices.length );
			for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

			/*
				Traverse every face and reorder vertices in the proper offsets of 65k.
				We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
			*/
			for ( var findex = 0; findex < facesCount; findex ++ ) {
				newVerticeMaps = 0;

				for ( var vo = 0; vo < 3; vo ++ ) {
					var vid = indices[ findex * 3 + vo ];
					if ( vertexMap[ vid ] == - 1 ) {
						//Unmapped vertice
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						newVerticeMaps ++;
					} else if ( vertexMap[ vid ] < offset.index ) {
						//Reused vertices from previous block (duplicate)
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = - 1;
						duplicatedVertices ++;
					} else {
						//Reused vertice in the current block
						faceVertices[ vo * 2 ] = vid;
						faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
					}
				}

				var faceMax = vertexPtr + newVerticeMaps;
				if ( faceMax > ( offset.index + size ) ) {
					var new_offset = { start:indexPtr, count:0, index:vertexPtr };
					offsets.push( new_offset );
					offset = new_offset;

					//Re-evaluate reused vertices in light of new offset.
					for ( var v = 0; v < 6; v += 2 ) {
						var new_vid = faceVertices[ v + 1 ];
						if ( new_vid > - 1 && new_vid < offset.index )
							faceVertices[ v + 1 ] = - 1;
					}
				}

				//Reindex the face.
				for ( var v = 0; v < 6; v += 2 ) {
					var vid = faceVertices[ v ];
					var new_vid = faceVertices[ v + 1 ];

					if ( new_vid === - 1 )
						new_vid = vertexPtr ++;

					vertexMap[ vid ] = new_vid;
					revVertexMap[ new_vid ] = vid;
					sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
					offset.count ++;
				}
			}

			/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
			this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
			this.offsets = offsets; // TODO: Deprecate
			this.drawcalls = offsets;

			/*
			var orderTime = Date.now();
			console.log("Reorder time: "+(orderTime-s)+"ms");
			console.log("Duplicated "+duplicatedVertices+" vertices.");
			console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
			console.log("Draw offsets: "+offsets.length);
			*/

			return offsets;

		},

		merge: function ( geometry, offset ) {

			if ( geometry instanceof THREE.BufferGeometry === false ) {

				THREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for ( var i = 0, il = normals.length; i < il; i += 3 ) {

				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];

				n = 1.0 / Math.sqrt( x * x + y * y + z * z );

				normals[ i     ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;

			}

		},

		/*
			reoderBuffers:
			Reorder attributes based on a new indexBuffer and indexMap.
			indexBuffer - Uint16Array of the new ordered indices.
			indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
			vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
		*/
		reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

			/* Create a copy of all attributes for reordering. */
			var sortedAttributes = {};
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var sourceArray = this.attributes[ attr ].array;
				sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
			}

			/* Move attribute positions based on the new index map */
			for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
				var vid = indexMap[ new_vid ];
				for ( var attr in this.attributes ) {
					if ( attr == 'index' )
						continue;
					var attrArray = this.attributes[ attr ].array;
					var attrSize = this.attributes[ attr ].itemSize;
					var sortedAttr = sortedAttributes[ attr ];
					for ( var k = 0; k < attrSize; k ++ )
						sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
				}
			}

			/* Carry the new sorted buffers locally */
			this.attributes[ 'index' ].array = indexBuffer;
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				this.attributes[ attr ].array = sortedAttributes[ attr ];
				this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
			}
		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type,
				data: {
					attributes: {}
				}
			};

			var attributes = this.attributes;
			var offsets = this.offsets;
			var boundingSphere = this.boundingSphere;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				output.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				}

			}

			if ( offsets.length > 0 ) {

				output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

			}

			if ( boundingSphere !== null ) {

				output.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				}

			}

			return output;

		},

		clone: function () {

			var geometry = new THREE.BufferGeometry();

			for ( var attr in this.attributes ) {

				var sourceAttr = this.attributes[ attr ];
				geometry.addAttribute( attr, sourceAttr.clone() );

			}

			for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

				var offset = this.offsets[ i ];

				geometry.offsets.push( {

					start: offset.start,
					index: offset.index,
					count: offset.count

				} );

			}

			return geometry;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */

	THREE.Geometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];  // one-to-one vertex colors, used in Points and Line

		this.faces = [];

		this.faceVertexUvs = [ [] ];

		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.hasTangents = false;

		this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.tangentsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;

		this.groupsNeedUpdate = false;

	};

	THREE.Geometry.prototype = {

		constructor: THREE.Geometry,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

		},

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var attributes = geometry.attributes;

			var vertices = attributes.position.array;
			var indices = attributes.index !== undefined ? attributes.index.array : undefined;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

			var tempNormals = [];
			var tempUVs = [];

			for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

			}

			var addFace = function ( a, b, c ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

			};

			if ( indices !== undefined ) {

				var drawcalls = geometry.drawcalls;

				if ( drawcalls.length > 0 ) {

					for ( var i = 0; i < drawcalls.length; i ++ ) {

						var drawcall = drawcalls[ i ];

						var start = drawcall.start;
						var count = drawcall.count;
						var index = drawcall.index;

						for ( var j = start, jl = start + count; j < jl; j += 3 ) {

							addFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < vertices.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

			return offset;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
				face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
				face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			// based on http://www.terathon.com/code/tangent.html
			// tangents go to vertices

			var f, fl, v, vl, i, vertexIndex,
				face, uv, vA, vB, vC, uvA, uvB, uvC,
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r, t, test,
				tan1 = [], tan2 = [],
				sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
				tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
				n = new THREE.Vector3(), w;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				tan1[ v ] = new THREE.Vector3();
				tan2[ v ] = new THREE.Vector3();

			}

			function handleTriangle( context, a, b, c, ua, ub, uc ) {

				vA = context.vertices[ a ];
				vB = context.vertices[ b ];
				vC = context.vertices[ c ];

				uvA = uv[ ua ];
				uvB = uv[ ub ];
				uvC = uv[ uc ];

				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;

				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;

				r = 1.0 / ( s1 * t2 - s2 * t1 );
				sdir.set( ( t2 * x1 - t1 * x2 ) * r,
						  ( t2 * y1 - t1 * y2 ) * r,
						  ( t2 * z1 - t1 * z2 ) * r );
				tdir.set( ( s1 * x2 - s2 * x1 ) * r,
						  ( s1 * y2 - s2 * y1 ) * r,
						  ( s1 * z2 - s2 * z1 ) * r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];
				uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

			}

			var faceIndex = [ 'a', 'b', 'c', 'd' ];

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

					n.copy( face.vertexNormals[ i ] );

					vertexIndex = face[ faceIndex[ i ] ];

					t = tan1[ vertexIndex ];

					// Gram-Schmidt orthogonalize

					tmp.copy( t );
					tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

					// Calculate handedness

					tmp2.crossVectors( face.vertexNormals[ i ], t );
					test = tmp2.dot( tan2[ vertexIndex ] );
					w = ( test < 0.0 ) ? - 1.0 : 1.0;

					face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

				}

			}

			this.hasTangents = true;

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( geometry instanceof THREE.Geometry === false ) {

				THREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( mesh instanceof THREE.Mesh === false ) {

				THREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			};


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
					if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}
				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.0,
					type: 'BufferGeometry',
					generator: 'BufferGeometryExporter'
				},
				uuid: this.uuid,
				type: this.type
			};

			if ( this.name !== "" ) output.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

				}

				return output;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );


				/*
				if ( hasMaterial ) {

					faces.push( face.materialIndex );

				}
				*/

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			output.data = {};

			output.data.vertices = vertices;
			output.data.normals = normals;
			if ( colors.length > 0 ) output.data.colors = colors;
			if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
			output.data.faces = faces;

			//

			return output;

		},

		clone: function () {

			var geometry = new THREE.Geometry();

			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				geometry.vertices.push( vertices[ i ].clone() );

			}

			var faces = this.faces;

			for ( var i = 0, il = faces.length; i < il; i ++ ) {

				geometry.faces.push( faces[ i ].clone() );

			}

			for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = this.faceVertexUvs[ i ];

				if ( geometry.faceVertexUvs[ i ] === undefined ) {

					geometry.faceVertexUvs[ i ] = [];

				}

				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					geometry.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			return geometry;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

	THREE.GeometryIdCount = 0;

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		}

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( this.position, vector, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}();

	THREE.Camera.prototype.clone = function ( camera ) {

		if ( camera === undefined ) camera = new THREE.Camera();

		THREE.Object3D.prototype.clone.call( this, camera );

		camera.matrixWorldInverse.copy( this.matrixWorldInverse );
		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;
	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function ( near, far, cubeResolution ) {

		THREE.Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

		this.updateCubeMap = function ( renderer, scene ) {

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;

			renderTarget.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

		};

	};

	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

		THREE.Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

	};

	THREE.OrthographicCamera.prototype.clone = function () {

		var camera = new THREE.OrthographicCamera();

		THREE.Camera.prototype.clone.call( this, camera );

		camera.zoom = this.zoom;

		camera.left = this.left;
		camera.right = this.right;
		camera.top = this.top;
		camera.bottom = this.bottom;

		camera.near = this.near;
		camera.far = this.far;

		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;
	};

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

		THREE.Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.zoom = 1;

		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (fullframe) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */

	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

		if ( frameHeight === undefined ) frameHeight = 24;

		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();

	}


	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.updateProjectionMatrix();

	};


	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

		if ( this.fullWidth ) {

			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );

			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);

		} else {

			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

		}

	};

	THREE.PerspectiveCamera.prototype.clone = function () {

		var camera = new THREE.PerspectiveCamera();

		THREE.Camera.prototype.clone.call( this, camera );

		camera.zoom = this.zoom;

		camera.fov = this.fov;
		camera.aspect = this.aspect;
		camera.near = this.near;
		camera.far = this.far;

		camera.projectionMatrix.copy( this.projectionMatrix );

		return camera;

	};

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function ( color ) {

		THREE.Object3D.call( this );

		this.type = 'Light';
		
		this.color = new THREE.Color( color );

	};

	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;

	THREE.Light.prototype.clone = function ( light ) {

		if ( light === undefined ) light = new THREE.Light();

		THREE.Object3D.prototype.clone.call( this, light );

		light.color.copy( this.color );

		return light;

	};

	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function ( color ) {

		THREE.Light.call( this, color );

		this.type = 'AmbientLight';

	};

	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

	THREE.AmbientLight.prototype.clone = function () {

		var light = new THREE.AmbientLight();

		THREE.Light.prototype.clone.call( this, light );

		return light;

	};

	// File:src/lights/AreaLight.js

	/**
	 * @author MPanknin / http://www.redplant.de/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.AreaLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'AreaLight';

		this.normal = new THREE.Vector3( 0, - 1, 0 );
		this.right = new THREE.Vector3( 1, 0, 0 );

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.width = 1.0;
		this.height = 1.0;

		this.constantAttenuation = 1.5;
		this.linearAttenuation = 0.5;
		this.quadraticAttenuation = 0.1;

	};

	THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AreaLight.prototype.constructor = THREE.AreaLight;


	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'DirectionalLight';

		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.castShadow = false;
		this.onlyShadow = false;

		//

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;

		this.shadowCameraLeft = - 500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = - 500;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		//

		this.shadowCascade = false;

		this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
		this.shadowCascadeCount = 2;

		this.shadowCascadeBias = [ 0, 0, 0 ];
		this.shadowCascadeWidth = [ 512, 512, 512 ];
		this.shadowCascadeHeight = [ 512, 512, 512 ];

		this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
		this.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];

		this.shadowCascadeArray = [];

		//

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

	THREE.DirectionalLight.prototype.clone = function () {

		var light = new THREE.DirectionalLight();

		THREE.Light.prototype.clone.call( this, light );

		light.target = this.target.clone();

		light.intensity = this.intensity;

		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;

		//

		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;

		light.shadowCameraLeft = this.shadowCameraLeft;
		light.shadowCameraRight = this.shadowCameraRight;
		light.shadowCameraTop = this.shadowCameraTop;
		light.shadowCameraBottom = this.shadowCameraBottom;

		light.shadowCameraVisible = this.shadowCameraVisible;

		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;

		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;

		//

		light.shadowCascade = this.shadowCascade;

		light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
		light.shadowCascadeCount = this.shadowCascadeCount;

		light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
		light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
		light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

		light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
		light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

		return light;

	};

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

		THREE.Light.call( this, skyColor );

		this.type = 'HemisphereLight';

		this.position.set( 0, 100, 0 );

		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;

	};

	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

	THREE.HemisphereLight.prototype.clone = function () {

		var light = new THREE.HemisphereLight();

		THREE.Light.prototype.clone.call( this, light );

		light.groundColor.copy( this.groundColor );
		light.intensity = this.intensity;

		return light;

	};

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLight = function ( color, intensity, distance, decay ) {

		THREE.Light.call( this, color );

		this.type = 'PointLight';

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	};

	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;

	THREE.PointLight.prototype.clone = function () {

		var light = new THREE.PointLight();

		THREE.Light.prototype.clone.call( this, light );

		light.intensity = this.intensity;
		light.distance = this.distance;
		light.decay = this.decay;

		return light;

	};

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

		THREE.Light.call( this, color );

		this.type = 'SpotLight';

		this.position.set( 0, 1, 0 );
		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.castShadow = false;
		this.onlyShadow = false;

		//

		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;

		this.shadowCameraVisible = false;

		this.shadowBias = 0;
		this.shadowDarkness = 0.5;

		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;

		//

		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;

	};

	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;

	THREE.SpotLight.prototype.clone = function () {

		var light = new THREE.SpotLight();

		THREE.Light.prototype.clone.call( this, light );

		light.target = this.target.clone();

		light.intensity = this.intensity;
		light.distance = this.distance;
		light.angle = this.angle;
		light.exponent = this.exponent;
		light.decay = this.decay;

		light.castShadow = this.castShadow;
		light.onlyShadow = this.onlyShadow;

		//

		light.shadowCameraNear = this.shadowCameraNear;
		light.shadowCameraFar = this.shadowCameraFar;
		light.shadowCameraFov = this.shadowCameraFov;

		light.shadowCameraVisible = this.shadowCameraVisible;

		light.shadowBias = this.shadowBias;
		light.shadowDarkness = this.shadowDarkness;

		light.shadowMapWidth = this.shadowMapWidth;
		light.shadowMapHeight = this.shadowMapHeight;

		return light;

	};

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = {

		files: {},

		add: function ( key, file ) {

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {}

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function ( showStatus ) {

		this.showStatus = showStatus;
		this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

		this.imageLoader = new THREE.ImageLoader();

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		addStatusElement: function () {

			var e = document.createElement( 'div' );

			e.style.position = 'absolute';
			e.style.right = '0px';
			e.style.top = '0px';
			e.style.fontSize = '0.8em';
			e.style.textAlign = 'left';
			e.style.background = 'rgba(0,0,0,0.25)';
			e.style.color = '#fff';
			e.style.width = '120px';
			e.style.padding = '0.5em 0.5em 0.5em 0.5em';
			e.style.zIndex = 1000;

			e.innerHTML = 'Loading ...';

			return e;

		},

		updateProgress: function ( progress ) {

			var message = 'Loaded ';

			if ( progress.total ) {

				message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


			} else {

				message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

			}

			this.statusDomElement.innerHTML = message;

		},

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		},

		initMaterials: function ( materials, texturePath ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath );

			}

			return array;

		},

		needsTangents: function ( materials ) {

			for ( var i = 0, il = materials.length; i < il; i ++ ) {

				var m = materials[ i ];

				if ( m instanceof THREE.ShaderMaterial ) return true;

			}

			return false;

		},

		createMaterial: function ( m, texturePath ) {

			var scope = this;

			function nearest_pow2( n ) {

				var l = Math.log( n ) / Math.LN2;
				return Math.pow( 2, Math.round(  l ) );

			}

			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + sourceFile;

				var texture;

				var loader = THREE.Loader.Handlers.get( fullPath );

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					texture = new THREE.Texture();

					loader = scope.imageLoader;
					loader.crossOrigin = scope.crossOrigin;
					loader.load( fullPath, function ( image ) {

						if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
							 THREE.Math.isPowerOfTwo( image.height ) === false ) {

							var width = nearest_pow2( image.width );
							var height = nearest_pow2( image.height );

							var canvas = document.createElement( 'canvas' );
							canvas.width = width;
							canvas.height = height;

							var context = canvas.getContext( '2d' );
							context.drawImage( image, 0, 0, width, height );

							texture.image = canvas;

						} else {

							texture.image = image;

						}

						texture.needsUpdate = true;

					} );

				}

				texture.sourceFile = sourceFile;

				if ( repeat ) {

					texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset ) {

					texture.offset.set( offset[ 0 ], offset[ 1 ] );

				}

				if ( wrap ) {

					var wrapMap = {
						'repeat': THREE.RepeatWrapping,
						'mirror': THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

				}

				if ( anisotropy ) {

					texture.anisotropy = anisotropy;

				}

				where[ name ] = texture;

			}

			function rgb2hex( rgb ) {

				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

			}

			// defaults

			var mtype = 'MeshLambertMaterial';
			var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

			// parameters from model file

			if ( m.shading ) {

				var shading = m.shading.toLowerCase();

				if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
				else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

			}

			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

				mpars.blending = THREE[ m.blending ];

			}

			if ( m.transparent !== undefined ) {

				mpars.transparent = m.transparent;

			}

			if ( m.opacity !== undefined && m.opacity < 1.0 ) {

				mpars.transparent = true;

			}

			if ( m.depthTest !== undefined ) {

				mpars.depthTest = m.depthTest;

			}

			if ( m.depthWrite !== undefined ) {

				mpars.depthWrite = m.depthWrite;

			}

			if ( m.visible !== undefined ) {

				mpars.visible = m.visible;

			}

			if ( m.flipSided !== undefined ) {

				mpars.side = THREE.BackSide;

			}

			if ( m.doubleSided !== undefined ) {

				mpars.side = THREE.DoubleSide;

			}

			if ( m.wireframe !== undefined ) {

				mpars.wireframe = m.wireframe;

			}

			if ( m.vertexColors !== undefined ) {

				if ( m.vertexColors === 'face' ) {

					mpars.vertexColors = THREE.FaceColors;

				} else if ( m.vertexColors ) {

					mpars.vertexColors = THREE.VertexColors;

				}

			}

			// colors

			if ( m.colorDiffuse ) {

				mpars.color = rgb2hex( m.colorDiffuse );

			} else if ( m.DbgColor ) {

				mpars.color = m.DbgColor;

			}

			if ( m.colorSpecular ) {

				mpars.specular = rgb2hex( m.colorSpecular );

			}

			if ( m.colorEmissive ) {

				mpars.emissive = rgb2hex( m.colorEmissive );

			}

			// modifiers

			if ( m.transparency !== undefined ) {

				console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
				m.opacity = m.transparency;

			}

			if ( m.opacity !== undefined ) {

				mpars.opacity = m.opacity;

			}

			if ( m.specularCoef ) {

				mpars.shininess = m.specularCoef;

			}

			// textures

			if ( m.mapDiffuse && texturePath ) {

				create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

			}

			if ( m.mapLight && texturePath ) {

				create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

			}

			if ( m.mapBump && texturePath ) {

				create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

			}

			if ( m.mapNormal && texturePath ) {

				create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

			}

			if ( m.mapSpecular && texturePath ) {

				create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

			}

			if ( m.mapAlpha && texturePath ) {

				create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

			}

			//

			if ( m.mapBumpScale ) {

				mpars.bumpScale = m.mapBumpScale;

			}

			if ( m.mapNormalFactor ) {

				mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

			}

			var material = new THREE[ mtype ]( mpars );

			if ( m.DbgName !== undefined ) material.name = m.DbgName;

			return material;

		}

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

				var regex = this.handlers[ i ];
				var loader  = this.handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.XHRLoader.prototype = {

		constructor: THREE.XHRLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) onLoad( cached );
				return;

			}

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this.response );

				if ( onLoad ) onLoad( this.response );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			if ( onError !== undefined ) {

				request.addEventListener( 'error', function ( event ) {

					onError( event );

				}, false );

			}

			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;

			request.send( null );

			scope.manager.itemStart( url );

		},

		setResponseType: function ( value ) {

			this.responseType = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ImageLoader.prototype = {

		constructor: THREE.ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				onLoad( cached );
				return;

			}

			var image = document.createElement( 'img' );

			image.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this );

				if ( onLoad ) onLoad( this );
				
				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				image.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			if ( onError !== undefined ) {

				image.addEventListener( 'error', function ( event ) {

					onError( event );

				}, false );

			}

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			image.src = url;

			scope.manager.itemStart( url );

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	}

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function ( showStatus ) {

		THREE.Loader.call( this, showStatus );

		this.withCredentials = false;

	};

	THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
	THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;

	THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

		// todo: unify load API to for easier SceneLoader use

		texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

		this.onLoadStart();
		this.loadAjaxJSON( this, url, callback, texturePath );

	};

	THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

		var xhr = new XMLHttpRequest();

		var length = 0;

		xhr.onreadystatechange = function () {

			if ( xhr.readyState === xhr.DONE ) {

				if ( xhr.status === 200 || xhr.status === 0 ) {

					if ( xhr.responseText ) {

						var json = JSON.parse( xhr.responseText );
						var metadata = json.metadata;

						if ( metadata !== undefined ) {

							if ( metadata.type === 'object' ) {

								THREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;

							}

							if ( metadata.type === 'scene' ) {

								THREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );
								return;

							}

						}

						var result = context.parse( json, texturePath );
						callback( result.geometry, result.materials );

					} else {

						THREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );

					}

					// in context of more complex asset initialization
					// do not block on single failed file
					// maybe should go even one more level up

					context.onLoadComplete();

				} else {

					THREE.error( 'THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')' );

				}

			} else if ( xhr.readyState === xhr.LOADING ) {

				if ( callbackProgress ) {

					if ( length === 0 ) {

						length = xhr.getResponseHeader( 'Content-Length' );

					}

					callbackProgress( { total: length, loaded: xhr.responseText.length } );

				}

			} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

				if ( callbackProgress !== undefined ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

			}

		};

		xhr.open( 'GET', url, true );
		xhr.withCredentials = this.withCredentials;
		xhr.send( null );

	};

	THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = []

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {
			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i     ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i     ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				THREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}


			// could change this to json.animations[0] or remove completely

			geometry.animation = json.animation;
			geometry.animations = json.animations;

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				var i, l, v, vl, dstVertices, srcVertices;

				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					dstVertices = geometry.morphTargets[ i ].vertices;
					srcVertices = json.morphTargets [ i ].vertices;

					for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined ) {

				var i, l, c, cl, dstColors, srcColors, color;

				for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

					geometry.morphColors[ i ] = {};
					geometry.morphColors[ i ].name = json.morphColors[ i ].name;
					geometry.morphColors[ i ].colors = [];

					dstColors = geometry.morphColors[ i ].colors;
					srcColors = json.morphColors [ i ].colors;

					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

						color = new THREE.Color( 0xffaa00 );
						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
						dstColors.push( color );

					}

				}

			}

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = this.initMaterials( json.materials, texturePath );

			if ( this.needsTangents( materials ) ) {

				geometry.computeTangents();

			}

			return { geometry: geometry, materials: materials };

		}

	};

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

		var scope = this;

		var loaded = 0, total = 0;

		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			total ++;

		};

		this.itemEnd = function ( url ) {

			loaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, loaded, total );

			}

			if ( loaded === total && scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.BufferGeometryLoader.prototype = {

		constructor: THREE.BufferGeometryLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometry = new THREE.BufferGeometry();

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

			}

			var offsets = json.data.offsets;

			if ( offsets !== undefined ) {

				geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new THREE.Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	};

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.MaterialLoader.prototype = {

		constructor: THREE.MaterialLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var material = new THREE[ json.type ];

			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

			// for PointCloudMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			if ( json.materials !== undefined ) {

				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

					material.materials.push( this.parse( json.materials[ i ] ) );

				}

			}

			return material;

		}

	};

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';

	};

	THREE.ObjectLoader.prototype = {

		constructor: THREE.ObjectLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				scope.parse( JSON.parse( text ), onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var geometries = this.parseGeometries( json.geometries );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );
			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
			var object = this.parseObject( json.object, geometries, materials );

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseGeometries: function ( json ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':

							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments
							);

							break;

						case 'CylinderGeometry':

							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded
							);

							break;

						case 'SphereGeometry':

							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'IcosahedronGeometry':

							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'TorusGeometry':

							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':

							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data.data ).geometry;

							break;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var getTexture = function ( name ) {

					if ( textures[ name ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined texture', name );

					}

					return textures[ name ];

				};

				var loader = new THREE.MaterialLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];
					var material = loader.parse( data );

					material.uuid = data.uuid;

					if ( data.name !== undefined ) material.name = data.name;

					if ( data.map !== undefined ) {

						material.map = getTexture( data.map );

					}

					if ( data.bumpMap !== undefined ) {

						material.bumpMap = getTexture( data.bumpMap );
						if ( data.bumpScale ) {
							material.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );
						}

					}

					if ( data.alphaMap !== undefined ) {

						material.alphaMap = getTexture( data.alphaMap );

					}

					if ( data.envMap !== undefined ) {

						material.envMap = getTexture( data.envMap );

					}

					if ( data.normalMap !== undefined ) {

						material.normalMap = getTexture( data.normalMap );
						if ( data.normalScale ) {
							material.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );
						}

					}

					if ( data.lightMap !== undefined ) {

						material.lightMap = getTexture( data.lightMap );

					}

					if ( data.specularMap !== undefined ) {

						material.specularMap = getTexture( data.specularMap );

					}

					materials[ data.uuid ] = material;

				}

			}

			return materials;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			if ( json !== undefined && json.length > 0 ) {

				var manager = new THREE.LoadingManager( onLoad );

				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				var loadImage = function ( url ) {

					scope.manager.itemStart( url );

					return loader.load( url, function () {

						scope.manager.itemEnd( url );

					} );

				};

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: No "image" speficied for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];
					if ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( data.wrap instanceof Array ) {

						texture.wrapS = THREE[ data.wrap[ 0 ] ];
						texture.wrapT = THREE[ data.wrap[ 1 ] ];

					}

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function ( data, geometries, materials ) {

				var object;

				var getGeometry = function ( name ) {

					if ( geometries[ name ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				};

				var getMaterial = function ( name ) {

					if ( materials[ name ] === undefined ) {

						THREE.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				};

				switch ( data.type ) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight( data.color );

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'SpotLight':

						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'Mesh':

						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Line':

						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'PointCloud':

						object = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new THREE.Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					for ( var child in data.children ) {

						object.add( this.parseObject( data.children[ child ], geometries, materials ) );

					}

				}

				return object;

			}

		}()

	};

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.TextureLoader.prototype = {

		constructor: THREE.TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.ImageLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {

				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/BinaryTextureLoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {

		// override in sub classes
		this._parser = null;

	};

	THREE.BinaryTextureLoader.prototype = {

		constructor: THREE.BinaryTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new THREE.DataTexture( );

			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( !texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	};

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function () {

		// override in sub classes
		this._parser = null;

	};


	THREE.CompressedTextureLoader.prototype = {

		constructor: THREE.CompressedTextureLoader,

		load: function ( url, onLoad, onError ) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader();
			loader.setResponseType( 'arraybuffer' );

			if ( url instanceof Array ) {

				var loaded = 0;

				var loadTexture = function ( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if (texDatas.mipmapCount == 1)
	 							texture.minFilter = THREE.LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					} );

				};

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps : [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				} );

			}

			return texture;

		}

	};

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.side = THREE.FrontSide;

		this.opacity = 1;
		this.transparent = false;

		this.blending = THREE.NormalBlending;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthTest = true;
		this.depthWrite = true;

		this.colorWrite = true;

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this._needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					THREE.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				if ( key in this ) {

					var currentValue = this[ key ];

					if ( currentValue instanceof THREE.Color ) {

						currentValue.set( newValue );

					} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

						currentValue.copy( newValue );

					} else if ( key == 'overdraw' ) {

						// ensure overdraw is backwards-compatable with legacy boolean type
						this[ key ] = Number( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			}

		},

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type
			};

			if ( this.name !== "" ) output.name = this.name;

			if ( this instanceof THREE.MeshBasicMaterial ) {

				output.color = this.color.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshLambertMaterial ) {

				output.color = this.color.getHex();
				output.emissive = this.emissive.getHex();
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshPhongMaterial ) {

				output.color = this.color.getHex();
				output.emissive = this.emissive.getHex();
				output.specular = this.specular.getHex();
				output.shininess = this.shininess;
				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshNormalMaterial ) {

				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.MeshDepthMaterial ) {

				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
				if ( this.side !== THREE.FrontSide ) output.side = this.side;

			} else if ( this instanceof THREE.PointCloudMaterial ) {

				output.size  = this.size;
				output.sizeAttenuation = this.sizeAttenuation;
				output.color = this.color.getHex();

				if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
				if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;

			} else if ( this instanceof THREE.ShaderMaterial ) {

				output.uniforms = this.uniforms;
				output.vertexShader = this.vertexShader;
				output.fragmentShader = this.fragmentShader;

			} else if ( this instanceof THREE.SpriteMaterial ) {

				output.color = this.color.getHex();

			}

			if ( this.opacity < 1 ) output.opacity = this.opacity;
			if ( this.transparent !== false ) output.transparent = this.transparent;
			if ( this.wireframe !== false ) output.wireframe = this.wireframe;

			return output;

		},

		clone: function ( material ) {

			if ( material === undefined ) material = new THREE.Material();

			material.name = this.name;

			material.side = this.side;

			material.opacity = this.opacity;
			material.transparent = this.transparent;

			material.blending = this.blending;

			material.blendSrc = this.blendSrc;
			material.blendDst = this.blendDst;
			material.blendEquation = this.blendEquation;
			material.blendSrcAlpha = this.blendSrcAlpha;
			material.blendDstAlpha = this.blendDstAlpha;
			material.blendEquationAlpha = this.blendEquationAlpha;

			material.depthTest = this.depthTest;
			material.depthWrite = this.depthWrite;

			material.polygonOffset = this.polygonOffset;
			material.polygonOffsetFactor = this.polygonOffsetFactor;
			material.polygonOffsetUnits = this.polygonOffsetUnits;

			material.alphaTest = this.alphaTest;

			material.overdraw = this.overdraw;

			material.visible = this.visible;

			return material;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

	THREE.LineBasicMaterial.prototype.clone = function () {

		var material = new THREE.LineBasicMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.linewidth = this.linewidth;
		material.linecap = this.linecap;
		material.linejoin = this.linejoin;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineDashedMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.vertexColors = false;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

	THREE.LineDashedMaterial.prototype.clone = function () {

		var material = new THREE.LineDashedMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.linewidth = this.linewidth;

		material.scale = this.scale;
		material.dashSize = this.dashSize;
		material.gapSize = this.gapSize;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

	THREE.MeshBasicMaterial.prototype.clone = function () {

		var material = new THREE.MeshBasicMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;

		return material;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );

		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

		this.map = null;

		this.lightMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

	THREE.MeshLambertMaterial.prototype.clone = function () {

		var material = new THREE.MeshLambertMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.emissive.copy( this.emissive );

		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.metal = false;

		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

		this.map = null;

		this.lightMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

	THREE.MeshPhongMaterial.prototype.clone = function () {

		var material = new THREE.MeshPhongMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.emissive.copy( this.emissive );
		material.specular.copy( this.specular );
		material.shininess = this.shininess;

		material.metal = this.metal;

		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );

		material.map = this.map;

		material.lightMap = this.lightMap;

		material.bumpMap = this.bumpMap;
		material.bumpScale = this.bumpScale;

		material.normalMap = this.normalMap;
		material.normalScale.copy( this.normalScale );

		material.specularMap = this.specularMap;

		material.alphaMap = this.alphaMap;

		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;

		material.fog = this.fog;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	};

	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

	THREE.MeshDepthMaterial.prototype.clone = function () {

		var material = new THREE.MeshDepthMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		return material;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function ( parameters ) {

		THREE.Material.call( this, parameters );

		this.type = 'MeshNormalMaterial';

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

	THREE.MeshNormalMaterial.prototype.clone = function () {

		var material = new THREE.MeshNormalMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		return material;

	};

	// File:src/materials/MeshFaceMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MeshFaceMaterial = function ( materials ) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MeshFaceMaterial';
		
		this.materials = materials instanceof Array ? materials : [];

	};

	THREE.MeshFaceMaterial.prototype = {

		constructor: THREE.MeshFaceMaterial,

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

				output.materials.push( this.materials[ i ].toJSON() );

			}

			return output;

		},

		clone: function () {

			var material = new THREE.MeshFaceMaterial();

			for ( var i = 0; i < this.materials.length; i ++ ) {

				material.materials.push( this.materials[ i ].clone() );

			}

			return material;

		}

	};

	// File:src/materials/PointCloudMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.PointCloudMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'PointCloudMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

	THREE.PointCloudMaterial.prototype.clone = function () {

		var material = new THREE.PointCloudMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );

		material.map = this.map;

		material.size = this.size;
		material.sizeAttenuation = this.sizeAttenuation;

		material.vertexColors = this.vertexColors;

		material.fog = this.fog;

		return material;

	};

	// backwards compatibility

	THREE.ParticleBasicMaterial = function ( parameters ) {

		THREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );

	};

	THREE.ParticleSystemMaterial = function ( parameters ) {

		THREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
		return new THREE.PointCloudMaterial( parameters );

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.attributes = null;

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.shading = THREE.SmoothShading;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		this.setValues( parameters );

	};

	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

	THREE.ShaderMaterial.prototype.clone = function () {

		var material = new THREE.ShaderMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.fragmentShader = this.fragmentShader;
		material.vertexShader = this.vertexShader;

		material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

		material.attributes = this.attributes;
		material.defines = this.defines;

		material.shading = this.shading;

		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;

		material.fog = this.fog;

		material.lights = this.lights;

		material.vertexColors = this.vertexColors;

		material.skinning = this.skinning;

		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;

		return material;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function ( parameters ) {

		THREE.ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

	THREE.RawShaderMaterial.prototype.clone = function () {

		var material = new THREE.RawShaderMaterial();

		THREE.ShaderMaterial.prototype.clone.call( this, material );

		return material;

	};

	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.SpriteMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;

		// set parameters

		this.setValues( parameters );

	};

	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

	THREE.SpriteMaterial.prototype.clone = function () {

		var material = new THREE.SpriteMaterial();

		THREE.Material.prototype.clone.call( this, material );

		material.color.copy( this.color );
		material.map = this.map;

		material.rotation = this.rotation;

		material.fog = this.fog;

		return material;

	};

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.sourceFile = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this._needsUpdate = false;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		clone: function ( texture ) {

			if ( texture === undefined ) texture = new THREE.Texture();

			texture.image = this.image;
			texture.mipmaps = this.mipmaps.slice( 0 );

			texture.mapping = this.mapping;

			texture.wrapS = this.wrapS;
			texture.wrapT = this.wrapT;

			texture.magFilter = this.magFilter;
			texture.minFilter = this.minFilter;

			texture.anisotropy = this.anisotropy;

			texture.format = this.format;
			texture.type = this.type;

			texture.offset.copy( this.offset );
			texture.repeat.copy( this.repeat );

			texture.generateMipmaps = this.generateMipmaps;
			texture.premultiplyAlpha = this.premultiplyAlpha;
			texture.flipY = this.flipY;
			texture.unpackAlignment = this.unpackAlignment;

			return texture;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

	THREE.TextureIdCount = 0;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
		
		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.images = images;

	};

	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

	THREE.CubeTexture.clone = function ( texture ) {

		if ( texture === undefined ) texture = new THREE.CubeTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		texture.images = this.images;

		return texture;

	};

	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

	THREE.CompressedTexture.prototype.clone = function () {

		var texture = new THREE.CompressedTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		return texture;

	};

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { data: data, width: width, height: height };

	};

	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;

	THREE.DataTexture.prototype.clone = function () {

		var texture = new THREE.DataTexture();

		THREE.Texture.prototype.clone.call( this, texture );

		return texture;

	};

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		var scope = this;

		var update = function () {

			requestAnimationFrame( update );

			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

				scope.needsUpdate = true;

			}

		};

		update();

	};

	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call( this );

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;

	// File:src/objects/PointCloud.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.PointCloud = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'PointCloud';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
	THREE.PointCloud.prototype.constructor = THREE.PointCloud;

	THREE.PointCloud.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();

		return function ( raycaster, intersects ) {

			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.PointCloud.threshold;

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var position = new THREE.Vector3();

			var testPoint = function ( point, index ) {

				var rayPointDistance = ray.distanceToPoint( point );

				if ( rayPointDistance < localThreshold ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					intersects.push( {

						distance: distance,
						distanceToRay: rayPointDistance,
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			};

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						var offset = {
							start: 0,
							count: indices.length,
							index: 0
						};

						offsets = [ offset ];

					}

					for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i ++ ) {

							var a = index + indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					}

				} else {

					var pointCount = positions.length / 3;

					for ( var i = 0; i < pointCount; i ++ ) {

						position.set(
							positions[ 3 * i ],
							positions[ 3 * i + 1 ],
							positions[ 3 * i + 2 ]
						);

						testPoint( position, i );

					}

				}

			} else {

				var vertices = this.geometry.vertices;

				for ( var i = 0; i < vertices.length; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() );

	THREE.PointCloud.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// Backwards compatibility

	THREE.ParticleSystem = function ( geometry, material ) {

		THREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
		return new THREE.PointCloud( geometry, material );

	};

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function ( geometry, material, mode ) {

		THREE.Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

		this.mode = mode !== undefined ? mode : THREE.LineStrip;

	};

	THREE.LineStrip = 0;
	THREE.LinePieces = 1;

	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;

	THREE.Line.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function ( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this.mode === THREE.LineStrip ? 1 : 2;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						offsets = [ { start: 0, count: indices.length, index: 0 } ];

					}

					for ( var oi = 0; oi < offsets.length; oi ++) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start; i < start + count - 1; i += step ) {

							var a = index + indices[ i ];
							var b = index + indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							var distance = ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								offsetIndex: oi,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0; i < positions.length / 3 - 1; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						var distance = ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Line.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Mesh';
		
		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;

	THREE.Mesh.prototype.updateMorphTargets = function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	};

	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		THREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	};


	THREE.Mesh.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			var geometry = this.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			// Check boundingBox before continuing

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = this.material;

				if ( material === undefined ) return;

				var attributes = geometry.attributes;

				var a, b, c;
				var precision = raycaster.precision;

				if ( attributes.index !== undefined ) {

					var indices = attributes.index.array;
					var positions = attributes.position.array;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						offsets = [ { start: 0, count: indices.length, index: 0 } ];

					}

					for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ];
							c = index + indices[ i + 2 ];

							vA.fromArray( positions, a * 3 );
							vB.fromArray( positions, b * 3 );
							vC.fromArray( positions, c * 3 );

							if ( material.side === THREE.BackSide ) {

								var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

							} else {

								var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( this.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
								faceIndex: null,
								object: this

							} );

						}

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.fromArray( positions, j );
						vB.fromArray( positions, j + 3 );
						vC.fromArray( positions, j + 6 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

				var a, b, c;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;

							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;

							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( c, b, a, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Mesh.prototype.clone = function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

		THREE.Object3D.prototype.clone.call( this, object, recursive );

		return object;

	};

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function ( skin ) {

		THREE.Object3D.call( this );

		this.type = 'Bone';

		this.skin = skin;

	};

	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;

	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );

		// create a bone texture or an array of floats

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//       16x16 pixel texture max   64 bones (16 * 16 / 4)
			//       32x32 pixel texture max  256 bones (32 * 32 / 4)
			//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( this.bones.length > 256 )
				size = 64;
			else if ( this.bones.length > 64 )
				size = 32;
			else if ( this.bones.length > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * this.bones.length );

		}

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				THREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					this.boneInverses.push( new THREE.Matrix4() );

				}

			}

		}

	};

	THREE.Skeleton.prototype.calculateInverses = function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	};

	THREE.Skeleton.prototype.pose = function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	};

	THREE.Skeleton.prototype.update = ( function () {

		var offsetMatrix = new THREE.Matrix4();
		
		return function () {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}
			
		};

	} )();


	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if ( this.geometry && this.geometry.bones !== undefined ) {

			var bone, gbone, p, q, s;

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				p = gbone.pos;
				q = gbone.rotq;
				s = gbone.scl;

				bone = new THREE.Bone( this );
				bones.push( bone );

				bone.name = gbone.name;
				bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
				bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

				if ( s !== undefined ) {

					bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

				} else {

					bone.scale.set( 1, 1, 1 );

				}

			}

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				if ( gbone.parent !== - 1 ) {

					bones[ gbone.parent ].add( bones[ b ] );

				} else {

					this.add( bones[ b ] );

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

	};


	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	};

	THREE.SkinnedMesh.prototype.pose = function () {

		this.skeleton.pose();

	};

	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1 ); // this will be normalized by the shader anyway

				}

			}

		} else {

			// skinning weights assumed to be normalized for THREE.BufferGeometry

		}

	};

	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			THREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

		}

	};

	THREE.SkinnedMesh.prototype.clone = function( object ) {

		if ( object === undefined ) {

			object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

		}

		THREE.Mesh.prototype.clone.call( this, object );

		return object;

	};


	// File:src/objects/MorphAnimMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphAnimMesh = function ( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'MorphAnimMesh';

		// API

		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;

		// internals

		this.lastKeyframe = 0;
		this.currentKeyframe = 0;

		this.direction = 1;
		this.directionBackwards = false;

		this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

	};

	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

		this.startKeyframe = start;
		this.endKeyframe = end;

		this.length = this.endKeyframe - this.startKeyframe + 1;

	};

	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

		this.direction = 1;
		this.directionBackwards = false;

	};

	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

		this.direction = - 1;
		this.directionBackwards = true;

	};

	THREE.MorphAnimMesh.prototype.parseAnimations = function () {

		var geometry = this.geometry;

		if ( ! geometry.animations ) geometry.animations = {};

		var firstAnimation, animations = geometry.animations;

		var pattern = /([a-z]+)_?(\d+)/;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var label = parts[ 1 ];

				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

				var animation = animations[ label ];

				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;

				if ( ! firstAnimation ) firstAnimation = label;

			}

		}

		geometry.firstAnimation = firstAnimation;

	};

	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

		if ( ! this.geometry.animations ) this.geometry.animations = {};

		this.geometry.animations[ label ] = { start: start, end: end };

	};

	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

		var animation = this.geometry.animations[ label ];

		if ( animation ) {

			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;

		} else {

			THREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

		}

	};

	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

		var frameTime = this.duration / this.length;

		this.time += this.direction * delta;

		if ( this.mirroredLoop ) {

			if ( this.time > this.duration || this.time < 0 ) {

				this.direction *= - 1;

				if ( this.time > this.duration ) {

					this.time = this.duration;
					this.directionBackwards = true;

				}

				if ( this.time < 0 ) {

					this.time = 0;
					this.directionBackwards = false;

				}

			}

		} else {

			this.time = this.time % this.duration;

			if ( this.time < 0 ) this.time += this.duration;

		}

		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

		if ( keyframe !== this.currentKeyframe ) {

			this.morphTargetInfluences[ this.lastKeyframe ] = 0;
			this.morphTargetInfluences[ this.currentKeyframe ] = 1;

			this.morphTargetInfluences[ keyframe ] = 0;

			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;

		}

		var mix = ( this.time % frameTime ) / frameTime;

		if ( this.directionBackwards ) {

			mix = 1 - mix;

		}

		this.morphTargetInfluences[ this.currentKeyframe ] = mix;
		this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

	};

	THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

		var influences = this.morphTargetInfluences;

		for ( var i = 0, l = influences.length; i < l; i ++ ) {

			influences[ i ] = 0;

		}

		if ( a > -1 ) influences[ a ] = 1 - t;
		if ( b > -1 ) influences[ b ] = t;

	};

	THREE.MorphAnimMesh.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

		object.duration = this.duration;
		object.mirroredLoop = this.mirroredLoop;
		object.time = this.time;

		object.lastKeyframe = this.lastKeyframe;
		object.currentKeyframe = this.currentKeyframe;

		object.direction = this.direction;
		object.directionBackwards = this.directionBackwards;

		THREE.Mesh.prototype.clone.call( this, object );

		return object;

	};

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call( this );

		this.objects = [];

	};


	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;

	THREE.LOD.prototype.addLevel = function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		for ( var l = 0; l < this.objects.length; l ++ ) {

			if ( distance < this.objects[ l ].distance ) {

				break;

			}

		}

		this.objects.splice( l, 0, { distance: distance, object: object } );
		this.add( object );

	};

	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

		for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

			if ( distance < this.objects[ i ].distance ) {

				break;

			}

		}

		return this.objects[ i - 1 ].object;

	};

	THREE.LOD.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() );

	THREE.LOD.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( camera ) {

			if ( this.objects.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				this.objects[ 0 ].object.visible = true;

				for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

					if ( distance >= this.objects[ i ].distance ) {

						this.objects[ i - 1 ].object.visible = false;
						this.objects[ i     ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					this.objects[ i ].object.visible = false;

				}

			}

		};

	}();

	THREE.LOD.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.LOD();

		THREE.Object3D.prototype.clone.call( this, object );

		for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
			var x = this.objects[ i ].object.clone();
			x.visible = i === 0;
			object.addLevel( x, this.objects[ i ].distance );
		}

		return object;

	};

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = ( function () {

		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return function ( material ) {

			THREE.Object3D.call( this );

			this.type = 'Sprite';

			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

		};

	} )();

	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;

	THREE.Sprite.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function ( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > this.scale.x ) {

				return;

			}

			intersects.push( {

				distance: distance,
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() );

	THREE.Sprite.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Sprite( this.material );

		THREE.Object3D.prototype.clone.call( this, object );

		return object;

	};

	// Backwards compatibility

	THREE.Particle = THREE.Sprite;

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function ( texture, size, distance, blending, color ) {

		THREE.Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if ( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	};

	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;


	/*
	 * Add: adds another flare
	 */

	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture, 			// THREE.Texture
			size: size, 				// size in pixels (-1 = use texture.width)
			distance: distance, 		// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
			scale: 1, 					// scale
			rotation: 1, 				// rotation
			opacity: opacity,			// opacity
			color: color,				// color
			blending: blending			// blending
		} );

	};

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	THREE.LensFlare.prototype.updateLensFlares = function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	};


	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call( this );

		this.type = 'Scene';

		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;

	THREE.Scene.prototype.clone = function ( object ) {

		if ( object === undefined ) object = new THREE.Scene();

		THREE.Object3D.prototype.clone.call( this, object );

		if ( this.fog !== null ) object.fog = this.fog.clone();
		if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

		object.autoUpdate = this.autoUpdate;
		object.matrixAutoUpdate = this.matrixAutoUpdate;

		return object;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function ( color, near, far ) {

		this.name = '';

		this.color = new THREE.Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog( this.color.getHex(), this.near, this.far );

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function ( color, density ) {

		this.name = '';

		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2( this.color.getHex(), this.density );

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/common.glsl

	THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n";

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

	THREE.ShaderChunk[ 'default_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

	THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

	THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

	THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( parameter_src instanceof Array ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },

			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"lightMap" : { type: "t", value: null },
			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },

			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 },

			"morphTargetInfluences" : { type: "f", value: 0 }

		},

		bump: {

			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }

		},

		normalmap: {

			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
		},

		fog : {

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		lights: {

			"ambientLightColor" : { type: "fv", value: [] },

			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },

			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },

			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },

			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }

		},

		particle: {

			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		shadowmap: {

			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },

			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },

			"shadowMatrix" : { type: "m4v", value: [] }

		}

	};

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],

				"	#ifdef USE_ENVMAP",

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	#endif",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "lightmap_fragment" ],		// TODO: Light map on an otherwise unlit surface doesn't make sense.
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}

			] ),

			vertexShader: [

				"#define LAMBERT",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

				"	#ifdef DOUBLE_SIDED",

						//"float isFront = float( gl_FrontFacing );",
						//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

				"	#else",

				"		outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

				"	#endif",

					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "bump" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}

			] ),

			vertexShader: [

				"#define PHONG",

				"varying vec3 vViewPosition;",

				"#ifndef FLAT_SHADED",

				"	varying vec3 vNormal;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

				"	vNormal = normalize( transformedNormal );",

				"#endif",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"	vViewPosition = -mvPosition.xyz;",

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"#define PHONG",

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],

					THREE.ShaderChunk[ "lights_phong_fragment" ],

					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'particle_basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "particle" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				"uniform float size;",
				"uniform float scale;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 psColor;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( psColor, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],

				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}

			] ),

			vertexShader: [

				"uniform float scale;",
				"attribute float lineDistance;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vLineDistance = scale * lineDistance;",

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform float dashSize;",
				"uniform float totalSize;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

				"		discard;",

				"	}",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'depth': {

			uniforms: {

				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

				"	#else",

				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

				"	#endif",

				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

				"}"

			].join("\n")

		},

		'normal': {

			uniforms: {

				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vNormal = normalize( normalMatrix * normal );",

					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform float opacity;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'equirect': {

			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join("\n")

		},

		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */

		'depthRGBA': {

			uniforms: {},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join("\n"),

			fragmentShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"vec4 pack_depth( const in float depth ) {",

				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",

				"}",

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

				"	#else",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				"	#endif",

					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

				"}"

			].join("\n")

		}

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.WebGLRenderer = function ( parameters ) {

		console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		pixelRatio = 1,

		_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;

		var lights = [];

		var _webglObjects = {};
		var _webglObjectsImmediate = [];

		var opaqueObjects = [];
		var transparentObjects = [];

		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// shadow map

		this.shadowMapEnabled = false;
		this.shadowMapType = THREE.PCFShadowMap;
		this.shadowMapCullFace = THREE.CullFaceFront;
		this.shadowMapDebug = false;
		this.shadowMapCascade = false;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// flags

		this.autoScaleCubemaps = true;

		// info

		this.info = {

			memory: {

				programs: 0,
				geometries: 0,
				textures: 0

			},

			render: {

				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			}

		};

		// internal properties

		var _this = this,

		_programs = [],

		// internal state cache

		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_usedTextureUnits = 0,

		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,

		// frustum

		_frustum = new THREE.Frustum(),

		 // camera matrices cache

		_projScreenMatrix = new THREE.Matrix4(),

		_vector3 = new THREE.Vector3(),

		// light arrays cache

		_direction = new THREE.Vector3(),

		_lightsNeedUpdate = true,

		_lights = {

			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors:[], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

		};

		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl') !== null ) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

			_canvas.addEventListener( 'webglcontextlost', function ( event ) {

				event.preventDefault();

				resetGLState();
				setDefaultGLState();

				_webglObjects = {};

			}, false);

		} catch ( error ) {

			THREE.error( 'THREE.WebGLRenderer: ' + error );

		}

		var state = new THREE.WebGLState( _gl, paramThreeToGL );

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return {
					'rangeMin': 1,
					'rangeMax': 1,
					'precision': 1
				};

			}

		}

		var extensions = new THREE.WebGLExtensions( _gl );

		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );

		if ( _logarithmicDepthBuffer ) {

			extensions.get( 'EXT_frag_depth' );

		}

		//

		var glClearColor = function ( r, g, b, a ) {

			if ( _premultipliedAlpha === true ) {

				r *= a; g *= a; b *= a;

			}

			_gl.clearColor( r, g, b, a );

		};

		var setDefaultGLState = function () {

			_gl.clearColor( 0, 0, 0, 1 );
			_gl.clearDepth( 1 );
			_gl.clearStencil( 0 );

			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthFunc( _gl.LEQUAL );

			_gl.frontFace( _gl.CCW );
			_gl.cullFace( _gl.BACK );
			_gl.enable( _gl.CULL_FACE );

			_gl.enable( _gl.BLEND );
			_gl.blendEquation( _gl.FUNC_ADD );
			_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		var resetGLState = function () {

			_currentProgram = null;
			_currentCamera = null;

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;

			_lightsNeedUpdate = true;

			state.reset();

		};

		setDefaultGLState();

		this.context = _gl;
		this.state = state;

		// GPU capabilities

		var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
		var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
		var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var _supportsVertexTextures = _maxVertexTextures > 0;
		var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

		//

		var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
		var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );

		var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
		var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );

		var getCompressedTextureFormats = ( function () {

			var array;

			return function () {

				if ( array !== undefined ) {

					return array;

				}

				array = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

					var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						array.push( formats[ i ] );

					}

				}

				return array;

			};

		} )();

		// clamp precision to maximum available

		var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
		var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

		if ( _precision === 'highp' && ! highpAvailable ) {

			if ( mediumpAvailable ) {

				_precision = 'mediump';
				THREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

			} else {

				_precision = 'lowp';
				THREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

			}

		}

		if ( _precision === 'mediump' && ! mediumpAvailable ) {

			_precision = 'lowp';
			THREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

		}

		// Plugins

		var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

		// API

		this.getContext = function () {

			return _gl;

		};

		this.forceContextLoss = function () {

			extensions.get( 'WEBGL_lose_context' ).loseContext();

		};

		this.supportsVertexTextures = function () {

			return _supportsVertexTextures;

		};

		this.supportsFloatTextures = function () {

			return extensions.get( 'OES_texture_float' );

		};

		this.supportsHalfFloatTextures = function () {

			return extensions.get( 'OES_texture_half_float' );

		};

		this.supportsStandardDerivatives = function () {

			return extensions.get( 'OES_standard_derivatives' );

		};

		this.supportsCompressedTextureS3TC = function () {

			return extensions.get( 'WEBGL_compressed_texture_s3tc' );

		};

		this.supportsCompressedTexturePVRTC = function () {

			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		};

		this.supportsBlendMinMax = function () {

			return extensions.get( 'EXT_blend_minmax' );

		};

		this.getMaxAnisotropy = ( function () {

			var value;

			return function () {

				if ( value !== undefined ) {

					return value;

				}

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

				return value;

			}

		} )();

		this.getPrecision = function () {

			return _precision;

		};

		this.getPixelRatio = function () {

			return pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			pixelRatio = value;

		};

		this.setSize = function ( width, height, updateStyle ) {

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;

			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		};

		this.setScissor = function ( x, y, width, height ) {

			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);

		};

		this.enableScissorTest = function ( enable ) {

			enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

		};

		// Clearing

		this.getClearColor = function () {

			return _clearColor;

		};

		this.setClearColor = function ( color, alpha ) {

			_clearColor.set( color );

			_clearAlpha = alpha !== undefined ? alpha : 1;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.setClearAlpha = function ( alpha ) {

			_clearAlpha = alpha;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			_gl.clear( _gl.COLOR_BUFFER_BIT );

		};

		this.clearDepth = function () {

			_gl.clear( _gl.DEPTH_BUFFER_BIT );

		};

		this.clearStencil = function () {

			_gl.clear( _gl.STENCIL_BUFFER_BIT );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		// Reset

		this.resetGLState = resetGLState;

		// Buffer allocation

		function createParticleBuffers ( geometry ) {

			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();

			_this.info.memory.geometries ++;

		};

		function createLineBuffers ( geometry ) {

			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglLineDistanceBuffer = _gl.createBuffer();

			_this.info.memory.geometries ++;

		};

		function createMeshBuffers ( geometryGroup ) {

			geometryGroup.__webglVertexBuffer = _gl.createBuffer();
			geometryGroup.__webglNormalBuffer = _gl.createBuffer();
			geometryGroup.__webglTangentBuffer = _gl.createBuffer();
			geometryGroup.__webglColorBuffer = _gl.createBuffer();
			geometryGroup.__webglUVBuffer = _gl.createBuffer();
			geometryGroup.__webglUV2Buffer = _gl.createBuffer();

			geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
			geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

			geometryGroup.__webglFaceBuffer = _gl.createBuffer();
			geometryGroup.__webglLineBuffer = _gl.createBuffer();

			var numMorphTargets = geometryGroup.numMorphTargets;

			if ( numMorphTargets ) {

				geometryGroup.__webglMorphTargetsBuffers = [];

				for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {

					geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

				}

			}

			var numMorphNormals = geometryGroup.numMorphNormals;

			if ( numMorphNormals ) {

				geometryGroup.__webglMorphNormalsBuffers = [];

				for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {

					geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

				}

			}

			_this.info.memory.geometries ++;

		};

		// Events

		var onObjectRemoved = function ( event ) {

			var object = event.target;

			object.traverse( function ( child ) {

				child.removeEventListener( 'remove', onObjectRemoved );

				removeObject( child );

			} );

		};

		var onGeometryDispose = function ( event ) {

			var geometry = event.target;

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			deallocateGeometry( geometry );

		};

		var onTextureDispose = function ( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			_this.info.memory.textures --;


		};

		var onRenderTargetDispose = function ( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			_this.info.memory.textures --;

		};

		var onMaterialDispose = function ( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		};

		// Buffer deallocation

		var deleteBuffers = function ( geometry ) {

			var buffers = [
				'__webglVertexBuffer',
				'__webglNormalBuffer',
				'__webglTangentBuffer',
				'__webglColorBuffer',
				'__webglUVBuffer',
				'__webglUV2Buffer',

				'__webglSkinIndicesBuffer',
				'__webglSkinWeightsBuffer',

				'__webglFaceBuffer',
				'__webglLineBuffer',

				'__webglLineDistanceBuffer'
			];

			for ( var i = 0, l = buffers.length; i < l; i ++ ) {

				var name = buffers[ i ];

				if ( geometry[ name ] !== undefined ) {

					_gl.deleteBuffer( geometry[ name ] );

					delete geometry[ name ];

				}

			}

			// custom attributes

			if ( geometry.__webglCustomAttributesList !== undefined ) {

				for ( var name in geometry.__webglCustomAttributesList ) {

					_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

				}

				delete geometry.__webglCustomAttributesList;

			}

			_this.info.memory.geometries --;

		};

		var deallocateGeometry = function ( geometry ) {

			delete geometry.__webglInit;

			if ( geometry instanceof THREE.BufferGeometry ) {

				for ( var name in geometry.attributes ) {

					var attribute = geometry.attributes[ name ];

					if ( attribute.buffer !== undefined ) {

						_gl.deleteBuffer( attribute.buffer );

						delete attribute.buffer;

					}

				}

				_this.info.memory.geometries --;

			} else {

				var geometryGroupsList = geometryGroups[ geometry.id ];

				if ( geometryGroupsList !== undefined ) {

					for ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {

						var geometryGroup = geometryGroupsList[ i ];

						if ( geometryGroup.numMorphTargets !== undefined ) {

							for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

								_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

							}

							delete geometryGroup.__webglMorphTargetsBuffers;

						}

						if ( geometryGroup.numMorphNormals !== undefined ) {

							for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

								_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

							}

							delete geometryGroup.__webglMorphNormalsBuffers;

						}

						deleteBuffers( geometryGroup );

					}

					delete geometryGroups[ geometry.id ];

				} else {

					deleteBuffers( geometry );

				}

			}

			// TOFIX: Workaround for deleted geometry being currently bound

			_currentGeometryProgram = '';

		};

		var deallocateTexture = function ( texture ) {

			if ( texture.image && texture.image.__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( texture.image.__webglTextureCube );

				delete texture.image.__webglTextureCube;

			} else {

				// 2D texture

				if ( texture.__webglInit === undefined ) return;

				_gl.deleteTexture( texture.__webglTexture );

				delete texture.__webglTexture;
				delete texture.__webglInit;

			}

		};

		var deallocateRenderTarget = function ( renderTarget ) {

			if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

			_gl.deleteTexture( renderTarget.__webglTexture );

			delete renderTarget.__webglTexture;

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

			}

			delete renderTarget.__webglFramebuffer;
			delete renderTarget.__webglRenderbuffer;

		};

		var deallocateMaterial = function ( material ) {

			var program = material.program.program;

			if ( program === undefined ) return;

			material.program = undefined;

			// only deallocate GL program if this was the last use of shared program
			// assumed there is only single copy of any program in the _programs list
			// (that's how it's constructed)

			var i, il, programInfo;
			var deleteProgram = false;

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program === program ) {

					programInfo.usedTimes --;

					if ( programInfo.usedTimes === 0 ) {

						deleteProgram = true;

					}

					break;

				}

			}

			if ( deleteProgram === true ) {

				// avoid using array.splice, this is costlier than creating new array from scratch

				var newPrograms = [];

				for ( i = 0, il = _programs.length; i < il; i ++ ) {

					programInfo = _programs[ i ];

					if ( programInfo.program !== program ) {

						newPrograms.push( programInfo );

					}

				}

				_programs = newPrograms;

				_gl.deleteProgram( program );

				_this.info.memory.programs --;

			}

		};

		// Buffer initialization

		function initCustomAttributes ( object ) {

			var geometry = object.geometry;
			var material = object.material;

			var nvertices = geometry.vertices.length;

			if ( material.attributes ) {

				if ( geometry.__webglCustomAttributesList === undefined ) {

					geometry.__webglCustomAttributesList = [];

				}

				for ( var name in material.attributes ) {

					var attribute = material.attributes[ name ];

					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

						attribute.__webglInitialized = true;

						var size = 1;   // "f" and "i"

						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;

						attribute.size = size;

						attribute.array = new Float32Array( nvertices * size );

						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;

						attribute.needsUpdate = true;

					}

					geometry.__webglCustomAttributesList.push( attribute );

				}

			}

		};

		function initParticleBuffers ( geometry, object ) {

			var nvertices = geometry.vertices.length;

			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );

			geometry.__webglParticleCount = nvertices;

			initCustomAttributes( object );

		};

		function initLineBuffers ( geometry, object ) {

			var nvertices = geometry.vertices.length;

			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

			geometry.__webglLineCount = nvertices;

			initCustomAttributes( object );

		};

		function initMeshBuffers ( geometryGroup, object ) {

			var geometry = object.geometry,
				faces3 = geometryGroup.faces3,

				nvertices = faces3.length * 3,
				ntris     = faces3.length * 1,
				nlines    = faces3.length * 3,

				material = getBufferMaterial( object, geometryGroup );

			geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
			geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

			if ( geometry.hasTangents ) {

				geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

			}

			if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

				geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
				geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

			}

			var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

			geometryGroup.__typeArray = UintArray;
			geometryGroup.__faceArray = new UintArray( ntris * 3 );
			geometryGroup.__lineArray = new UintArray( nlines * 2 );

			var numMorphTargets = geometryGroup.numMorphTargets;

			if ( numMorphTargets ) {

				geometryGroup.__morphTargetsArrays = [];

				for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {

					geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

				}

			}

			var numMorphNormals = geometryGroup.numMorphNormals;

			if ( numMorphNormals ) {

				geometryGroup.__morphNormalsArrays = [];

				for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {

					geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

				}

			}

			geometryGroup.__webglFaceCount = ntris * 3;
			geometryGroup.__webglLineCount = nlines * 2;


			// custom attributes

			if ( material.attributes ) {

				if ( geometryGroup.__webglCustomAttributesList === undefined ) {

					geometryGroup.__webglCustomAttributesList = [];

				}

				for ( var name in material.attributes ) {

					// Do a shallow copy of the attribute object so different geometryGroup chunks use different
					// attribute buffers which are correctly indexed in the setMeshBuffers function

					var originalAttribute = material.attributes[ name ];

					var attribute = {};

					for ( var property in originalAttribute ) {

						attribute[ property ] = originalAttribute[ property ];

					}

					if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

						attribute.__webglInitialized = true;

						var size = 1;   // "f" and "i"

						if ( attribute.type === 'v2' ) size = 2;
						else if ( attribute.type === 'v3' ) size = 3;
						else if ( attribute.type === 'v4' ) size = 4;
						else if ( attribute.type === 'c'  ) size = 3;

						attribute.size = size;

						attribute.array = new Float32Array( nvertices * size );

						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = name;

						originalAttribute.needsUpdate = true;
						attribute.__original = originalAttribute;

					}

					geometryGroup.__webglCustomAttributesList.push( attribute );

				}

			}

			geometryGroup.__inittedArrays = true;

		};

		function getBufferMaterial( object, geometryGroup ) {

			return object.material instanceof THREE.MeshFaceMaterial
				 ? object.material.materials[ geometryGroup.materialIndex ]
				 : object.material;

		}

		function materialNeedsFaceNormals ( material ) {

			return material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;

		}

		// Buffer setting

		function setParticleBuffers ( geometry, hint, object ) {

			var v, c, vertex, offset, color,

			vertices = geometry.vertices,
			vl = vertices.length,

			colors = geometry.colors,
			cl = colors.length,

			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,

			customAttributes = geometry.__webglCustomAttributesList,
			i, il,
			ca, cal, value,
			customAttribute;

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

					customAttribute.needsUpdate = false;

				}

			}

		}

		function setLineBuffers ( geometry, hint ) {

			var v, c, d, vertex, offset, color,

			vertices = geometry.vertices,
			colors = geometry.colors,
			lineDistances = geometry.lineDistances,

			vl = vertices.length,
			cl = colors.length,
			dl = lineDistances.length,

			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			lineDistanceArray = geometry.__lineDistanceArray,

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyLineDistances = geometry.lineDistancesNeedUpdate,

			customAttributes = geometry.__webglCustomAttributesList,

			i, il,
			ca, cal, value,
			customAttribute;

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

			if ( dirtyLineDistances ) {

				for ( d = 0; d < dl; d ++ ) {

					lineDistanceArray[ d ] = lineDistances[ d ];

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {

						offset = 0;

						cal = customAttribute.value.length;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]    = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

						customAttribute.needsUpdate = false;

					}

				}

			}

		}

		function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

			if ( ! geometryGroup.__inittedArrays ) {

				return;

			}

			var needsFaceNormals = materialNeedsFaceNormals( material );

			var f, fl, fi, face,
			vertexNormals, faceNormal,
			vertexColors, faceColor,
			vertexTangents,
			uv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,
			c1, c2, c3,
			sw1, sw2, sw3,
			si1, si2, si3,
			i, il,
			vn, uvi, uv2i,
			vk, vkl, vka,
			nka, chf, faceVertexNormals,

			vertexIndex = 0,

			offset = 0,
			offset_uv = 0,
			offset_uv2 = 0,
			offset_face = 0,
			offset_normal = 0,
			offset_tangent = 0,
			offset_line = 0,
			offset_color = 0,
			offset_skin = 0,
			offset_morphTarget = 0,
			offset_custom = 0,

			value,

			vertexArray = geometryGroup.__vertexArray,
			uvArray = geometryGroup.__uvArray,
			uv2Array = geometryGroup.__uv2Array,
			normalArray = geometryGroup.__normalArray,
			tangentArray = geometryGroup.__tangentArray,
			colorArray = geometryGroup.__colorArray,

			skinIndexArray = geometryGroup.__skinIndexArray,
			skinWeightArray = geometryGroup.__skinWeightArray,

			morphTargetsArrays = geometryGroup.__morphTargetsArrays,
			morphNormalsArrays = geometryGroup.__morphNormalsArrays,

			customAttributes = geometryGroup.__webglCustomAttributesList,
			customAttribute,

			faceArray = geometryGroup.__faceArray,
			lineArray = geometryGroup.__lineArray,

			geometry = object.geometry, // this is shared for all chunks

			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyUvs = geometry.uvsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
			dirtyTangents = geometry.tangentsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

			vertices = geometry.vertices,
			chunk_faces3 = geometryGroup.faces3,
			obj_faces = geometry.faces,

			obj_uvs  = geometry.faceVertexUvs[ 0 ],
			obj_uvs2 = geometry.faceVertexUvs[ 1 ],

			obj_skinIndices = geometry.skinIndices,
			obj_skinWeights = geometry.skinWeights,

			morphTargets = geometry.morphTargets,
			morphNormals = geometry.morphNormals;

			if ( dirtyVertices ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];

					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;

					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;

					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;

					offset += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

			}

			if ( dirtyMorphTargets ) {

				for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

					offset_morphTarget = 0;

					for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

						chf = chunk_faces3[ f ];
						face = obj_faces[ chf ];

						// morph positions

						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];

						vka = morphTargetsArrays[ vk ];

						vka[ offset_morphTarget ]     = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;

						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;

						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;

						// morph normals

						if ( material.morphNormals ) {

							if ( needsFaceNormals ) {

								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;

							} else {

								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;

							}

							nka = morphNormalsArrays[ vk ];

							nka[ offset_morphTarget ]     = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;

							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;

							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;

						}

						//

						offset_morphTarget += 9;

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

					if ( material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
						_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

					}

				}

			}

			if ( obj_skinWeights.length ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					// weights

					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];

					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;

					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;

					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;

					// indices

					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];

					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;

					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;

					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;

					offset_skin += 12;

				}

				if ( offset_skin > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

				}

			}

			if ( dirtyColors ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexColors = face.vertexColors;
					faceColor = face.color;

					if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];

					} else {

						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;

					}

					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;

					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;

					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;

					offset_color += 9;

				}

				if ( offset_color > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

				}

			}

			if ( dirtyTangents && geometry.hasTangents ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexTangents = face.vertexTangents;

					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];

					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;

					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;

					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;

					offset_tangent += 12;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

			}

			if ( dirtyNormals ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					face = obj_faces[ chunk_faces3[ f ] ];

					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;

					if ( vertexNormals.length === 3 && needsFaceNormals === false ) {

						for ( i = 0; i < 3; i ++ ) {

							vn = vertexNormals[ i ];

							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;

							offset_normal += 3;

						}

					} else {

						for ( i = 0; i < 3; i ++ ) {

							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;

							offset_normal += 3;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

			}

			if ( dirtyUvs && obj_uvs ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					fi = chunk_faces3[ f ];

					uv = obj_uvs[ fi ];

					if ( uv === undefined ) continue;

					for ( i = 0; i < 3; i ++ ) {

						uvi = uv[ i ];

						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;

						offset_uv += 2;

					}

				}

				if ( offset_uv > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

				}

			}

			if ( dirtyUvs && obj_uvs2 ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					fi = chunk_faces3[ f ];

					uv2 = obj_uvs2[ fi ];

					if ( uv2 === undefined ) continue;

					for ( i = 0; i < 3; i ++ ) {

						uv2i = uv2[ i ];

						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;

						offset_uv2 += 2;

					}

				}

				if ( offset_uv2 > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

				}

			}

			if ( dirtyElements ) {

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					faceArray[ offset_face ]   = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 2;

					offset_face += 3;

					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;

					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 2;

					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;

					offset_line += 6;

					vertexIndex += 3;

				}

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! customAttribute.__original.needsUpdate ) continue;

					offset_custom = 0;

					if ( customAttribute.size === 1 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

								offset_custom += 3;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								customAttribute.array[ offset_custom ]     = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;

								offset_custom += 3;

							}

						}

					} else if ( customAttribute.size === 2 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;

								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;

								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;

								offset_custom += 6;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom ]     = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;

								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;

								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;

								offset_custom += 6;

							}

						}

					} else if ( customAttribute.size === 3 ) {

						var pp;

						if ( customAttribute.type === 'c' ) {

							pp = [ 'r', 'g', 'b' ];

						} else {

							pp = [ 'x', 'y', 'z' ];

						}

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						} else if ( customAttribute.boundTo === 'faceVertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];

								customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

								offset_custom += 9;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								face = obj_faces[ chunk_faces3[ f ] ];

								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						} else if ( customAttribute.boundTo === 'faces' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value;
								v2 = value;
								v3 = value;

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						} else if ( customAttribute.boundTo === 'faceVertices' ) {

							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

								value = customAttribute.value[ chunk_faces3[ f ] ];

								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];

								customAttribute.array[ offset_custom  ]   = v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;

								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;

								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;

								offset_custom += 12;

							}

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

			if ( dispose ) {

				delete geometryGroup.__inittedArrays;
				delete geometryGroup.__colorArray;
				delete geometryGroup.__normalArray;
				delete geometryGroup.__tangentArray;
				delete geometryGroup.__uvArray;
				delete geometryGroup.__uv2Array;
				delete geometryGroup.__faceArray;
				delete geometryGroup.__vertexArray;
				delete geometryGroup.__lineArray;
				delete geometryGroup.__skinIndexArray;
				delete geometryGroup.__skinWeightArray;

			}

		};

		// Buffer rendering

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
			if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
			if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
			if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.position );

				_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

				if ( material instanceof THREE.MeshPhongMaterial === false &&
					   material.shading === THREE.FlatShading ) {

					var nx, ny, nz,
						nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
						normalArray,
						i, il = object.count * 3;

					for ( i = 0; i < il; i += 9 ) {

						normalArray = object.normalArray;

						nax  = normalArray[ i ];
						nay  = normalArray[ i + 1 ];
						naz  = normalArray[ i + 2 ];

						nbx  = normalArray[ i + 3 ];
						nby  = normalArray[ i + 4 ];
						nbz  = normalArray[ i + 5 ];

						ncx  = normalArray[ i + 6 ];
						ncy  = normalArray[ i + 7 ];
						ncz  = normalArray[ i + 8 ];

						nx = ( nax + nbx + ncx ) / 3;
						ny = ( nay + nby + ncy ) / 3;
						nz = ( naz + nbz + ncz ) / 3;

						normalArray[ i ]   = nx;
						normalArray[ i + 1 ] = ny;
						normalArray[ i + 2 ] = nz;

						normalArray[ i + 3 ] = nx;
						normalArray[ i + 4 ] = ny;
						normalArray[ i + 5 ] = nz;

						normalArray[ i + 6 ] = nx;
						normalArray[ i + 7 ] = ny;
						normalArray[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.normal );

				_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.uv );

				_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( program.attributes.color );

				_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.attributes;
			var programAttributesKeys = program.attributesKeys;

			for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

				var key = programAttributesKeys[ i ];
				var programAttribute = programAttributes[ key ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ key ];

					if ( geometryAttribute !== undefined ) {

						var size = geometryAttribute.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

						state.enableAttribute( programAttribute );

						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

					} else if ( material.defaultAttributeValues !== undefined ) {

						if ( material.defaultAttributeValues[ key ].length === 2 ) {

							_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

						} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

							_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

			if ( material.visible === false ) return;

			updateObject( object );

			var program = setProgram( camera, lights, fog, material, object );

			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( updateBuffers ) {

				state.initAttributes();

			}

			// render mesh

			if ( object instanceof THREE.Mesh ) {

				var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed triangles

					var type, size;

					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0 );

						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
						_this.info.render.faces += index.array.length / 3;

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed triangles

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
							_this.info.render.faces += offsets[ i ].count / 3;

						}

					}

				} else {

					// non-indexed triangles

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes[ 'position' ];

					// render non-indexed triangles

					_gl.drawArrays( mode, 0, position.array.length / position.itemSize );

					_this.info.render.calls ++;
					_this.info.render.vertices += position.array.length / position.itemSize;
					_this.info.render.faces += position.array.length / ( 3 * position.itemSize );

				}

			} else if ( object instanceof THREE.PointCloud ) {

				// render particles

				var mode = _gl.POINTS;

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed points

					var type, size;

					if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0);

						_this.info.render.calls ++;
						_this.info.render.points += index.array.length;

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						if ( offsets.length > 1 ) updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed points

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

							_this.info.render.calls ++;
							_this.info.render.points += offsets[ i ].count;

						}

					}

				} else {

					// non-indexed points

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes.position;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						_gl.drawArrays( mode, 0, position.array.length / 3 );

						_this.info.render.calls ++;
						_this.info.render.points += position.array.length / 3;

					} else {

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

							_this.info.render.calls ++;
							_this.info.render.points += offsets[ i ].count;

						}

					}

				}

			} else if ( object instanceof THREE.Line ) {

				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				state.setLineWidth( material.linewidth * pixelRatio );

				var index = geometry.attributes.index;

				if ( index ) {

					// indexed lines

					var type, size;

					if ( index.array instanceof Uint32Array ) {

						type = _gl.UNSIGNED_INT;
						size = 4;

					} else {

						type = _gl.UNSIGNED_SHORT;
						size = 2;

					}

					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, 0 );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

					} else {

						// if there is more than 1 chunk
						// must set attribute pointers to use new offsets for each chunk
						// even if geometry and materials didn't change

						if ( offsets.length > 1 ) updateBuffers = true;

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							var startIndex = offsets[ i ].index;

							if ( updateBuffers ) {

								setupVertexAttributes( material, program, geometry, startIndex );
								_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

							}

							// render indexed lines

							_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

						}

					}

				} else {

					// non-indexed lines

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );

					}

					var position = geometry.attributes.position;
					var offsets = geometry.offsets;

					if ( offsets.length === 0 ) {

						_gl.drawArrays( mode, 0, position.array.length / 3 );

						_this.info.render.calls ++;
						_this.info.render.vertices += position.array.length / 3;

					} else {

						for ( var i = 0, il = offsets.length; i < il; i ++ ) {

							_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

							_this.info.render.calls ++;
							_this.info.render.vertices += offsets[ i ].count;

						}

					}

				}

			}

		};

		this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

			if ( material.visible === false ) return;

			updateObject( object );

			var program = setProgram( camera, lights, fog, material, object );

			var attributes = program.attributes;

			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( updateBuffers ) {

				state.initAttributes();

			}

			// vertices

			if ( ! material.morphTargets && attributes.position >= 0 ) {

				if ( updateBuffers ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );

					state.enableAttribute( attributes.position );

					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

				}

			} else {

				if ( object.morphTargetBase ) {

					setupMorphTargets( material, geometryGroup, object );

				}

			}


			if ( updateBuffers ) {

				// custom attributes

				// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

				if ( geometryGroup.__webglCustomAttributesList ) {

					for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

						var attribute = geometryGroup.__webglCustomAttributesList[ i ];

						if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );

							state.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );

							_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

						}

					}

				}


				// colors

				if ( attributes.color >= 0 ) {

					if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );

						state.enableAttribute( attributes.color );

						_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

					}

				}

				// normals

				if ( attributes.normal >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );

					state.enableAttribute( attributes.normal );

					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

				}

				// tangents

				if ( attributes.tangent >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );

					state.enableAttribute( attributes.tangent );

					_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

				}

				// uvs

				if ( attributes.uv >= 0 ) {

					if ( object.geometry.faceVertexUvs[ 0 ] ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );

						state.enableAttribute( attributes.uv );

						_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

					}

				}

				if ( attributes.uv2 >= 0 ) {

					if ( object.geometry.faceVertexUvs[ 1 ] ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );

						state.enableAttribute( attributes.uv2 );

						_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

					} else if ( material.defaultAttributeValues !== undefined ) {


						_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

					}

				}

				if ( material.skinning &&
					 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );

					state.enableAttribute( attributes.skinIndex );

					_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );

					state.enableAttribute( attributes.skinWeight );

					_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

				}

				// line distances

				if ( attributes.lineDistance >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );

					state.enableAttribute( attributes.lineDistance );

					_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

				}

			}

			state.disableUnusedAttributes();

			// render mesh

			if ( object instanceof THREE.Mesh ) {

				var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

				// wireframe

				if ( material.wireframe ) {

					state.setLineWidth( material.wireframeLinewidth * pixelRatio );

					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
					_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

				// triangles

				} else {

					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
					_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

				}

				_this.info.render.calls ++;
				_this.info.render.vertices += geometryGroup.__webglFaceCount;
				_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

			// render lines

			} else if ( object instanceof THREE.Line ) {

				var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

				state.setLineWidth( material.linewidth * pixelRatio );

				_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

				_this.info.render.calls ++;

			// render particles

			} else if ( object instanceof THREE.PointCloud ) {

				_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

				_this.info.render.calls ++;
				_this.info.render.points += geometryGroup.__webglParticleCount;

			}

		};

		function setupMorphTargets ( material, geometryGroup, object ) {

			// set base

			var attributes = material.program.attributes;

			if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );

				state.enableAttribute( attributes.position );

				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			} else if ( attributes.position >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );

				state.enableAttribute( attributes.position );

				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.morphTargetForcedOrder.length ) {

				// set forced order

				var m = 0;
				var order = object.morphTargetForcedOrder;
				var influences = object.morphTargetInfluences;

				var attribute;

				while ( m < material.numSupportedMorphTargets && m < order.length ) {

					attribute = attributes[ 'morphTarget' + m ];

					if ( attribute >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );

						state.enableAttribute( attribute );

						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

					}

					attribute = attributes[ 'morphNormal' + m ];

					if ( attribute >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );

						state.enableAttribute( attribute );

						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

					m ++;

				}

			} else {

				// find the most influencing

				var activeInfluenceIndices = [];
				var influences = object.morphTargetInfluences;
				var morphTargets = object.geometry.morphTargets;

				if ( influences.length > morphTargets.length ) {

					console.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );
					influences.length = morphTargets.length;

				}

				for ( var i = 0, il = influences.length; i < il; i ++ ) {

					var influence = influences[ i ];

					activeInfluenceIndices.push( [ influence, i ] );

				}

				if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

					activeInfluenceIndices.sort( numericalSort );
					activeInfluenceIndices.length = material.numSupportedMorphTargets;

				} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

					activeInfluenceIndices.sort( numericalSort );

				} else if ( activeInfluenceIndices.length === 0 ) {

					activeInfluenceIndices.push( [ 0, 0 ] );

				}

				var attribute;

				for ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {

					if ( activeInfluenceIndices[ m ] ) {

						var influenceIndex = activeInfluenceIndices[ m ][ 1 ];

						attribute = attributes[ 'morphTarget' + m ];

						if ( attribute >= 0 ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );

							state.enableAttribute( attribute );

							_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

						}

						attribute = attributes[ 'morphNormal' + m ];

						if ( attribute >= 0 && material.morphNormals ) {

							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );

							state.enableAttribute( attribute );

							_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

						}

						object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

					} else {

						/*
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

						if ( material.morphNormals ) {

							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

						}
						*/

						object.__webglMorphTargetInfluences[ m ] = 0;

					}

				}

			}

			// load updated influences uniform

			if ( material.program.uniforms.morphTargetInfluences !== null ) {

				_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

			}

		}

		// Sorting

		function painterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} else if ( a.material.id !== b.material.id ) {

				return a.material.id - b.material.id;

			} else if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		function numericalSort ( a, b ) {

			return b[ 0 ] - a[ 0 ];

		}

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( camera instanceof THREE.Camera === false ) {

				THREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === undefined ) camera.updateMatrixWorld();

			// update Skeleton objects

			scene.traverse( function ( object ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

			} );

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lights.length = 0;
			opaqueObjects.length = 0;
			transparentObjects.length = 0;

			sprites.length = 0;
			lensFlares.length = 0;

			projectObject( scene );

			if ( _this.sortObjects === true ) {

				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );

			}

			// custom render plugins (pre pass)

			shadowMapPlugin.render( scene, camera );

			//

			_this.info.render.calls = 0;
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_this.info.render.points = 0;

			this.setRenderTarget( renderTarget );

			if ( this.autoClear || forceClear ) {

				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

			}

			// set matrices for immediate objects

			for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

				var webglObject = _webglObjectsImmediate[ i ];
				var object = webglObject.object;

				if ( object.visible ) {

					setupMatrices( object, camera );

					unrollImmediateBufferMaterial( webglObject );

				}

			}

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				setMaterial( overrideMaterial );

				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
				renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				state.setBlending( THREE.NoBlending );

				renderObjects( opaqueObjects, camera, lights, fog, null );
				renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog, null );
				renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );

			}

			// custom render plugins (post pass)

			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

				updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );

			// _gl.finish();

		};

		function projectObject( object ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

				// skip

			} else {

				initObject( object );

				if ( object instanceof THREE.Light ) {

					lights.push( object );

				} else if ( object instanceof THREE.Sprite ) {

					sprites.push( object );

				} else if ( object instanceof THREE.LensFlare ) {

					lensFlares.push( object );

				} else {

					var webglObjects = _webglObjects[ object.id ];

					if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

						for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

							var webglObject = webglObjects[ i ];

							unrollBufferMaterial( webglObject );

							webglObject.render = true;

							if ( _this.sortObjects === true ) {

								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );

								webglObject.z = _vector3.z;

							}

						}

					}

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( object.children[ i ] );

			}

		}

		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

			var material;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var webglObject = renderList[ i ];

				var object = webglObject.object;
				var buffer = webglObject.buffer;

				setupMatrices( object, camera );

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject.material;

					if ( ! material ) continue;

					setMaterial( material );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

		function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {

			var material;

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var webglObject = renderList[ i ];
				var object = webglObject.object;

				if ( object.visible ) {

					if ( overrideMaterial ) {

						material = overrideMaterial;

					} else {

						material = webglObject[ materialType ];

						if ( ! material ) continue;

						setMaterial( material );

					}

					_this.renderImmediateObject( camera, lights, fog, material, object );

				}

			}

		}

		this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

			var program = setProgram( camera, lights, fog, material, object );

			_currentGeometryProgram = '';

			_this.setMaterialFaces( material );

			if ( object.immediateRenderCallback ) {

				object.immediateRenderCallback( program, _gl, _frustum );

			} else {

				object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

			}

		};

		function unrollImmediateBufferMaterial ( globject ) {

			var object = globject.object,
				material = object.material;

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		}

		function unrollBufferMaterial ( globject ) {

			var object = globject.object;
			var buffer = globject.buffer;

			var geometry = object.geometry;
			var material = object.material;

			if ( material instanceof THREE.MeshFaceMaterial ) {

				var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

				material = material.materials[ materialIndex ];

				globject.material = material;

				if ( material.transparent ) {

					transparentObjects.push( globject );

				} else {

					opaqueObjects.push( globject );

				}

			} else if ( material ) {

				globject.material = material;

				if ( material.transparent ) {

					transparentObjects.push( globject );

				} else {

					opaqueObjects.push( globject );

				}

			}

		}

		function initObject( object ) {

			if ( object.__webglInit === undefined ) {

				object.__webglInit = true;
				object._modelViewMatrix = new THREE.Matrix4();
				object._normalMatrix = new THREE.Matrix3();

				object.addEventListener( 'removed', onObjectRemoved );

			}

			var geometry = object.geometry;

			if ( geometry === undefined ) {

				// ImmediateRenderObject

			} else if ( geometry.__webglInit === undefined ) {

				geometry.__webglInit = true;
				geometry.addEventListener( 'dispose', onGeometryDispose );

				if ( geometry instanceof THREE.BufferGeometry ) {

					_this.info.memory.geometries ++;

				} else if ( object instanceof THREE.Mesh ) {

					initGeometryGroups( object, geometry );

				} else if ( object instanceof THREE.Line ) {

					if ( geometry.__webglVertexBuffer === undefined ) {

						createLineBuffers( geometry );
						initLineBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
						geometry.lineDistancesNeedUpdate = true;

					}

				} else if ( object instanceof THREE.PointCloud ) {

					if ( geometry.__webglVertexBuffer === undefined ) {

						createParticleBuffers( geometry );
						initParticleBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					}

				}

			}

			if ( object.__webglActive === undefined) {

				object.__webglActive = true;

				if ( object instanceof THREE.Mesh ) {

					if ( geometry instanceof THREE.BufferGeometry ) {

						addBuffer( _webglObjects, geometry, object );

					} else if ( geometry instanceof THREE.Geometry ) {

						var geometryGroupsList = geometryGroups[ geometry.id ];

						for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

							addBuffer( _webglObjects, geometryGroupsList[ i ], object );

						}

					}

				} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

					addBufferImmediate( _webglObjectsImmediate, object );

				}

			}

		}

		// Geometry splitting

		var geometryGroups = {};
		var geometryGroupCounter = 0;

		function makeGroups( geometry, usesFaceMaterial ) {

			var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

			var groupHash, hash_map = {};

			var numMorphTargets = geometry.morphTargets.length;
			var numMorphNormals = geometry.morphNormals.length;

			var group;
			var groups = {};
			var groupsList = [];

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];
				var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

				if ( ! ( materialIndex in hash_map ) ) {

					hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

				}

				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};

					groups[ groupHash ] = group;
					groupsList.push( group );

				}

				if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

					if ( ! ( groupHash in groups ) ) {

						group = {
							id: geometryGroupCounter ++,
							faces3: [],
							materialIndex: materialIndex,
							vertices: 0,
							numMorphTargets: numMorphTargets,
							numMorphNormals: numMorphNormals
						};

						groups[ groupHash ] = group;
						groupsList.push( group );

					}

				}

				groups[ groupHash ].faces3.push( f );
				groups[ groupHash ].vertices += 3;

			}

			return groupsList;

		}

		function initGeometryGroups( object, geometry ) {

			var material = object.material, addBuffers = false;

			if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

				delete _webglObjects[ object.id ];

				geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

				geometry.groupsNeedUpdate = false;

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			// create separate VBOs per geometry chunk

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				// initialise VBO on the first access

				if ( geometryGroup.__webglVertexBuffer === undefined ) {

					createMeshBuffers( geometryGroup );
					initMeshBuffers( geometryGroup, object );

					geometry.verticesNeedUpdate = true;
					geometry.morphTargetsNeedUpdate = true;
					geometry.elementsNeedUpdate = true;
					geometry.uvsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;
					geometry.tangentsNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

					addBuffers = true;

				} else {

					addBuffers = false;

				}

				if ( addBuffers || object.__webglActive === undefined ) {

					addBuffer( _webglObjects, geometryGroup, object );

				}

			}

			object.__webglActive = true;

		}

		function addBuffer( objlist, buffer, object ) {

			var id = object.id;
			objlist[id] = objlist[id] || [];
			objlist[id].push(
				{
					id: id,
					buffer: buffer,
					object: object,
					material: null,
					z: 0
				}
			);

		};

		function addBufferImmediate( objlist, object ) {

			objlist.push(
				{
					id: null,
					object: object,
					opaque: null,
					transparent: null,
					z: 0
				}
			);

		};

		// Objects updates

		function updateObject( object ) {

			var geometry = object.geometry;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var attributes = geometry.attributes;
				var attributesKeys = geometry.attributesKeys;

				for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

					var key = attributesKeys[ i ];
					var attribute = attributes[ key ];
					var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

					if ( attribute.buffer === undefined ) {

						attribute.buffer = _gl.createBuffer();
						_gl.bindBuffer( bufferType, attribute.buffer );
						_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );

						attribute.needsUpdate = false;

					} else if ( attribute.needsUpdate === true ) {

						_gl.bindBuffer( bufferType, attribute.buffer );

						if ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges

							_gl.bufferSubData( bufferType, 0, attribute.array );

						} else if ( attribute.updateRange.count === 0 ) {

							console.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );

						} else {

							_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,
											   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );

							attribute.updateRange.count = 0; // reset range

						}

						attribute.needsUpdate = false;

					}

				}

			} else if ( object instanceof THREE.Mesh ) {

				// check all geometry groups

				if ( geometry.groupsNeedUpdate === true ) {

					initGeometryGroups( object, geometry );

				}

				var geometryGroupsList = geometryGroups[ geometry.id ];

				for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];
					var material = getBufferMaterial( object, geometryGroup );

					var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			} else if ( object instanceof THREE.Line ) {

				var material = getBufferMaterial( object, geometry );
				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

					setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.lineDistancesNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			} else if ( object instanceof THREE.PointCloud ) {

				var material = getBufferMaterial( object, geometry );
				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {

					setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			}

		}

		// Objects updates - custom attributes check

		function areCustomAttributesDirty( material ) {

			for ( var name in material.attributes ) {

				if ( material.attributes[ name ].needsUpdate ) return true;

			}

			return false;

		}

		function clearCustomAttributes( material ) {

			for ( var name in material.attributes ) {

				material.attributes[ name ].needsUpdate = false;

			}

		}

		// Objects removal

		function removeObject( object ) {

			if ( object instanceof THREE.Mesh  ||
				 object instanceof THREE.PointCloud ||
				 object instanceof THREE.Line ) {

				delete _webglObjects[ object.id ];

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				removeInstances( _webglObjectsImmediate, object );

			}

			delete object.__webglInit;
			delete object._modelViewMatrix;
			delete object._normalMatrix;

			delete object.__webglActive;

		}

		function removeInstances( objlist, object ) {

			for ( var o = objlist.length - 1; o >= 0; o -- ) {

				if ( objlist[ o ].object === object ) {

					objlist.splice( o, 1 );

				}

			}

		}

		// Materials

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointCloudMaterial: 'particle_basic'
		};

		function initMaterial( material, lights, fog, object ) {

			material.addEventListener( 'dispose', onMaterialDispose );

			var shaderID = shaderIDs[ material.type ];

			if ( shaderID ) {

				var shader = THREE.ShaderLib[ shaderID ];

				material.__webglShader = {
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				}

			} else {

				material.__webglShader = {
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				}

			}

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxLightCount = allocateLights( lights );
			var maxShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );

			var parameters = {

				precision: _precision,
				supportsVertexTextures: _supportsVertexTextures,

				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				flatShading: material.shading === THREE.FlatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: _logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: _this.maxMorphTargets,
				maxMorphNormals: _this.maxMorphNormals,

				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,

				maxShadows: maxShadows,
				shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
				shadowMapType: _this.shadowMapType,
				shadowMapDebug: _this.shadowMapDebug,
				shadowMapCascade: _this.shadowMapCascade,

				alphaTest: material.alphaTest,
				metal: material.metal,
				wrapAround: material.wrapAround,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide

			};

			// Generate code

			var chunks = [];

			if ( shaderID ) {

				chunks.push( shaderID );

			} else {

				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					chunks.push( name );
					chunks.push( material.defines[ name ] );

				}

			}

			for ( var name in parameters ) {

				chunks.push( name );
				chunks.push( parameters[ name ] );

			}

			var code = chunks.join();

			var program;

			// Check if code has been already compiled

			for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

				var programInfo = _programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					program.usedTimes ++;

					break;

				}

			}

			if ( program === undefined ) {

				program = new THREE.WebGLProgram( _this, code, material, parameters );
				_programs.push( program );

				_this.info.memory.programs = _programs.length;

			}

			material.program = program;

			var attributes = program.attributes;

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				var id, base = 'morphTarget';

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					id = base + i;

					if ( attributes[ id ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				var id, base = 'morphNormal';

				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

					id = base + i;

					if ( attributes[ id ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			material.uniformsList = [];

			for ( var u in material.__webglShader.uniforms ) {

				var location = material.program.uniforms[ u ];

				if ( location ) {
					material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
				}

			}

		}

		function setMaterial( material ) {

			if ( material.transparent === true ) {

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

			} else {

				state.setBlending( THREE.NoBlending );

			}

			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		function setProgram( camera, lights, fog, material, object ) {

			_usedTextureUnits = 0;

			if ( material.needsUpdate ) {

				if ( material.program ) deallocateMaterial( material );

				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;

			}

			if ( material.morphTargets ) {

				if ( ! object.__webglMorphTargetInfluences ) {

					object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

				}

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = material.program,
				p_uniforms = program.uniforms,
				m_uniforms = material.__webglShader.uniforms;

			if ( program.id !== _currentProgram ) {

				_gl.useProgram( program.program );
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				if ( _currentMaterialId === -1 ) refreshLights = true;
				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				if ( _logarithmicDepthBuffer ) {

					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}


				if ( camera !== _currentCamera ) _currentCamera = camera;

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {

					if ( p_uniforms.cameraPosition !== null ) {

						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

					}

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {

					if ( p_uniforms.viewMatrix !== null ) {

						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

					}

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

				}

				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

				}

				if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

					if ( p_uniforms.boneTexture !== null ) {

						var textureUnit = getTextureUnit();

						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );

					}

					if ( p_uniforms.boneTextureWidth !== null ) {

						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

					}

					if ( p_uniforms.boneTextureHeight !== null ) {

						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

					}

				} else if ( object.skeleton && object.skeleton.boneMatrices ) {

					if ( p_uniforms.boneGlobalMatrices !== null ) {

						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

					}

				}

			}

			if ( refreshMaterial ) {

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {

					if ( _lightsNeedUpdate ) {

						refreshLights = true;
						setupLights( lights );
						_lightsNeedUpdate = false;
					}

					if ( refreshLights ) {
						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );
					} else {
						markUniformsLightsNeedsUpdate( m_uniforms, false );
					}

				}

				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				}

				// refresh single material specific uniforms

				if ( material instanceof THREE.LineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

				} else if ( material instanceof THREE.LineDashedMaterial ) {

					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );

				} else if ( material instanceof THREE.PointCloudMaterial ) {

					refreshUniformsParticle( m_uniforms, material );

				} else if ( material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsPhong( m_uniforms, material );

				} else if ( material instanceof THREE.MeshLambertMaterial ) {

					refreshUniformsLambert( m_uniforms, material );

				} else if ( material instanceof THREE.MeshDepthMaterial ) {

					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;

				} else if ( material instanceof THREE.MeshNormalMaterial ) {

					m_uniforms.opacity.value = material.opacity;

				}

				if ( object.receiveShadow && ! material._shadowPass ) {

					refreshUniformsShadow( m_uniforms, lights );

				}

				// load common uniforms

				loadUniformsGeneric( material.uniformsList );

			}

			loadUniformsMatrices( p_uniforms, object );

			if ( p_uniforms.modelMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon ( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value = material.color;

			uniforms.map.value = material.map;
			uniforms.lightMap.value = material.lightMap;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			// uv repeat and offset setting priorities
			//  1. color map
			//  2. specular map
			//  3. normal map
			//  4. bump map
			//  5. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		function refreshUniformsLine ( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash ( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsParticle ( uniforms, material ) {

			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				var offset = material.map.offset;
				var repeat = material.map.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

		}

		function refreshUniformsFog ( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog instanceof THREE.Fog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog instanceof THREE.FogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsPhong ( uniforms, material ) {

			uniforms.shininess.value = material.shininess;

			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

			if ( material.wrapAround ) {

				uniforms.wrapRGB.value.copy( material.wrapRGB );

			}

		}

		function refreshUniformsLambert ( uniforms, material ) {

			uniforms.emissive.value = material.emissive;

			if ( material.wrapAround ) {

				uniforms.wrapRGB.value.copy( material.wrapRGB );

			}

		}

		function refreshUniformsLights ( uniforms, lights ) {

			uniforms.ambientLightColor.value = lights.ambient;

			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;

			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;

			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;

			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate ( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;

			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;

			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;

			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;

		}

		function refreshUniformsShadow ( uniforms, lights ) {

			if ( uniforms.shadowMatrix ) {

				var j = 0;

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];

					if ( ! light.castShadow ) continue;

					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;

						j ++;

					}

				}

			}

		}

		// Uniforms (load to GPU)

		function loadUniformsMatrices ( uniforms, object ) {

			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

			if ( uniforms.normalMatrix ) {

				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

			}

		}

		function getTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= _maxTextures ) {

				THREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		function loadUniformsGeneric ( uniforms ) {

			var texture, textureUnit, offset;

			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

				var uniform = uniforms[ j ][ 0 ];

				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;

				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];

				switch ( type ) {

					case '1i':
						_gl.uniform1i( location, value );
						break;

					case '1f':
						_gl.uniform1f( location, value );
						break;

					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;

					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;

					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;

					case '1iv':
						_gl.uniform1iv( location, value );
						break;

					case '3iv':
						_gl.uniform3iv( location, value );
						break;

					case '1fv':
						_gl.uniform1fv( location, value );
						break;

					case '2fv':
						_gl.uniform2fv( location, value );
						break;

					case '3fv':
						_gl.uniform3fv( location, value );
						break;

					case '4fv':
						_gl.uniform4fv( location, value );
						break;

					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;

					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;

					//

					case 'i':

						// single integer
						_gl.uniform1i( location, value );

						break;

					case 'f':

						// single float
						_gl.uniform1f( location, value );

						break;

					case 'v2':

						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );

						break;

					case 'v3':

						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );

						break;

					case 'v4':

						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );

						break;

					case 'c':

						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );

						break;

					case 'iv1':

						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );

						break;

					case 'iv':

						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );

						break;

					case 'fv1':

						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );

						break;

					case 'fv':

						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );

						break;

					case 'v2v':

						// array of THREE.Vector2

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 2 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 2;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;

						}

						_gl.uniform2fv( location, uniform._array );

						break;

					case 'v3v':

						// array of THREE.Vector3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 3 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 3;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;

						}

						_gl.uniform3fv( location, uniform._array );

						break;

					case 'v4v':

						// array of THREE.Vector4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 4 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							offset = i * 4;

							uniform._array[ offset ]   = value[ i ].x;
							uniform._array[ offset + 1 ] = value[ i ].y;
							uniform._array[ offset + 2 ] = value[ i ].z;
							uniform._array[ offset + 3 ] = value[ i ].w;

						}

						_gl.uniform4fv( location, uniform._array );

						break;

					case 'm3':

						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );

						break;

					case 'm3v':

						// array of THREE.Matrix3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 9 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

						}

						_gl.uniformMatrix3fv( location, false, uniform._array );

						break;

					case 'm4':

						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );

						break;

					case 'm4v':

						// array of THREE.Matrix4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 16 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

						}

						_gl.uniformMatrix4fv( location, false, uniform._array );

						break;

					case 't':

						// single THREE.Texture (2d or cube)

						texture = value;
						textureUnit = getTextureUnit();

						_gl.uniform1i( location, textureUnit );

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
						   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

						break;

					case 'tv':

						// array of THREE.Texture (2d)

						if ( uniform._array === undefined ) {

							uniform._array = [];

						}

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							uniform._array[ i ] = getTextureUnit();

						}

						_gl.uniform1iv( location, uniform._array );

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];

							if ( ! texture ) continue;

							_this.setTexture( texture, textureUnit );

						}

						break;

					default:

						THREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

				}

			}

		}

		function setupMatrices ( object, camera ) {

			object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

		}

		function setColorLinear( array, offset, color, intensity ) {

			array[ offset ]     = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;

		}

		function setupLights ( lights ) {

			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,

			zlights = _lights,

			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,

			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,

			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,

			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,

			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];

				if ( light.onlyShadow ) continue;

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				if ( light instanceof THREE.AmbientLight ) {

					if ( ! light.visible ) continue;

					r += color.r;
					g += color.g;
					b += color.b;

				} else if ( light instanceof THREE.DirectionalLight ) {

					dirCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();

					dirOffset = dirLength * 3;

					dirPositions[ dirOffset ]     = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;

					setColorLinear( dirColors, dirOffset, color, intensity );

					dirLength += 1;

				} else if ( light instanceof THREE.PointLight ) {

					pointCount += 1;

					if ( ! light.visible ) continue;

					pointOffset = pointLength * 3;

					setColorLinear( pointColors, pointOffset, color, intensity );

					_vector3.setFromMatrixPosition( light.matrixWorld );

					pointPositions[ pointOffset ]     = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;

					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					pointLength += 1;

				} else if ( light instanceof THREE.SpotLight ) {

					spotCount += 1;

					if ( ! light.visible ) continue;

					spotOffset = spotLength * 3;

					setColorLinear( spotColors, spotOffset, color, intensity );

					_direction.setFromMatrixPosition( light.matrixWorld );

					spotPositions[ spotOffset ]     = _direction.x;
					spotPositions[ spotOffset + 1 ] = _direction.y;
					spotPositions[ spotOffset + 2 ] = _direction.z;

					spotDistances[ spotLength ] = distance;

					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();

					spotDirections[ spotOffset ]     = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;

					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					spotLength += 1;

				} else if ( light instanceof THREE.HemisphereLight ) {

					hemiCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.normalize();

					hemiOffset = hemiLength * 3;

					hemiPositions[ hemiOffset ]     = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;

					skyColor = light.color;
					groundColor = light.groundColor;

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

					hemiLength += 1;

				}

			}

			// null eventual remains from removed lights
			// (this is to avoid if in shader)

			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;

			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			if ( cullFace === THREE.CullFaceNone ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				if ( cullFace === THREE.CullFaceBack ) {

					_gl.cullFace( _gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					_gl.cullFace( _gl.FRONT );

				} else {

					_gl.cullFace( _gl.FRONT_AND_BACK );

				}

				_gl.enable( _gl.CULL_FACE );

			}

		};

		this.setMaterialFaces = function ( material ) {

			state.setDoubleSided( material.side === THREE.DoubleSide );
			state.setFlipSided( material.side === THREE.BackSide );

		};

		// Textures

		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

			var extension;

			if ( isImagePowerOfTwo ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

					THREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

					THREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {

				if ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					texture.__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		this.uploadTexture = function ( texture ) {

			if ( texture.__webglInit === undefined ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			texture.image = clampToMaxSize( texture.image, _maxTextureSize );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

						if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

							_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							THREE.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

						}

					} else {

						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		};

		this.setTexture = function ( texture, slot ) {

			_gl.activeTexture( _gl.TEXTURE0 + slot );

			if ( texture.needsUpdate ) {

				_this.uploadTexture( texture );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			}

		};

		function clampToMaxSize ( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				THREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function setCubeTexture ( texture, slot ) {

			if ( texture.image.length === 6 ) {

				if ( texture.needsUpdate ) {

					if ( ! texture.image.__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						texture.image.__webglTextureCube = _gl.createTexture();

						_this.info.memory.textures ++;

					}

					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

									if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

										_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										THREE.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

									}

								} else {

									_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( texture.generateMipmaps && isImagePowerOfTwo ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					texture.needsUpdate = false;

					if ( texture.onUpdate ) texture.onUpdate();

				} else {

					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				}

			}

		}

		function setCubeTextureDynamic ( texture, slot ) {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

		}

		// Render targets

		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

		}

		function setupRenderBuffer ( renderbuffer, renderTarget  ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

		}

		this.setRenderTarget = function ( renderTarget ) {

			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

			if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				renderTarget.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

				// Setup texture, create render and frame buffers

				var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );

				if ( isCube ) {

					renderTarget.__webglFramebuffer = [];
					renderTarget.__webglRenderbuffer = [];

					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

						setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

					}

					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				} else {

					renderTarget.__webglFramebuffer = _gl.createFramebuffer();

					if ( renderTarget.shareDepthFrom ) {

						renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

					} else {

						renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

					}

					_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

					if ( renderTarget.shareDepthFrom ) {

						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

						}

					} else {

						setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

					}

					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

				}

				// Release everything

				if ( isCube ) {

					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					_gl.bindTexture( _gl.TEXTURE_2D, null );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			var framebuffer, width, height, vx, vy;

			if ( renderTarget ) {

				if ( isCube ) {

					framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

				} else {

					framebuffer = renderTarget.__webglFramebuffer;

				}

				width = renderTarget.width;
				height = renderTarget.height;

				vx = 0;
				vy = 0;

			} else {

				framebuffer = null;

				width = _viewportWidth;
				height = _viewportHeight;

				vx = _viewportX;
				vy = _viewportY;

			}

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );

				_currentFramebuffer = framebuffer;

			}

			_currentWidth = width;
			_currentHeight = height;

		};

		this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			if ( renderTarget.__webglFramebuffer ) {

				if ( renderTarget.format !== THREE.RGBAFormat ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
					return;

				}

				var restore = false;

				if ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );

					restore = true;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		};

		function updateRenderTargetMipmap ( renderTarget ) {

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback ( f ) {

			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		// Map three.js constants to WebGL constants

		function paramThreeToGL ( p ) {

			var extension;

			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

			}

			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

			}

			return 0;

		}

		// Allocations

		function allocateBones ( object ) {

			if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader
				//   to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = nVertexMatrices;

				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

					maxBones = Math.min( object.skeleton.bones.length, maxBones );

					if ( maxBones < object.skeleton.bones.length ) {

						THREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function allocateLights( lights ) {

			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( light.onlyShadow || light.visible === false ) continue;

				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

			}

			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

		}

		function allocateShadows( lights ) {

			var maxShadows = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

			}

			return maxShadows;

		}

		// DEPRECATED

		this.initMaterial = function () {

			THREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		};

		this.addPrePlugin = function () {

			THREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		};

		this.addPostPlugin = function () {

			THREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		};

		this.updateShadowMap = function () {

			THREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		};

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.WebGLRenderTarget = function ( width, height, options ) {

		this.width = width;
		this.height = height;

		options = options || {};

		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

		this.generateMipmaps = true;

		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

	};

	THREE.WebGLRenderTarget.prototype = {

		constructor: THREE.WebGLRenderTarget,

		setSize: function ( width, height ) {

			this.width = width;
			this.height = height;

		},

		clone: function () {

			var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

			tmp.wrapS = this.wrapS;
			tmp.wrapT = this.wrapT;

			tmp.magFilter = this.magFilter;
			tmp.minFilter = this.minFilter;

			tmp.anisotropy = this.anisotropy;

			tmp.offset.copy( this.offset );
			tmp.repeat.copy( this.repeat );

			tmp.format = this.format;
			tmp.type = this.type;

			tmp.depthBuffer = this.depthBuffer;
			tmp.stencilBuffer = this.stencilBuffer;

			tmp.generateMipmaps = this.generateMipmaps;

			tmp.shareDepthFrom = this.shareDepthFrom;

			return tmp;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function ( width, height, options ) {

		THREE.WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

	// File:src/renderers/webgl/WebGLExtensions.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLExtensions = function ( gl ) {

		var extensions = {};

		this.get = function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				THREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = ( function () {

		var programIdCount = 0;

		var generateDefines = function ( defines ) {

			var value, chunk, chunks = [];

			for ( var d in defines ) {

				value = defines[ d ];
				if ( value === false ) continue;

				chunk = '#define ' + d + ' ' + value;
				chunks.push( chunk );

			}

			return chunks.join( '\n' );

		};

		var cacheUniformLocations = function ( gl, program, identifiers ) {

			var uniforms = {};

			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

				var id = identifiers[ i ];
				uniforms[ id ] = gl.getUniformLocation( program, id );

			}

			return uniforms;

		};

		var cacheAttributeLocations = function ( gl, program, identifiers ) {

			var attributes = {};

			for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

				var id = identifiers[ i ];
				attributes[ id ] = gl.getAttribLocation( program, id );

			}

			return attributes;

		};

		return function ( renderer, code, material, parameters ) {

			var _this = renderer;
			var _gl = _this.context;

			var defines = material.defines;
			var uniforms = material.__webglShader.uniforms;
			var attributes = material.attributes;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var index0AttributeName = material.index0AttributeName;

			if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0

				index0AttributeName = 'position';

			}

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customDefines = generateDefines( defines );

			//

			var program = _gl.createProgram();

			var prefix_vertex, prefix_fragment;

			if ( material instanceof THREE.RawShaderMaterial ) {

				prefix_vertex = '';
				prefix_fragment = '';

			} else {

				prefix_vertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					_this.gammaInput ? '#define GAMMA_INPUT' : '',
					_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED': '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
					parameters.wrapAround ? '#define WRAP_AROUND' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',


					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
					'attribute vec2 uv2;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					''

				].join( '\n' );

				prefix_fragment = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					( parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',

					customDefines,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					_this.gammaInput ? '#define GAMMA_INPUT' : '',
					_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED': '',

					parameters.metal ? '#define METAL' : '',
					parameters.wrapAround ? '#define WRAP_AROUND' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
					''

				].join( '\n' );

			}

			var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
			var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

			_gl.attachShader( program, glVertexShader );
			_gl.attachShader( program, glFragmentShader );

			if ( index0AttributeName !== undefined ) {

				// Force a particular attribute to index 0.
				// because potentially expensive emulation is done by browser if attribute 0 is disabled.
				// And, color, for example is often automatically bound to index 0 so disabling it

				_gl.bindAttribLocation( program, 0, index0AttributeName );

			}

			_gl.linkProgram( program );

			var programLogInfo = _gl.getProgramInfoLog( program );

			if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

				THREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );

			}

			if ( programLogInfo !== '' ) {

				THREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );
				// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
				// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

			}

			// clean up

			_gl.deleteShader( glVertexShader );
			_gl.deleteShader( glFragmentShader );

			// cache uniform locations

			var identifiers = [

				'viewMatrix',
				'modelViewMatrix',
				'projectionMatrix',
				'normalMatrix',
				'modelMatrix',
				'cameraPosition',
				'morphTargetInfluences',
				'bindMatrix',
				'bindMatrixInverse'

			];

			if ( parameters.useVertexTexture ) {

				identifiers.push( 'boneTexture' );
				identifiers.push( 'boneTextureWidth' );
				identifiers.push( 'boneTextureHeight' );

			} else {

				identifiers.push( 'boneGlobalMatrices' );

			}

			if ( parameters.logarithmicDepthBuffer ) {

				identifiers.push('logDepthBufFC');

			}


			for ( var u in uniforms ) {

				identifiers.push( u );

			}

			this.uniforms = cacheUniformLocations( _gl, program, identifiers );

			// cache attributes locations

			identifiers = [

				'position',
				'normal',
				'uv',
				'uv2',
				'tangent',
				'color',
				'skinIndex',
				'skinWeight',
				'lineDistance'

			];

			for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

				identifiers.push( 'morphTarget' + i );

			}

			for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

				identifiers.push( 'morphNormal' + i );

			}

			for ( var a in attributes ) {

				identifiers.push( a );

			}

			this.attributes = cacheAttributeLocations( _gl, program, identifiers );
			this.attributesKeys = Object.keys( this.attributes );

			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	} )();

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = ( function () {

		var addLineNumbers = function ( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		};

		return function ( gl, type, string ) {

			var shader = gl.createShader( type ); 

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				THREE.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				THREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	} )();

	// File:src/renderers/webgl/WebGLState.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLState = function ( gl, paramThreeToGL ) {

		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;

		var currentDepthTest = null;
		var currentDepthWrite = null;

		var currentColorWrite = null;

		var currentDoubleSided = null;
		var currentFlipSided = null;

		var currentLineWidth = null;

		var currentPolygonOffset = null;
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		this.initAttributes = function () {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		};

		this.enableAttribute = function ( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

		};

		this.disableUnusedAttributes = function () {

			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		};

		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

			if ( blending !== currentBlending ) {

				if ( blending === THREE.NoBlending ) {

					gl.disable( gl.BLEND );

				} else if ( blending === THREE.AdditiveBlending ) {

					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				} else if ( blending === THREE.SubtractiveBlending ) {

					// TODO: Find blendFuncSeparate() combination
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				} else if ( blending === THREE.MultiplyBlending ) {

					// TODO: Find blendFuncSeparate() combination
					gl.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				} else if ( blending === THREE.CustomBlending ) {

					gl.enable( gl.BLEND );

				} else {

					gl.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

				currentBlending = blending;

			}

			if ( blending === THREE.CustomBlending ) {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			} else {

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			}

		};

		this.setDepthTest = function ( depthTest ) {

			if ( currentDepthTest !== depthTest ) {

				if ( depthTest ) {

					gl.enable( gl.DEPTH_TEST );

				} else {

					gl.disable( gl.DEPTH_TEST );

				}

				currentDepthTest = depthTest;

			}

		};

		this.setDepthWrite = function ( depthWrite ) {

			if ( currentDepthWrite !== depthWrite ) {

				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;

			}

		};

		this.setColorWrite = function ( colorWrite ) {

			if ( currentColorWrite !== colorWrite ) {

				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;

			}

		};

		this.setDoubleSided = function ( doubleSided ) {

			if ( currentDoubleSided !== doubleSided ) {

				if ( doubleSided ) {

					gl.disable( gl.CULL_FACE );

				} else {

					gl.enable( gl.CULL_FACE );

				}

				currentDoubleSided = doubleSided;

			}

		};

		this.setFlipSided = function ( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		};

		this.setLineWidth = function ( width ) {

			if ( width !== currentLineWidth ) {

				gl.lineWidth( width );

				currentLineWidth = width;

			}

		};

		this.setPolygonOffset = function ( polygonoffset, factor, units ) {

			if ( currentPolygonOffset !== polygonoffset ) {

				if ( polygonoffset ) {

					gl.enable( gl.POLYGON_OFFSET_FILL );

				} else {

					gl.disable( gl.POLYGON_OFFSET_FILL );

				}

				currentPolygonOffset = polygonoffset;

			}

			if ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		};

		this.reset = function () {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				enabledAttributes[ i ] = 0;

			}

			currentBlending = null;
			currentDepthTest = null;
			currentDepthWrite = null;
			currentColorWrite = null;
			currentDoubleSided = null;
			currentFlipSided = null;

		};

	};

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function ( renderer, flares ) {

		var gl = renderer.context;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;

		var tempTexture, occlusionTexture;

		var init = function () {

			var vertices = new Float32Array( [
				-1, -1,  0, 0,
				 1, -1,  1, 0,
				 1,  1,  1, 1,
				-1,  1,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();

			gl.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

			var shader;

			if ( hasVertexTexture ) {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			} else {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if( renderType == 2 ) {",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"precision mediump float;",

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",

						"void main() {",

							// pink square

							"if( renderType == 0 ) {",

								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

							// restore

							"} else if( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			}

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			}

			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};

		};

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;

			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );

			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			gl.enableVertexAttribArray( attributes.vertex );
			gl.enableVertexAttribArray( attributes.uv );

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/unforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.disable( gl.CULL_FACE );
			gl.depthMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];

				tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition )

				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

				// screen cull

				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {

					// save current RGB to temp texture

					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					gl.disable( gl.BLEND );
					gl.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					gl.activeTexture( gl.TEXTURE0 );
					gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					gl.disable( gl.DEPTH_TEST );

					gl.activeTexture( gl.TEXTURE1 );
					gl.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition )

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					gl.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewportHeight;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							renderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			gl.enable( gl.CULL_FACE );
			gl.enable( gl.DEPTH_TEST );
			gl.depthMask( true );

			renderer.resetGLState();

		};

		function createProgram ( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

		var _gl = _renderer.context;

		var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),

		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),

		_matrixPosition = new THREE.Vector3(),

		_renderList = [];

		// init

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader
		 } );

		_depthMaterialMorph = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true
		} );

		_depthMaterialSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			skinning: true
		} );

		_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: true,
			skinning: true
		} );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

		this.render = function ( scene, camera ) {

			if ( _renderer.shadowMapEnabled === false ) return;

			var i, il, j, jl, n,

			shadowMap, shadowMatrix, shadowCamera,
			buffer, material,
			webglObject, object, light,

			lights = [],
			k = 0,

			fog = null;

			// set GL state for depth map

			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );

			_gl.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );

			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.state.setDepthTest( true );

			// preprocess lights
			// 	- skip lights that are not casting shadows
			//	- create virtual lights for cascaded shadow maps

			for ( i = 0, il = _lights.length; i < il; i ++ ) {

				light = _lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

					for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

						var virtualLight;

						if ( ! light.shadowCascadeArray[ n ] ) {

							virtualLight = createVirtualLight( light, n );
							virtualLight.originalCamera = camera;

							var gyro = new THREE.Gyroscope();
							gyro.position.copy( light.shadowCascadeOffset );

							gyro.add( virtualLight );
							gyro.add( virtualLight.target );

							camera.add( gyro );

							light.shadowCascadeArray[ n ] = virtualLight;

							//console.log( "Created virtualLight", virtualLight );

						} else {

							virtualLight = light.shadowCascadeArray[ n ];

						}

						updateVirtualLight( light, n );

						lights[ k ] = virtualLight;
						k ++;

					}

				} else {

					lights[ k ] = light;
					k ++;

				}

			}

			// render depth map

			for ( i = 0, il = lights.length; i < il; i ++ ) {

				light = lights[ i ];

				if ( ! light.shadowMap ) {

					var shadowFilter = THREE.LinearFilter;

					if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

					light.shadowMatrix = new THREE.Matrix4();

				}

				if ( ! light.shadowCamera ) {

					if ( light instanceof THREE.SpotLight ) {

						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

					} else if ( light instanceof THREE.DirectionalLight ) {

						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

					} else {

						THREE.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
						continue;

					}

					scene.add( light.shadowCamera );

					if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				}

				if ( light.shadowCameraVisible && ! light.cameraHelper ) {

					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					scene.add( light.cameraHelper );

				}

				if ( light.isVirtual && virtualLight.originalCamera == camera ) {

					updateShadowCamera( camera, light );

				}

				shadowMap = light.shadowMap;
				shadowMatrix = light.shadowMatrix;
				shadowCamera = light.shadowCamera;

				//

				shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
				_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();

				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				//

				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// render shadow map

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, scene, shadowCamera );


				// render regular objects

				var objectMaterial, useMorphing, useSkinning;

				for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

					webglObject = _renderList[ j ];

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					_renderer.setMaterialFaces( objectMaterial );

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

					}

				}

				// set matrices and render immediate objects

				for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

					webglObject = _webglObjectsImmediate[ j ];
					object = webglObject.object;

					if ( object.visible && object.castShadow ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

					}

				}

			}

			// restore GL state

			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();

			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );

			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.resetGLState();

		};

		function projectObject( scene, object, shadowCamera ) {

			if ( object.visible ) {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[ i ];

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( webglObject );

					}

				}

				for ( var i = 0, l = object.children.length; i < l; i ++ ) {

					projectObject( scene, object.children[ i ], shadowCamera );

				}

			}

		}

		function createVirtualLight( light, cascade ) {

			var virtualLight = new THREE.DirectionalLight();

			virtualLight.isVirtual = true;

			virtualLight.onlyShadow = true;
			virtualLight.castShadow = true;

			virtualLight.shadowCameraNear = light.shadowCameraNear;
			virtualLight.shadowCameraFar = light.shadowCameraFar;

			virtualLight.shadowCameraLeft = light.shadowCameraLeft;
			virtualLight.shadowCameraRight = light.shadowCameraRight;
			virtualLight.shadowCameraBottom = light.shadowCameraBottom;
			virtualLight.shadowCameraTop = light.shadowCameraTop;

			virtualLight.shadowCameraVisible = light.shadowCameraVisible;

			virtualLight.shadowDarkness = light.shadowDarkness;

			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
			virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
			virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

			virtualLight.pointsWorld = [];
			virtualLight.pointsFrustum = [];

			var pointsWorld = virtualLight.pointsWorld,
				pointsFrustum = virtualLight.pointsFrustum;

			for ( var i = 0; i < 8; i ++ ) {

				pointsWorld[ i ] = new THREE.Vector3();
				pointsFrustum[ i ] = new THREE.Vector3();

			}

			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];

			pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
			pointsFrustum[ 1 ].set(  1, - 1, nearZ );
			pointsFrustum[ 2 ].set( - 1,  1, nearZ );
			pointsFrustum[ 3 ].set(  1,  1, nearZ );

			pointsFrustum[ 4 ].set( - 1, - 1, farZ );
			pointsFrustum[ 5 ].set(  1, - 1, farZ );
			pointsFrustum[ 6 ].set( - 1,  1, farZ );
			pointsFrustum[ 7 ].set(  1,  1, farZ );

			return virtualLight;

		}

		// Synchronize virtual light with the original light

		function updateVirtualLight( light, cascade ) {

			var virtualLight = light.shadowCascadeArray[ cascade ];

			virtualLight.position.copy( light.position );
			virtualLight.target.position.copy( light.target.position );
			virtualLight.lookAt( virtualLight.target );

			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
			virtualLight.shadowDarkness = light.shadowDarkness;

			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];

			var pointsFrustum = virtualLight.pointsFrustum;

			pointsFrustum[ 0 ].z = nearZ;
			pointsFrustum[ 1 ].z = nearZ;
			pointsFrustum[ 2 ].z = nearZ;
			pointsFrustum[ 3 ].z = nearZ;

			pointsFrustum[ 4 ].z = farZ;
			pointsFrustum[ 5 ].z = farZ;
			pointsFrustum[ 6 ].z = farZ;
			pointsFrustum[ 7 ].z = farZ;

		}

		// Fit shadow camera's ortho frustum to camera frustum

		function updateShadowCamera( camera, light ) {

			var shadowCamera = light.shadowCamera,
				pointsFrustum = light.pointsFrustum,
				pointsWorld = light.pointsWorld;

			_min.set( Infinity, Infinity, Infinity );
			_max.set( - Infinity, - Infinity, - Infinity );

			for ( var i = 0; i < 8; i ++ ) {

				var p = pointsWorld[ i ];

				p.copy( pointsFrustum[ i ] );
				p.unproject( camera );

				p.applyMatrix4( shadowCamera.matrixWorldInverse );

				if ( p.x < _min.x ) _min.x = p.x;
				if ( p.x > _max.x ) _max.x = p.x;

				if ( p.y < _min.y ) _min.y = p.y;
				if ( p.y > _max.y ) _max.y = p.y;

				if ( p.z < _min.z ) _min.z = p.z;
				if ( p.z > _max.z ) _max.z = p.z;

			}

			shadowCamera.left = _min.x;
			shadowCamera.right = _max.x;
			shadowCamera.top = _max.y;
			shadowCamera.bottom = _min.y;

			// can't really fit near/far
			//shadowCamera.near = _min.z;
			//shadowCamera.far = _max.z;

			shadowCamera.updateProjectionMatrix();

		}

		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use for shadow maps

		function getObjectMaterial( object ) {

			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;

		};

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function ( renderer, sprites ) {

		var gl = renderer.context;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();

		var init = function () {

			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};

			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),

				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),

				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),

				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;

		};

		this.render = function ( scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			gl.enableVertexAttribArray( attributes.position );
			gl.enableVertexAttribArray( attributes.uv );

			gl.disable( gl.CULL_FACE );
			gl.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			gl.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog instanceof THREE.Fog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog instanceof THREE.FogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				renderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				renderer.state.setDepthTest( material.depthTest );
				renderer.state.setDepthWrite( material.depthWrite );

				if ( material.map && material.map.image && material.map.image.width ) {

					renderer.setTexture( material.map, 0 );

				} else {

					renderer.setTexture( texture, 0 );

				}

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			}

			// restore gl

			gl.enable( gl.CULL_FACE );

			renderer.resetGLState();

		};

		function createProgram () {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

					'vUV = uvOffset + uv * uvScale;',

					'vec2 alignedPosition = position * scale;',

					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

					'vec4 finalPosition;',

					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',

					'gl_Position = finalPosition;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

					'vec4 texture = texture2D( map, vUV );',

					'if ( texture.a < alphaTest ) discard;',

					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

					'if ( fogType > 0 ) {',

						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',

						'if ( fogType == 1 ) {',

							'fogFactor = smoothstep( fogNear, fogFar, depth );',

						'} else {',

							'const float LOG2 = 1.442695;',
							'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

						'}',

						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

					'}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		};

		function painterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		};

	};

	// File:src/extras/GeometryUtils.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			THREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if ( geometry2 instanceof THREE.Mesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			THREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	// File:src/extras/ImageUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.Texture( undefined, mapping );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, undefined, function ( event ) {

				if ( onError ) onError( event );

			} );

			texture.sourceFile = url;

			return texture;

		},

		loadTextureCube: function ( array, mapping, onLoad, onError ) {

			var images = [];

			var loader = new THREE.ImageLoader();
			loader.crossOrigin = this.crossOrigin;

			var texture = new THREE.CubeTexture( images, mapping );

			// no flipping needed for cube textures

			texture.flipY = false;

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( array[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded += 1;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		loadCompressedTexture: function () {

			THREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

		},

		loadCompressedTextureCube: function () {

			THREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

		},

		getNormalMap: function ( image, depth ) {

			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

			var cross = function ( a, b ) {

				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

			}

			var subtract = function ( a, b ) {

				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

			}

			var normalize = function ( a ) {

				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

			}

			depth = depth | 1;

			var width = image.width;
			var height = image.height;

			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );

			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;

			for ( var x = 0; x < width; x ++ ) {

				for ( var y = 0; y < height; y ++ ) {

					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;

					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

					var normals = [];
					var num_points = points.length;

					for ( var i = 0; i < num_points; i ++ ) {

						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );

					}

					var normal = [ 0, 0, 0 ];

					for ( var i = 0; i < normals.length; i ++ ) {

						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];

					}

					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;

					var idx = ( y * width + x ) * 4;

					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;

				}

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		},

		generateDataTexture: function ( width, height, color ) {

			var size = width * height;
			var data = new Uint8Array( 3 * size );

			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );

			for ( var i = 0; i < size; i ++ ) {

				data[ i * 3 ] 	   = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;

			}

			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;

			return texture;

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new THREE.Object3D();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new THREE.Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );

			scene.remove( child );
			parent.add( child );

		}

	};

	// File:src/extras/FontUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 * 	typeface.js and canvastext
	 * 		For converting fonts and rendering with javascript
	 *		http://typeface.neocracy.org
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */

	THREE.FontUtils = {

		faces: {},

		// Just for now. face[weight][style]

		face: 'helvetiker',
		weight: 'normal',
		style: 'normal',
		size: 150,
		divisions: 10,

		getFace: function () {

			try {

				return this.faces[ this.face ][ this.weight ][ this.style ];

			} catch (e) {

				throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

			};

		},

		loadFace: function ( data ) {

			var family = data.familyName.toLowerCase();

			var ThreeFont = this;

			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

			return data;

		},

		drawText: function ( text ) {

			// RenderText

			var i,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;

			var fontPaths = [];

			for ( i = 0; i < length; i ++ ) {

				var path = new THREE.Path();

				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;

				fontPaths.push( ret.path );

			}

			// get the width

			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }

			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;

			//extract.paths = fontPaths;
			//extract.offset = width;

			return { paths: fontPaths, offset: width };

		},




		extractGlyphPoints: function ( c, face, scale, offset, path ) {

			var pts = [];

			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

			if ( ! glyph ) return;

			if ( glyph.o ) {

				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;

				scaleX = scale;
				scaleY = scale;

				for ( i = 0; i < length; ) {

					action = outline[ i ++ ];

					//console.log( action );

					switch ( action ) {

					case 'm':

						// Move To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;

						path.moveTo( x, y );
						break;

					case 'l':

						// Line To

						x = outline[ i ++ ] * scaleX + offset;
						y = outline[ i ++ ] * scaleY;
						path.lineTo( x, y );
						break;

					case 'q':

						// QuadraticCurveTo

						cpx  = outline[ i ++ ] * scaleX + offset;
						cpy  = outline[ i ++ ] * scaleY;
						cpx1 = outline[ i ++ ] * scaleX + offset;
						cpy1 = outline[ i ++ ] * scaleY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
							}

						}

						break;

					case 'b':

						// Cubic Bezier Curve

						cpx  = outline[ i ++ ] *  scaleX + offset;
						cpy  = outline[ i ++ ] *  scaleY;
						cpx1 = outline[ i ++ ] *  scaleX + offset;
						cpy1 = outline[ i ++ ] *  scaleY;
						cpx2 = outline[ i ++ ] *  scaleX + offset;
						cpy2 = outline[ i ++ ] *  scaleY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						laste = pts[ pts.length - 1 ];

						if ( laste ) {

							cpx0 = laste.x;
							cpy0 = laste.y;

							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

								var t = i2 / divisions;
								THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

							}

						}

						break;

					}

				}
			}



			return { offset: glyph.ha * scale, path:path };
		}

	};


	THREE.FontUtils.generateShapes = function ( text, parameters ) {

		// Parameters 

		parameters = parameters || {};

		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

		var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
		var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
		var style = parameters.style !== undefined ? parameters.style : 'normal';

		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;

		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;

		// Get a Font data json object

		var data = THREE.FontUtils.drawText( text );

		var paths = data.paths;
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	};


	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */


	( function ( namespace ) {

		var EPSILON = 0.0000000001;

		// takes in an contour array and returns

		var process = function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					THREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		};

		// calculate area of the contour polygon

		var area = function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		};

		var snip = function ( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

			}

			return true;

		};


		namespace.Triangulate = process;
		namespace.Triangulate.area = area;

		return namespace;

	} )( THREE.FontUtils );

	// To use the typeface.js face files, hook up the API
	self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
	THREE.typeface_js = self._typeface_js;

	// File:src/extras/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Audio = function ( listener ) {

		THREE.Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind(this);

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

		this.autoplay = false;

		this.startTime = 0;
		this.isPlaying = false;

	};

	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;

	THREE.Audio.prototype.load = function ( file ) {

		var scope = this;

		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {

			scope.context.decodeAudioData( this.response, function ( buffer ) {

				scope.source.buffer = buffer;

				if( scope.autoplay ) scope.play();

			} );

		};
		request.send();

		return this;

	};

	THREE.Audio.prototype.play = function () {

		if ( this.isPlaying === true ) {

			THREE.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.connect( this.panner );
		source.start( 0, this.startTime );

		this.isPlaying = true;

		this.source = source;

	};

	THREE.Audio.prototype.pause = function () {

		this.source.stop();
		this.startTime = this.context.currentTime;

	};

	THREE.Audio.prototype.stop = function () {

		this.source.stop();
		this.startTime = 0;

	};

	THREE.Audio.prototype.onEnded = function() {

		this.isPlaying = false;

	};

	THREE.Audio.prototype.setLoop = function ( value ) {

		this.source.loop = value;

	};

	THREE.Audio.prototype.setRefDistance = function ( value ) {

		this.panner.refDistance = value;

	};

	THREE.Audio.prototype.setRolloffFactor = function ( value ) {

		this.panner.rolloffFactor = value;

	};

	THREE.Audio.prototype.setVolume = function ( value ) {

		this.gain.gain.value = value;

	};

	THREE.Audio.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();

		return function ( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )();

	// File:src/extras/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call( this );

		this.type = 'AudioListener';

		this.context = new ( window.AudioContext || window.webkitAudioContext )();

	};

	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;

	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();
		var velocity = new THREE.Vector3();

		var positionPrev = new THREE.Vector3();

		return function ( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
			velocity.subVectors( position, positionPrev );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
			listener.setVelocity( velocity.x, velocity.y, velocity.z );

			positionPrev.copy( position );

		};

	} )();

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	THREE.Curve.prototype.getPoint = function ( t ) {

		THREE.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	};

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	THREE.Curve.prototype.getPointAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	};

	// Get sequence of points using getPoint( t )

	THREE.Curve.prototype.getPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	};

	// Get sequence of points using getPointAt( u )

	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	};

	// Get total curve arc length

	THREE.Curve.prototype.getLength = function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	};

	// Get list of cumulative segment lengths

	THREE.Curve.prototype.getLengths = function ( divisions ) {

		if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length == divisions + 1 )
			&& ! this.needsUpdate) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	};


	THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = true;
		this.getLengths();
	};

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] == targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolatation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

	    // determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

	    // add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	};

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	THREE.Curve.prototype.getTangent = function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub(pt1);
		return vec.normalize();

	};


	THREE.Curve.prototype.getTangentAt = function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	};





	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Curve.Utils = {

		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

			return - 3 * p0 * (1 - t) * (1 - t)  +
				3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
				6 * t *  p2 * (1 - t) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function ( t, p0, p1, p2, p3 ) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3  t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};


	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function ( constructor, getPointFunc ) {

		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];
		this.bends = [];
		
		this.autoClose = false; // Automatically closes the path
	};

	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;

	THREE.CurvePath.prototype.add = function ( curve ) {

		this.curves.push( curve );

	};

	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};

	THREE.CurvePath.prototype.closePath = function() {
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[0].getPoint(0);
		var endPoint = this.curves[this.curves.length - 1].getPoint(1);
		
		if (! startPoint.equals(endPoint)) {
			this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
		}
		
	};

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	THREE.CurvePath.prototype.getPoint = function( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	};

	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/


	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	THREE.CurvePath.prototype.getLength = function() {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	};

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	THREE.CurvePath.prototype.getCurveLengths = function() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

			return this.cacheLengths;

		};

		// Get length of subsurve
		// Push sums into cached array

		var lengths = [], sums = 0;
		var i, il = this.curves.length;

		for ( i = 0; i < il; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	};



	// Returns min and max coordinates

	THREE.CurvePath.prototype.getBoundingBox = function () {

		var points = this.getPoints();

		var maxX, maxY, maxZ;
		var minX, minY, minZ;

		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;

		var p, i, il, sum;

		var v3 = points[0] instanceof THREE.Vector3;

		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

		for ( i = 0, il = points.length; i < il; i ++ ) {

			p = points[ i ];

			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;

			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;

			if ( v3 ) {

				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;

			}

			sum.add( p );

		}

		var ret = {

			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY

		};

		if ( v3 ) {

			ret.maxZ = maxZ;
			ret.minZ = minZ;

		}

		return ret;

	};

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );

	};

	// Generate geometry from equidistance sampling along the path

	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );

	};

	THREE.CurvePath.prototype.createGeometry = function( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < points.length; i ++ ) {

			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

		}

		return geometry;

	};


	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/

	// Wrap path / Bend modifiers?

	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

		this.bends.push( bendpath );

	};

	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

		var oldPts = this.getSpacedPoints( segments );

		var i, il;

		if ( ! bends ) {

			bends = this.bends;

		}

		for ( i = 0, il = bends.length; i < il; i ++ ) {

			oldPts = this.getWrapPoints( oldPts, bends[ i ] );

		}

		return oldPts;

	};

	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

		var bounds = this.getBoundingBox();

		var i, il, p, oldX, oldY, xNorm;

		for ( i = 0, il = oldPts.length; i < il; i ++ ) {

			p = oldPts[ i ];

			oldX = p.x;
			oldY = p.y;

			xNorm = oldX / bounds.maxX;

			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

			xNorm = path.getUtoTmapping( xNorm, oldX );

			// check for out of bounds?

			var pathPt = path.getPoint( xNorm );
			var normal = path.getTangent( xNorm );
			normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;

		}

		return oldPts;

	};


	// File:src/extras/core/Gyroscope.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Gyroscope = function () {

		THREE.Object3D.call( this );

	};

	THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;

	THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

		var translationObject = new THREE.Vector3();
		var quaternionObject = new THREE.Quaternion();
		var scaleObject = new THREE.Vector3();

		var translationWorld = new THREE.Vector3();
		var quaternionWorld = new THREE.Quaternion();
		var scaleWorld = new THREE.Vector3();

		return function ( force ) {

			this.matrixAutoUpdate && this.updateMatrix();

			// update matrixWorld

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent ) {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
					this.matrix.decompose( translationObject, quaternionObject, scaleObject );

					this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


				} else {

					this.matrixWorld.copy( this.matrix );

				}


				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		};
		
	}() );

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function ( points ) {

		THREE.CurvePath.call(this);

		this.actions = [];

		if ( points ) {

			this.fromPoints( points );

		}

	};

	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;

	THREE.PathActions = {

		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	THREE.Path.prototype.fromPoints = function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

			this.lineTo( vectors[ v ].x, vectors[ v ].y );

		};

	};

	// startPath() endPath()?

	THREE.Path.prototype.moveTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

	};

	THREE.Path.prototype.lineTo = function ( x, y ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

	};

	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
												   aCP2x, aCP2y,
												   aX, aY ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

	};

	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

	};

	// FUTURE: Change the API or follow canvas API?

	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc(aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };

	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	 };

	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };


	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {

		var args = Array.prototype.slice.call( arguments );
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise );
		this.curves.push( curve );

		var lastPoint = curve.getPoint(1);
		args.push(lastPoint.x);
		args.push(lastPoint.y);

		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

	 };

	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }

		return points;

	};

	/* Return an array of vectors based on contour of the path */

	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

		if (this.useSpacedPoints) {
			console.log('tata');
			return this.getSpacedPoints( divisions, closedPath );
		}

		divisions = divisions || 12;

		var points = [];

		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;

		for ( i = 0, il = this.actions.length; i < il; i ++ ) {

			item = this.actions[ i ];

			action = item.action;
			args = item.args;

			switch ( action ) {

			case THREE.PathActions.MOVE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.LINE_TO:

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case THREE.PathActions.QUADRATIC_CURVE_TO:

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.BEZIER_CURVE_TO:

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( j = 1; j <= divisions; j ++ ) {

					t = j / divisions;

					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case THREE.PathActions.CSPLINE_THRU:

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) ) ;

				}

				break;

			case THREE.PathActions.ARC:

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;
			  
			case THREE.PathActions.ELLIPSE:

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( j = 1; j <= tdivisions; j ++ ) {

					t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1];
		var EPSILON = 0.0000000001;
		if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
				 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
			points.splice( points.length - 1, 1);
		if ( closedPath ) {

			points.push( points[ 0 ] );

		}

		return points;

	};

	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//

	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var i, il, item, action, args;

			var subPaths = [], lastPath = new THREE.Path();

			for ( i = 0, il = inActions.length; i < il; i ++ ) {

				item = inActions[ i ];

				args = item.args;
				action = item.action;

				if ( action == THREE.PathActions.MOVE_TO ) {

					if ( lastPath.actions.length != 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;
		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
			}

			//console.log("shape", shapes);

			return shapes;
		};

		function isPointInsidePolygon( inPt, inPolygon ) {
			var EPSILON = 0.0000000001;

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
					if ( edgeDy < 0 ) {
						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y == edgeLowPt.y ) {
						if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!
					} else {
						var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
						if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt
					}
				} else {		// parallel or colinear
					if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
					// egde lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;
				}
			}

			return	inside;
		}


		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length == 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length == 1) {

			tmpPath = subPaths[0];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);
		
		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[mainIdx] = undefined;
		newShapeHoles[mainIdx] = [];

		var i, il;

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = THREE.Shape.Utils.isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

				newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[mainIdx].s.actions = tmpPath.actions;
				newShapes[mainIdx].s.curves = tmpPath.curves;
				
				if ( holesFirst )	mainIdx ++;
				newShapeHoles[mainIdx] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {
			var ambigious = false;
			var toChange = [];

			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				betterShapeHoles[sIdx] = [];
			}
			for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
				var sho = newShapeHoles[sIdx];
				for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
					var ho = sho[hIdx];
					var hole_unassigned = true;
					for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
						if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
							if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {
								hole_unassigned = false;
								betterShapeHoles[s2Idx].push( ho );
							} else {
								ambigious = true;
							}
						}
					}
					if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
				}
			}
			// console.log("ambigious: ", ambigious);
			if ( toChange.length > 0 ) {
				// console.log("to change: ", toChange);
				if (! ambigious)	newShapeHoles = betterShapeHoles;
			}
		}

		var tmpHoles, j, jl;
		for ( i = 0, il = newShapes.length; i < il; i ++ ) {
			tmpShape = newShapes[i].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[i];
			for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
				tmpShape.holes.push( tmpHoles[j].h );
			}
		}

		//console.log("shape", shapes);

		return shapes;

	};

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply( this, arguments );
		this.holes = [];

	};

	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;

	// Convenience method to return ExtrudeGeometry

	THREE.Shape.prototype.extrude = function ( options ) {

		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;

	};

	// Convenience method to return ShapeGeometry

	THREE.Shape.prototype.makeGeometry = function ( options ) {

		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;

	};

	// Get points of holes

	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

		}

		return holesPts;

	};

	// Get points of holes (spaced by regular distance)

	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

		var i, il = this.holes.length, holesPts = [];

		for ( i = 0; i < il; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

		}

		return holesPts;

	};


	// Get points of shape and holes (keypoints based on segments parameter)

	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

		return {

			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	};

	THREE.Shape.prototype.extractPoints = function ( divisions ) {

		if (this.useSpacedPoints) {
			return this.extractAllSpacedPoints(divisions);
		}

		return this.extractAllPoints(divisions);

	};

	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };

	// Get points of shape and holes (spaced by regular distance)

	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

		return {

			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )

		};

	};

	/**************************************************************
	 *	Utils
	 **************************************************************/

	THREE.Shape.Utils = {

		triangulateShape: function ( contour, holes ) {

			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
				// inOtherPt needs to be colinear to the inSegment
				if ( inSegPt1.x != inSegPt2.x ) {
					if ( inSegPt1.x < inSegPt2.x ) {
						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
					} else {
						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
					}
				} else {
					if ( inSegPt1.y < inSegPt2.y ) {
						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
					} else {
						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
					}
				}
			}

			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
				var EPSILON = 0.0000000001;

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if ( Math.abs(limit) > EPSILON ) {			// not parallel

					var perpSeg2;
					if ( limit > 0 ) {
						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
					} else {
						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 == 0 ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return [ inSeg1Pt1 ];
					}
					if ( perpSeg2 == limit ) {
						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
						return [ inSeg1Pt2 ];
					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 == 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 == limit )	return [ inSeg2Pt2 ];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

				} else {		// parallel or colinear
					if ( ( perpSeg1 != 0 ) ||
						 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

					// they are collinear or degenerate
					var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
					var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {
						if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
							 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
						return [ inSeg1Pt1 ];                 					// they are the same point
					}
					// segment#1  is a single point
					if ( seg1Pt ) {
						if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];
					}
					// segment#2  is a single point
					if ( seg2Pt ) {
						if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];
					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if (seg1dx != 0) {		// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
						}
					} else {				// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
						} else {
							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
						} else {
							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
						}
					}
					if ( seg1minVal <= seg2minVal ) {
						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal == seg2minVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];
					} else {
						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal == seg2maxVal )	{
							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];
						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];
					}
				}
			}

			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
				// The order of legs is important

				var EPSILON = 0.0000000001;

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

				if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if ( from2toAngle > 0 ) {				// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
					} else {								// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
					}
				} else {										// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );
				}
			}


			function removeHoles( contour, holes ) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;
					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

					insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
					if (! insideAngle ) {
						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;
					}

					return	true;
				}

				function intersectsShapeEdge( inShapePt, inHolePt ) {
					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}

					return	false;
				}

				var indepHoles = [];

				function intersectsHoleEdge( inShapePt, inHolePt ) {
					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
						chkHole = holes[indepHoles[ihIdx]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
							if ( intersection.length > 0 )		return	true;
						}
					}
					return	false;
				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					indepHoles.push( h );

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {
					counter --;
					if ( counter < 0 ) {
						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;
					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;

						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {
							holeIdx = indepHoles[h];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[cutKey] !== undefined )			continue;

							hole = holes[holeIdx];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
								holePt = hole[ h2 ];
								if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

								holeIndex = h2;
								indepHoles.splice(h, 1);

								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );

								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

							failedCuts[cutKey] = true;			// remember failure
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found
					}
				}

				return shape; 			/* shape with no holes */
			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				Array.prototype.push.apply( allpoints, holes[h] );

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for ( i = 0, il = allpoints.length; i < il; i ++ ) {

				key = allpoints[ i ].x + ":" + allpoints[ i ].y;

				if ( allPointsMap[ key ] !== undefined ) {

					THREE.warn( "THREE.Shape: Duplicate point", key );

				}

				allPointsMap[ key ] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );

			var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for ( i = 0, il = triangles.length; i < il; i ++ ) {

				face = triangles[ i ];

				for ( f = 0; f < 3; f ++ ) {

					key = face[ f ].x + ":" + face[ f ].y;

					index = allPointsMap[ key ];

					if ( index !== undefined ) {

						face[ f ] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function ( pts ) {

			return THREE.FontUtils.Triangulate.area( pts ) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * p;

		},

		b2p1: function ( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		},

		b2p2: function ( t, p ) {

			return t * t * p;

		},

		b2: function ( t, p0, p1, p2 ) {

			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

		},

		// Cubic Bezier Functions

		b3p0: function ( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		},

		b3p1: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		},

		b3p2: function ( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		},

		b3p3: function ( t, p ) {

			return t * t * t * p;

		},

		b3: function ( t, p0, p1, p2, p3 ) {

			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

		}

	};


	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;

	THREE.LineCurve.prototype.getPoint = function ( t ) {

		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar( t ).add( this.v1 );

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function ( u ) {

		return this.getPoint( u );

	};

	THREE.LineCurve.prototype.getTangent = function( t ) {

		var tangent = this.v2.clone().sub(this.v1);

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

		return vector;

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

		// returns unit vector

		return vector.normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

		var tx, ty;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		return new THREE.Vector2( tx, ty );

	};

	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

		var tx, ty;

		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();

		return tangent;

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

	THREE.SplineCurve.prototype.getPoint = function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
		var point1 = points[ intPoint ]
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]

		var vector = new THREE.Vector2();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

		return vector;

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

	};

	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

	THREE.EllipseCurve.prototype.getPoint = function ( t ) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

		var angle;

		if ( this.aClockwise === true ) {

			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}
		
		var vector = new THREE.Vector2();

		vector.x = this.aX + this.xRadius * Math.cos( angle );
		vector.y = this.aY + this.yRadius * Math.sin( angle );

		return vector;

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	};

	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function ( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

			return vector;

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

			return vector;

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];

			var vector = new THREE.Vector3();

			vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
			vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
			vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

			return vector;

		}

	);

	// File:src/extras/animation/AnimationHandler.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 */

	THREE.AnimationHandler = {

		LINEAR: 0,
		CATMULLROM: 1,
		CATMULLROM_FORWARD: 2,

		//

		add: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
		get: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
		remove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

		//

		animations: [],

		init: function ( data ) {

			if ( data.initialized === true ) return data;

			// loop through all keys

			for ( var h = 0; h < data.hierarchy.length; h ++ ) {

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					// remove minus times

					if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

						 data.hierarchy[ h ].keys[ k ].time = 0;

					}

					// create quaternions

					if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

					}

				}

				// prepare morph target keys

				if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

					// get all used

					var usedMorphTargets = {};

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = - 1;

						}

					}

					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


					// set all used on all frames

					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

						var influences = {};

						for ( var morphTargetName in usedMorphTargets ) {

							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;

								}

							}

							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

								influences[ morphTargetName ] = 0;

							}

						}

						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

					}

				}


				// remove all keys that are on the same time

				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;

					}

				}


				// set index

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					data.hierarchy[ h ].keys[ k ].index = k;

				}

			}

			data.initialized = true;

			return data;

		},

		parse: function ( root ) {

			var parseRecurseHierarchy = function ( root, hierarchy ) {

				hierarchy.push( root );

				for ( var c = 0; c < root.children.length; c ++ )
					parseRecurseHierarchy( root.children[ c ], hierarchy );

			};

			// setup hierarchy

			var hierarchy = [];

			if ( root instanceof THREE.SkinnedMesh ) {

				for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

					hierarchy.push( root.skeleton.bones[ b ] );

				}

			} else {

				parseRecurseHierarchy( root, hierarchy );

			}

			return hierarchy;

		},

		play: function ( animation ) {

			if ( this.animations.indexOf( animation ) === - 1 ) {

				this.animations.push( animation );

			}

		},

		stop: function ( animation ) {

			var index = this.animations.indexOf( animation );

			if ( index !== - 1 ) {

				this.animations.splice( index, 1 );

			}

		},

		update: function ( deltaTimeMS ) {

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].resetBlendWeights( );

			}

			for ( var i = 0; i < this.animations.length; i ++ ) {

				this.animations[ i ].update( deltaTimeMS );

			}

		}

	};

	// File:src/extras/animation/Animation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Animation = function ( root, data ) {

		this.root = root;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );

		this.currentTime = 0;
		this.timeScale = 1;

		this.isPlaying = false;
		this.loop = true;
		this.weight = 0;

		this.interpolationType = THREE.AnimationHandler.LINEAR;

	};

	THREE.Animation.prototype = {

		constructor: THREE.Animation,

		keyTypes:  [ "pos", "rot", "scl" ],

		play: function ( startTime, weight ) {

			this.currentTime = startTime !== undefined ? startTime : 0;
			this.weight = weight !== undefined ? weight : 1;

			this.isPlaying = true;

			this.reset();

			THREE.AnimationHandler.play( this );

		},

		stop: function() {

			this.isPlaying = false;

			THREE.AnimationHandler.stop( this );

		},

		reset: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];

				if ( object.animationCache === undefined ) {

					object.animationCache = {
						animations: {},
						blending: {
							positionWeight: 0.0,
							quaternionWeight: 0.0,
							scaleWeight: 0.0
						}
					};
				}

				var name = this.data.name;
				var animations = object.animationCache.animations;
				var animationCache = animations[ name ];

				if ( animationCache === undefined ) {

					animationCache = {
						prevKey: { pos: 0, rot: 0, scl: 0 },
						nextKey: { pos: 0, rot: 0, scl: 0 },
						originalMatrix: object.matrix
					};

					animations[ name ] = animationCache;

				}

				// Get keys to match our current time

				for ( var t = 0; t < 3; t ++ ) {

					var type = this.keyTypes[ t ];

					var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					var nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

			}

		},

		resetBlendWeights: function () {

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var animationCache = object.animationCache;

				if ( animationCache !== undefined ) {

					var blending = animationCache.blending;

					blending.positionWeight = 0.0;
					blending.quaternionWeight = 0.0;
					blending.scaleWeight = 0.0;

				}

			}

		},

		update: ( function() {

			var points = [];
			var target = new THREE.Vector3();
			var newVector = new THREE.Vector3();
			var newQuat = new THREE.Quaternion();

			// Catmull-Rom spline

			var interpolateCatmullRom = function ( points, scale ) {

				var c = [], v3 = [],
				point, intPoint, weight, w2, w3,
				pa, pb, pc, pd;

				point = ( points.length - 1 ) * scale;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
				c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

				pa = points[ c[ 0 ] ];
				pb = points[ c[ 1 ] ];
				pc = points[ c[ 2 ] ];
				pd = points[ c[ 3 ] ];

				w2 = weight * weight;
				w3 = weight * w2;

				v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
				v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
				v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

				return v3;

			};

			var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;

				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			};

			return function ( delta ) {

				if ( this.isPlaying === false ) return;

				this.currentTime += delta * this.timeScale;

				if ( this.weight === 0 )
					return;

				//

				var duration = this.data.length;

				if ( this.currentTime > duration || this.currentTime < 0 ) {

					if ( this.loop ) {

						this.currentTime %= duration;

						if ( this.currentTime < 0 )
							this.currentTime += duration;

						this.reset();

					} else {

						this.stop();

					}

				}

				for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

					var object = this.hierarchy[ h ];
					var animationCache = object.animationCache.animations[this.data.name];
					var blending = object.animationCache.blending;

					// loop through pos/rot/scl

					for ( var t = 0; t < 3; t ++ ) {

						// get keys

						var type    = this.keyTypes[ t ];
						var prevKey = animationCache.prevKey[ type ];
						var nextKey = animationCache.nextKey[ type ];

						if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
							( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );

							while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

							}

							animationCache.prevKey[ type ] = prevKey;
							animationCache.nextKey[ type ] = nextKey;

						}

						var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

						var prevXYZ = prevKey[ type ];
						var nextXYZ = nextKey[ type ];

						if ( scale < 0 ) scale = 0;
						if ( scale > 1 ) scale = 1;

						// interpolate

						if ( type === "pos" ) {

							if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

								newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
								newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
								newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

								// blend
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								object.position.lerp( newVector, proportionalWeight );
								blending.positionWeight += this.weight;

							} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
										this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

								points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
								points[ 1 ] = prevXYZ;
								points[ 2 ] = nextXYZ;
								points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

								scale = scale * 0.33 + 0.33;

								var currentPoint = interpolateCatmullRom( points, scale );
								var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
								blending.positionWeight += this.weight;

								// blend

								var vector = object.position;

								vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
								vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
								vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

								if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

									var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

									target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
									target.sub( vector );
									target.y = 0;
									target.normalize();

									var angle = Math.atan2( target.x, target.z );
									object.rotation.set( 0, angle, 0 );

								}

							}

						} else if ( type === "rot" ) {

							THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

							// Avoid paying the cost of an additional slerp if we don't have to
							if ( blending.quaternionWeight === 0 ) {

								object.quaternion.copy(newQuat);
								blending.quaternionWeight = this.weight;

							} else {

								var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
								THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
								blending.quaternionWeight += this.weight;

							}

						} else if ( type === "scl" ) {

							newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
							newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
							newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

							var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
							object.scale.lerp( newVector, proportionalWeight );
							blending.scaleWeight += this.weight;

						}

					}

				}

				return true;

			};

		} )(),

		getNextKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key < keys.length - 1 ? key : keys.length - 1;

			} else {

				key = key % keys.length;

			}

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ 0 ];

		},

		getPrevKeyWith: function ( type, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key > 0 ? key : 0;

			} else {

				key = key >= 0 ? key : key + keys.length;

			}


			for ( ; key >= 0; key -- ) {

				if ( keys[ key ][ type ] !== undefined ) {

					return keys[ key ];

				}

			}

			return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/KeyFrameAnimation.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */

	THREE.KeyFrameAnimation = function ( data ) {

		this.root = data.node;
		this.data = THREE.AnimationHandler.init( data );
		this.hierarchy = THREE.AnimationHandler.parse( this.root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;

		// initialize to first keyframes

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				obj = this.hierarchy[h];

			if ( keys.length && sids ) {

				for ( var s = 0; s < sids.length; s ++ ) {

					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );

					if ( next ) {

						next.apply( sid );

					}

				}

				obj.matrixAutoUpdate = false;
				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

	};

	THREE.KeyFrameAnimation.prototype = {

		constructor: THREE.KeyFrameAnimation,

		play: function ( startTime ) {

			this.currentTime = startTime !== undefined ? startTime : 0;

			if ( this.isPlaying === false ) {

				this.isPlaying = true;

				// reset key cache

				var h, hl = this.hierarchy.length,
					object,
					node;

				for ( h = 0; h < hl; h ++ ) {

					object = this.hierarchy[ h ];
					node = this.data.hierarchy[ h ];

					if ( node.animationCache === undefined ) {

						node.animationCache = {};
						node.animationCache.prevKey = null;
						node.animationCache.nextKey = null;
						node.animationCache.originalMatrix = object.matrix;

					}

					var keys = this.data.hierarchy[h].keys;

					if (keys.length) {

						node.animationCache.prevKey = keys[ 0 ];
						node.animationCache.nextKey = keys[ 1 ];

						this.startTime = Math.min( keys[0].time, this.startTime );
						this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

					}

				}

				this.update( 0 );

			}

			this.isPaused = false;

			THREE.AnimationHandler.play( this );

		},

		stop: function () {

			this.isPlaying = false;
			this.isPaused  = false;

			THREE.AnimationHandler.stop( this );

			// reset JIT matrix and remove cache

			for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

				var obj = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				if ( node.animationCache !== undefined ) {

					var original = node.animationCache.originalMatrix;

					original.copy( obj.matrix );
					obj.matrix = original;

					delete node.animationCache;

				}

			}

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta * this.timeScale;

			//

			var duration = this.data.length;

			if ( this.loop === true && this.currentTime > duration ) {

				this.currentTime %= duration;

			}

			this.currentTime = Math.min( this.currentTime, duration );

			for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

				var object = this.hierarchy[ h ];
				var node = this.data.hierarchy[ h ];

				var keys = node.keys,
					animationCache = node.animationCache;


				if ( keys.length ) {

					var prevKey = animationCache.prevKey;
					var nextKey = animationCache.nextKey;

					if ( nextKey.time <= this.currentTime ) {

						while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;

					}

					if ( nextKey.time >= this.currentTime ) {

						prevKey.interpolate( nextKey, this.currentTime );

					} else {

						prevKey.interpolate( nextKey, nextKey.time );

					}

					this.data.hierarchy[ h ].node.updateMatrix();
					object.matrixWorldNeedsUpdate = true;

				}

			}

		},

		getNextKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key % keys.length;

			for ( ; key < keys.length; key ++ ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ 0 ];

		},

		getPrevKeyWith: function ( sid, h, key ) {

			var keys = this.data.hierarchy[ h ].keys;
			key = key >= 0 ? key : key + keys.length;

			for ( ; key >= 0; key -- ) {

				if ( keys[ key ].hasTarget( sid ) ) {

					return keys[ key ];

				}

			}

			return keys[ keys.length - 1 ];

		}

	};

	// File:src/extras/animation/MorphAnimation.js

	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author willy-vvu / http://willy-vvu.github.io
	 */

	THREE.MorphAnimation = function ( mesh ) {

		this.mesh = mesh;
		this.frames = mesh.morphTargetInfluences.length;
		this.currentTime = 0;
		this.duration = 1000;
		this.loop = true;
		this.lastFrame = 0;
		this.currentFrame = 0;

		this.isPlaying = false;

	};

	THREE.MorphAnimation.prototype = {

		constructor: THREE.MorphAnimation,

		play: function () {

			this.isPlaying = true;

		},

		pause: function () {

			this.isPlaying = false;

		},

		update: function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			var influences = this.mesh.morphTargetInfluences;

			if ( frame != this.currentFrame ) {

				influences[ this.lastFrame ] = 0;
				influences[ this.currentFrame ] = 1;
				influences[ frame ] = 0;

				this.lastFrame = this.currentFrame;
				this.currentFrame = frame;

			}

			influences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			influences[ this.lastFrame ] = 1 - influences[ frame ];

		}

	};

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;

		var scope = this;

		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;

		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;

			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

				w = 'z';

			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

				w = 'y';
				gridY = scope.depthSegments;

			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

				w = 'x';
				gridX = scope.depthSegments;

			}

			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();

			normal[ w ] = depth > 0 ? 1 : - 1;

			for ( iy = 0; iy < gridY1; iy ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;

					scope.vertices.push( vector );

				}

			}

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

				}

			}

		}

		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var i, uvs = [],
		center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

		this.vertices.push(center);
		uvs.push( centerUV );

		for ( i = 0; i <= segments; i ++ ) {

			var vertex = new THREE.Vector3();
			var segment = thetaStart + i / segments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 1; i <= segments; i ++ ) {

			this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

	// File:src/extras/geometries/CubeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
		return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

	 };

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

		var heightHalf = height / 2;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;

		for ( x = 0; x < radialSegments; x ++ ) {

			if ( radiusTop !== 0 ) {

				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

			} else {

				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

			}

			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

			for ( y = 0; y < heightSegments; y ++ ) {

				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];

				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();

				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

		// top cap

		if ( openEnded === false && radiusTop > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );

				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		// bottom cap

		if ( openEnded === false && radiusBottom > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );

				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  material: <int> // material index for front and back faces
	 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function ( shapes, options ) {

		if ( typeof( shapes ) === "undefined" ) {
			shapes = [];
			return;
		}

		THREE.Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		shapes = shapes instanceof Array ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
		var sl = shapes.length;

		for ( var s = 0; s < sl; s ++ ) {
			var shape = shapes[ s ];
			this.addShape( shape, options );
		}
	};

	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		var material = options.material;
		var extrudeMaterial = options.extrudeMaterial;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initalization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2 ( pt, vec, size ) {

			if ( ! vec ) THREE.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			var EPSILON = 0.0000000001;
			
			// computes for inPt the corresponding point inPt' on a new contour
			//   shiftet by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.
			
			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
			
			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
			
			// check for colinear edges
			var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
			
			if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
				
				// length of vectors for normalizing
		
				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
				
				// shift adjacent points by unit vectors to the left
		
				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
				
				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
		
				// scaling factor for v_prev to intersection point
		
				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
				// vector from inPt to intersection point
		
				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
		
				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
				if ( v_trans_lensq <= 2 ) {
					return	new THREE.Vector2( v_trans_x, v_trans_y );
				} else {
					shrink_by = Math.sqrt( v_trans_lensq / 2 );
				}
				
			} else {		// handle special case of colinear edges

				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > EPSILON ) {
					if ( v_next_x > EPSILON ) { direction_eq = true; }
				} else {
					if ( v_prev_x < - EPSILON ) {
						if ( v_next_x < - EPSILON ) { direction_eq = true; }
					} else {
						if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
					}
				}

				if ( direction_eq ) {
					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );
				} else {
					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );
				}

			}

			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {
		//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );

			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved
			//bs = bevelSize * t ; // linear

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
				binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

				position2.copy( extrudePts[0] ).add(normal).add(binormal);

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[s] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y,  amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if ( bevelEnabled ) {

				var layer = 0 ; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}
			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps  + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d, contour, s, sl, j, k );

				}
			}

		}


		function v( x, y, z ) {

			scope.vertices.push( new THREE.Vector3( x, y, z ) );

		}

		function f3( a, b, c ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			// normal, color, material
			scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

			var uvs = uvgen.generateTopUV( scope, a, b, c );

			scope.faceVertexUvs[ 0 ].push( uvs );

		}

		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, indexA, indexB, indexC ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];

			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];

		},

		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];

			if ( Math.abs( a.y - b.y ) < 0.01 ) {
				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];
			} else {
				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];
			}
		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function ( shapes, options ) {

		THREE.Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( shapes instanceof Array === false ) shapes = [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			this.addShape( shapes[ i ], options );

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];

				if ( THREE.Shape.Utils.isClockWise( hole ) ) {

					holes[ i ] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

		// Vertices

		var contour = vertices;

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];
			vertices = vertices.concat( hole );

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;

		for ( i = 0; i < vlen; i ++ ) {

			vert = vertices[ i ];

			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

		}

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];

			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;

			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

		}

	};

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */

	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

		THREE.Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;

		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;

		for ( var i = 0, il = segments; i <= il; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var c = Math.cos( phi ),
				s = Math.sin( phi );

			for ( var j = 0, jl = points.length; j < jl; j ++ ) {

				var pt = points[ j ];

				var vertex = new THREE.Vector3();

				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;

				this.vertices.push( vertex );

			}

		}

		var np = points.length;

		for ( var i = 0, il = segments; i < il; i ++ ) {

			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;

				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;

				this.faces.push( new THREE.Face3( a, b, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )

				] );

				this.faces.push( new THREE.Face3( b, c, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )

				] );


			}

		}

		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

		console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

		THREE.Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

	};

	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = widthSegments || 1;
		var gridY = heightSegments || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );

		var offset = 0;
		var offset2 = 0;

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices[ offset     ] = x;
				vertices[ offset + 1 ] = - y;

				normals[ offset + 2 ] = 1;

				uvs[ offset2     ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

		for ( var iy = 0; iy < gridY; iy ++ ) {

			for ( var ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				indices[ offset     ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;

				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;

				offset += 6;

			}

		}

		this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	};

	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

		for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

			for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
			}

			radius += radiusStep;

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

			var thetaSegment = i * (thetaSegments + 1);

			for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

				var segment = o + thetaSegment;

				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			}
		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;


	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength 
		};

		radius = radius || 50;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			for ( x = 0; x <= widthSegments; x ++ ) {

				var u = x / widthSegments;
				var v = y / heightSegments;

				var vertex = new THREE.Vector3();
				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		for ( y = 0; y < heightSegments; y ++ ) {

			for ( x = 0; x < widthSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];

				var n1 = this.vertices[ v1 ].clone().normalize();
				var n2 = this.vertices[ v2 ].clone().normalize();
				var n3 = this.vertices[ v3 ].clone().normalize();
				var n4 = this.vertices[ v4 ].clone().normalize();

				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x ].clone();
				var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

				if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

					uv1.x = ( uv1.x + uv2.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

				} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

					uv3.x = ( uv3.x + uv4.x ) / 2;
					this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

				} else {

					this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

					this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

				}

			}

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

	// File:src/extras/geometries/TextGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */

	/*	Usage Examples

		// TextGeometry wrapper

		var text3d = new TextGeometry( text, options );

		// Complete manner

		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );

	*/


	THREE.TextGeometry = function ( text, parameters ) {

		parameters = parameters || {};

		var textShapes = THREE.FontUtils.generateShapes( text, parameters );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		THREE.ExtrudeGeometry.call( this, textShapes, parameters );

		this.type = 'TextGeometry';

	};

	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

		THREE.Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;

		var center = new THREE.Vector3(), uvs = [], normals = [];

		for ( var j = 0; j <= radialSegments; j ++ ) {

			for ( var i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );

				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				this.vertices.push( vertex );

				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );

			}

		}

		for ( var j = 1; j <= radialSegments; j ++ ) {

			for ( var i = 1; i <= tubularSegments; i ++ ) {

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */

	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

		THREE.Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;
		
		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();

		for ( var i = 0; i < radialSegments; ++ i ) {

			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );

				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;

				grid[ i ][ j ] = this.vertices.push( pos ) - 1;

			}

		}

		for ( var i = 0; i < radialSegments; ++ i ) {

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;

				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];

				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}
		}

		this.computeFaceNormals();
		this.computeVertexNormals();

		function getPos( u, in_q, in_p, radius, heightScale ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );

			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

			return new THREE.Vector3( tx, ty, tz );

		}

	};

	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

		THREE.Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			u, v, r,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert( x, y, z ) {

			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

		}

		// consruct the grid

		for ( i = 0; i < numpoints; i ++ ) {

			grid[ i ] = [];

			u = i / ( numpoints - 1 );

			pos = path.getPointAt( u );

			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];

			r = radius * taper( u );

			for ( j = 0; j < radialSegments; j ++ ) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );

				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

			}
		}


		// construct the mesh

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < radialSegments; j ++ ) {

				ip = ( closed ) ? (i + 1) % segments : i + 1;
				jp = (j + 1) % radialSegments;

				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];

				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}
		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

	THREE.TubeGeometry.NoTaper = function ( u ) {

		return 1;

	};

	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

		return Math.sin( Math.PI * u );

	};

	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

		var	normal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,

			tx, ty, tz,
			i, u;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for ( i = 0; i < numpoints; i ++ ) {

			u = i / ( numpoints - 1 );

			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}

		function initialNormal2() {

			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );

			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

		}
		*/

		function initialNormal3() {
			// select an initial normal vector perpenicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= smallest ) {
				smallest = tx;
				normal.set( 1, 0, 0 );
			}

			if ( ty <= smallest ) {
				smallest = ty;
				normal.set( 0, 1, 0 );
			}

			if ( tz <= smallest ) {
				normal.set( 0, 0, 1 );
			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for ( i = 1; i < numpoints; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > epsilon ) {

				vec.normalize();

				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed ) {

			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i < numpoints; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}
	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

		THREE.Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

		}

		var p = this.vertices;

		var faces = [];

		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

			var v1 = p[ indices[ i     ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];

			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

		}

		var centroid = new THREE.Vector3();

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			subdivide( faces[ i ], detail );

		}


		// Handle case when face straddles the seam

		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			var uvs = this.faceVertexUvs[ 0 ][ i ];

			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;

			var max = Math.max( x0, Math.max( x1, x2 ) );
			var min = Math.min( x0, Math.min( x1, x2 ) );

			if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

			}

		}


		// Apply radius

		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

			this.vertices[ i ].multiplyScalar( radius );

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


		// Project vector onto sphere's surface

		function prepare( vector ) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make( v1, v2, v3 ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			that.faces.push( face );

			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

			var azi = azimuth( centroid );

			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide( face, detail ) {

			var cols = Math.pow(2, detail);
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];

			// Construct all of the vertices for this subdivision.

			for ( var i = 0 ; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;

				for ( var j = 0; j <= rows; j ++) {

					if ( j == 0 && i == cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

					}

				}

			}

			// Construct all of the faces.

			for ( var i = 0; i < cols ; i ++ ) {

				for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 == 0 ) {

						make(
							v[ i ][ k + 1],
							v[ i + 1 ][ k ],
							v[ i ][ k ]
						);

					} else {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1][ k + 1],
							v[ i + 1 ][ k ]
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV( uv, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function ( radius, detail ) {

		this.parameters = {
			radius: radius,
			detail: detail
		};

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			-1, -1, -1,    -1, -1,  1,
			-1,  1, -1,    -1,  1,  1,
			 1, -1, -1,     1, -1,  1,
			 1,  1, -1,     1,  1,  1,

			// (0, 1/, )
			 0, -r, -t,     0, -r,  t,
			 0,  r, -t,     0,  r,  t,

			// (1/, , 0)
			-r, -t,  0,    -r,  t,  0,
			 r, -t,  0,     r,  t,  0,

			// (, 0, 1/)
			-t,  0, -r,     t,  0, -r,
			-t,  0,  r,     t,  0,  r
		];

		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	};

	THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];

		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};
	};

	THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function ( radius, detail ) {

		this.parameters = {
			radius: radius,
			detail: detail
		};

		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
		];

		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};
	};

	THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function ( radius, detail ) {

		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];

		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function ( func, slices, stacks ) {

		THREE.Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];

		var i, j, p;
		var u, v;

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				u = j / slices;

				p = func( u, v );
				verts.push( p );

			}
		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j + 1;
				d = (i + 1) * sliceCount + j;

				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );

				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function ( size ) {

		size = size || 1;

		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );

		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

	};

	THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = ( function () {

		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

		return function ( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			THREE.Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );

			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

	}() );

	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

	THREE.ArrowHelper.prototype.setDirection = ( function () {

		var axis = new THREE.Vector3();
		var radians;

		return function ( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, length - headLength, 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function ( object ) {

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

		if ( object !== undefined ) {

			this.update( object );

		}

	};

	THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

	THREE.BoxHelper.prototype.update = function ( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		var min = geometry.boundingBox.min;
		var max = geometry.boundingBox.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var vertices = this.geometry.attributes.position.array;

		vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
		vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

		vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
		vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

		vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
		vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

		vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
		vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

		//

		vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
		vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

		vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
		vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

		vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
		vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

		vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
		vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

		//

		vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
		vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

		vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
		vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

		vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
		vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

		vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
		vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

		this.geometry.attributes.position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

	};

	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject( this.object );

		this.box.size( this.scale );

		this.box.center( this.position );

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function ( camera ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );

		// far

		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );

		// sides

		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );

		// cone

		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );

		// up

		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );

		// target

		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );

		// cross

		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );

		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );

		function addLine( a, b, hex ) {

			addPoint( a, hex );
			addPoint( b, hex );

		}

		function addPoint( id, hex ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( geometry.vertices.length - 1 );

		}

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

		this.camera = camera;
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;
		
		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		var setPoint = function ( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		};

		return function () {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );

			// near

			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );

			// far

			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );

			// up

			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );

			// cross

			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );

			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function ( light, size ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		size = size || 1;

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);

		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);

		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function () {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimim angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */

	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };

		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();

		var geometry2;

		if ( object.geometry instanceof THREE.BufferGeometry ) {

			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( object.geometry );

		} else {

			geometry2 = object.geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;
		var numEdges = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
					numEdges ++;

				} else {

					hash[ key ].face2 = i;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		var index = 0;

		for ( var key in hash ) {

			var h = hash[ key ];

			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

				var vertex = vertices[ h.vert1 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;

				vertex = vertices[ h.vert2 ];
				coords[ index ++ ] = vertex.x;
				coords[ index ++ ] = vertex.y;
				coords[ index ++ ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = this.object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.normalMatrix = new THREE.Matrix3();

		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

	THREE.FaceNormalsHelper.prototype.update = function () {

		var vertices = this.geometry.vertices;

		var object = this.object;
		var objectVertices = object.geometry.vertices;
		var objectFaces = object.geometry.faces;
		var objectWorldMatrix = object.matrixWorld;

		object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( objectWorldMatrix );

		for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

			var face = objectFaces[ i ];

			vertices[ i2 ].copy( objectVertices[ face.a ] )
				.add( objectVertices[ face.b ] )
				.add( objectVertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( objectWorldMatrix );

			vertices[ i2 + 1 ].copy( face.normal )
				.applyMatrix3( this.normalMatrix )
				.normalize()
				.multiplyScalar( this.size )
				.add( vertices[ i2 ] );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	};


	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function ( size, step ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );

		for ( var i = - size; i <= size; i += step ) {

			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);

			var color = i === 0 ? this.color1 : this.color2;

			geometry.colors.push( color, color, color, color );

		}

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

	};

	THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;

	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );

		this.geometry.colorsNeedUpdate = true;

	}

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function ( light, sphereSize ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [ new THREE.Color(), new THREE.Color() ];

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

		for ( var i = 0, il = 8; i < il; i ++ ) {

			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

		}

		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

	THREE.HemisphereLightHelper.prototype.dispose = function () {
		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();
	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function () {

			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;

		}

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function ( light, sphereSize ) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		THREE.Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();
	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function ( object ) {

		this.bones = this.getBoneList( object );

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

			}

		}

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		THREE.Line.call( this, geometry, material, THREE.LinePieces );

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

		var boneList = [];

		if ( object instanceof THREE.Bone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function ( light ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
		geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

	THREE.SpotLightHelper.prototype.dispose = function () {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function () {

			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.normalMatrix = new THREE.Matrix3();

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

	THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

		var v1 = new THREE.Vector3();

		return function( object ) {

			var keys = [ 'a', 'b', 'c', 'd' ];

			this.object.updateMatrixWorld( true );

			this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var vertices = this.geometry.vertices;

			var verts = this.object.geometry.vertices;

			var faces = this.object.geometry.faces;

			var worldMatrix = this.object.matrixWorld;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];

					var normal = face.vertexNormals[ j ];

					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

					v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

					v1.add( vertices[ idx ] );
					idx = idx + 1;

					vertices[ idx ].copy( v1 );
					idx = idx + 1;

				}

			}

			this.geometry.verticesNeedUpdate = true;

			return this;

		}

	}());

	// File:src/extras/helpers/VertexTangentsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0x0000ff;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		var geometry = new THREE.Geometry();

		var faces = object.geometry.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

	THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

		var v1 = new THREE.Vector3();

		return function( object ) {

			var keys = [ 'a', 'b', 'c', 'd' ];

			this.object.updateMatrixWorld( true );

			var vertices = this.geometry.vertices;

			var verts = this.object.geometry.vertices;

			var faces = this.object.geometry.faces;

			var worldMatrix = this.object.matrixWorld;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

					var vertexId = face[ keys[ j ] ];
					var vertex = verts[ vertexId ];

					var tangent = face.vertexTangents[ j ];

					vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

					v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

					v1.add( vertices[ idx ] );
					idx = idx + 1;

					vertices[ idx ].copy( v1 );
					idx = idx + 1;

				}

			}

			this.geometry.verticesNeedUpdate = true;

			return this;

		}

	}());

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		var edge = [ 0, 0 ], hash = {};
		var sortFunction = function ( a, b ) { return a - b };

		var keys = [ 'a', 'b', 'c' ];
		var geometry = new THREE.BufferGeometry();

		if ( object.geometry instanceof THREE.Geometry ) {

			var vertices = object.geometry.vertices;
			var faces = object.geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var vertex = vertices[ edges [ 2 * i + j] ];

					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else if ( object.geometry instanceof THREE.BufferGeometry ) {

			if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

				var vertices = object.geometry.attributes.position.array;
				var indices = object.geometry.attributes.index.array;
				var drawcalls = object.geometry.drawcalls;
				var numEdges = 0;

				if ( drawcalls.length === 0 ) {

					drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

				}

				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );

				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

					var start = drawcalls[ o ].start;
					var count = drawcalls[ o ].count;
					var index = drawcalls[ o ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						for ( var j = 0; j < 3; j ++ ) {

							edge[ 0 ] = index + indices[ i + j ];
							edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );

							var key = edge.toString();

							if ( hash[ key ] === undefined ) {

								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;

							}

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var index = 6 * i + 3 * j;
						var index2 = 3 * edges[ 2 * i + j];
						coords[ index + 0 ] = vertices[ index2 ];
						coords[ index + 1 ] = vertices[ index2 + 1 ];
						coords[ index + 2 ] = vertices[ index2 + 2 ];

					}

				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			} else { // non-indexed BufferGeometry

				var vertices = object.geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numTris; i < l; i ++ ) {

					for ( var j = 0; j < 3; j ++ ) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];

						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];

					}

				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			}

		}

		THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function () {

		THREE.Object3D.call( this );

		this.render = function ( renderCallback ) {};

	};

	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );

	};

	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

		var animation = {

			startFrame: start,
			endFrame: end,

			length: end - start + 1,

			fps: fps,
			duration: ( end - start ) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

		var pattern = /([a-z]+)_?(\d+)/;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );

			if ( chunks && chunks.length > 1 ) {

				var name = chunks[ 1 ];

				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

				var range = frameRanges[ name ];

				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;

				if ( ! firstAnimation ) firstAnimation = name;

			}

		}

		for ( var name in frameRanges ) {

			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

		var time = 0;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

		var duration = - 1;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = 0;
			animation.active = true;

		} else {

			THREE.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function ( delta ) {

		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

			var animation = this.animationsList[ i ];

			if ( ! animation.active ) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if ( animation.mirroredLoop ) {

				if ( animation.time > animation.duration || animation.time < 0 ) {

					animation.direction *= - 1;

					if ( animation.time > animation.duration ) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if ( animation.time < 0 ) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if ( animation.time < 0 ) animation.time += animation.duration;

			}

			var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;

			if ( keyframe !== animation.currentFrame ) {

				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

				this.morphTargetInfluences[ keyframe ] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = ( animation.time % frameTime ) / frameTime;

			if ( animation.directionBackwards ) mix = 1 - mix;

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		}

	};



/***/ }
/******/ ]);